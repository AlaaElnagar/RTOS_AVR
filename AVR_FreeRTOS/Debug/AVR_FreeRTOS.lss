
AVR_FreeRTOS.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00004932  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000018  00800060  00004932  000049c6  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000064e  00800078  00800078  000049de  2**0
                  ALLOC
  3 .stab         000079f8  00000000  00000000  000049e0  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      000048fc  00000000  00000000  0000c3d8  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 1a 03 	jmp	0x634	; 0x634 <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e2 e3       	ldi	r30, 0x32	; 50
      68:	f9 e4       	ldi	r31, 0x49	; 73
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	a8 37       	cpi	r26, 0x78	; 120
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	16 e0       	ldi	r17, 0x06	; 6
      78:	a8 e7       	ldi	r26, 0x78	; 120
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a6 3c       	cpi	r26, 0xC6	; 198
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 47 24 	call	0x488e	; 0x488e <main>
      8a:	0c 94 97 24 	jmp	0x492e	; 0x492e <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <pxPortInitialiseStack>:
      92:	df 93       	push	r29
      94:	cf 93       	push	r28
      96:	cd b7       	in	r28, 0x3d	; 61
      98:	de b7       	in	r29, 0x3e	; 62
      9a:	28 97       	sbiw	r28, 0x08	; 8
      9c:	0f b6       	in	r0, 0x3f	; 63
      9e:	f8 94       	cli
      a0:	de bf       	out	0x3e, r29	; 62
      a2:	0f be       	out	0x3f, r0	; 63
      a4:	cd bf       	out	0x3d, r28	; 61
      a6:	9c 83       	std	Y+4, r25	; 0x04
      a8:	8b 83       	std	Y+3, r24	; 0x03
      aa:	7e 83       	std	Y+6, r23	; 0x06
      ac:	6d 83       	std	Y+5, r22	; 0x05
      ae:	58 87       	std	Y+8, r21	; 0x08
      b0:	4f 83       	std	Y+7, r20	; 0x07
      b2:	eb 81       	ldd	r30, Y+3	; 0x03
      b4:	fc 81       	ldd	r31, Y+4	; 0x04
      b6:	81 e1       	ldi	r24, 0x11	; 17
      b8:	80 83       	st	Z, r24
      ba:	8b 81       	ldd	r24, Y+3	; 0x03
      bc:	9c 81       	ldd	r25, Y+4	; 0x04
      be:	01 97       	sbiw	r24, 0x01	; 1
      c0:	9c 83       	std	Y+4, r25	; 0x04
      c2:	8b 83       	std	Y+3, r24	; 0x03
      c4:	eb 81       	ldd	r30, Y+3	; 0x03
      c6:	fc 81       	ldd	r31, Y+4	; 0x04
      c8:	82 e2       	ldi	r24, 0x22	; 34
      ca:	80 83       	st	Z, r24
      cc:	8b 81       	ldd	r24, Y+3	; 0x03
      ce:	9c 81       	ldd	r25, Y+4	; 0x04
      d0:	01 97       	sbiw	r24, 0x01	; 1
      d2:	9c 83       	std	Y+4, r25	; 0x04
      d4:	8b 83       	std	Y+3, r24	; 0x03
      d6:	eb 81       	ldd	r30, Y+3	; 0x03
      d8:	fc 81       	ldd	r31, Y+4	; 0x04
      da:	83 e3       	ldi	r24, 0x33	; 51
      dc:	80 83       	st	Z, r24
      de:	8b 81       	ldd	r24, Y+3	; 0x03
      e0:	9c 81       	ldd	r25, Y+4	; 0x04
      e2:	01 97       	sbiw	r24, 0x01	; 1
      e4:	9c 83       	std	Y+4, r25	; 0x04
      e6:	8b 83       	std	Y+3, r24	; 0x03
      e8:	8d 81       	ldd	r24, Y+5	; 0x05
      ea:	9e 81       	ldd	r25, Y+6	; 0x06
      ec:	9a 83       	std	Y+2, r25	; 0x02
      ee:	89 83       	std	Y+1, r24	; 0x01
      f0:	89 81       	ldd	r24, Y+1	; 0x01
      f2:	eb 81       	ldd	r30, Y+3	; 0x03
      f4:	fc 81       	ldd	r31, Y+4	; 0x04
      f6:	80 83       	st	Z, r24
      f8:	8b 81       	ldd	r24, Y+3	; 0x03
      fa:	9c 81       	ldd	r25, Y+4	; 0x04
      fc:	01 97       	sbiw	r24, 0x01	; 1
      fe:	9c 83       	std	Y+4, r25	; 0x04
     100:	8b 83       	std	Y+3, r24	; 0x03
     102:	89 81       	ldd	r24, Y+1	; 0x01
     104:	9a 81       	ldd	r25, Y+2	; 0x02
     106:	89 2f       	mov	r24, r25
     108:	99 27       	eor	r25, r25
     10a:	9a 83       	std	Y+2, r25	; 0x02
     10c:	89 83       	std	Y+1, r24	; 0x01
     10e:	89 81       	ldd	r24, Y+1	; 0x01
     110:	eb 81       	ldd	r30, Y+3	; 0x03
     112:	fc 81       	ldd	r31, Y+4	; 0x04
     114:	80 83       	st	Z, r24
     116:	8b 81       	ldd	r24, Y+3	; 0x03
     118:	9c 81       	ldd	r25, Y+4	; 0x04
     11a:	01 97       	sbiw	r24, 0x01	; 1
     11c:	9c 83       	std	Y+4, r25	; 0x04
     11e:	8b 83       	std	Y+3, r24	; 0x03
     120:	eb 81       	ldd	r30, Y+3	; 0x03
     122:	fc 81       	ldd	r31, Y+4	; 0x04
     124:	10 82       	st	Z, r1
     126:	8b 81       	ldd	r24, Y+3	; 0x03
     128:	9c 81       	ldd	r25, Y+4	; 0x04
     12a:	01 97       	sbiw	r24, 0x01	; 1
     12c:	9c 83       	std	Y+4, r25	; 0x04
     12e:	8b 83       	std	Y+3, r24	; 0x03
     130:	eb 81       	ldd	r30, Y+3	; 0x03
     132:	fc 81       	ldd	r31, Y+4	; 0x04
     134:	80 e8       	ldi	r24, 0x80	; 128
     136:	80 83       	st	Z, r24
     138:	8b 81       	ldd	r24, Y+3	; 0x03
     13a:	9c 81       	ldd	r25, Y+4	; 0x04
     13c:	01 97       	sbiw	r24, 0x01	; 1
     13e:	9c 83       	std	Y+4, r25	; 0x04
     140:	8b 83       	std	Y+3, r24	; 0x03
     142:	eb 81       	ldd	r30, Y+3	; 0x03
     144:	fc 81       	ldd	r31, Y+4	; 0x04
     146:	10 82       	st	Z, r1
     148:	8b 81       	ldd	r24, Y+3	; 0x03
     14a:	9c 81       	ldd	r25, Y+4	; 0x04
     14c:	01 97       	sbiw	r24, 0x01	; 1
     14e:	9c 83       	std	Y+4, r25	; 0x04
     150:	8b 83       	std	Y+3, r24	; 0x03
     152:	eb 81       	ldd	r30, Y+3	; 0x03
     154:	fc 81       	ldd	r31, Y+4	; 0x04
     156:	82 e0       	ldi	r24, 0x02	; 2
     158:	80 83       	st	Z, r24
     15a:	8b 81       	ldd	r24, Y+3	; 0x03
     15c:	9c 81       	ldd	r25, Y+4	; 0x04
     15e:	01 97       	sbiw	r24, 0x01	; 1
     160:	9c 83       	std	Y+4, r25	; 0x04
     162:	8b 83       	std	Y+3, r24	; 0x03
     164:	eb 81       	ldd	r30, Y+3	; 0x03
     166:	fc 81       	ldd	r31, Y+4	; 0x04
     168:	83 e0       	ldi	r24, 0x03	; 3
     16a:	80 83       	st	Z, r24
     16c:	8b 81       	ldd	r24, Y+3	; 0x03
     16e:	9c 81       	ldd	r25, Y+4	; 0x04
     170:	01 97       	sbiw	r24, 0x01	; 1
     172:	9c 83       	std	Y+4, r25	; 0x04
     174:	8b 83       	std	Y+3, r24	; 0x03
     176:	eb 81       	ldd	r30, Y+3	; 0x03
     178:	fc 81       	ldd	r31, Y+4	; 0x04
     17a:	84 e0       	ldi	r24, 0x04	; 4
     17c:	80 83       	st	Z, r24
     17e:	8b 81       	ldd	r24, Y+3	; 0x03
     180:	9c 81       	ldd	r25, Y+4	; 0x04
     182:	01 97       	sbiw	r24, 0x01	; 1
     184:	9c 83       	std	Y+4, r25	; 0x04
     186:	8b 83       	std	Y+3, r24	; 0x03
     188:	eb 81       	ldd	r30, Y+3	; 0x03
     18a:	fc 81       	ldd	r31, Y+4	; 0x04
     18c:	85 e0       	ldi	r24, 0x05	; 5
     18e:	80 83       	st	Z, r24
     190:	8b 81       	ldd	r24, Y+3	; 0x03
     192:	9c 81       	ldd	r25, Y+4	; 0x04
     194:	01 97       	sbiw	r24, 0x01	; 1
     196:	9c 83       	std	Y+4, r25	; 0x04
     198:	8b 83       	std	Y+3, r24	; 0x03
     19a:	eb 81       	ldd	r30, Y+3	; 0x03
     19c:	fc 81       	ldd	r31, Y+4	; 0x04
     19e:	86 e0       	ldi	r24, 0x06	; 6
     1a0:	80 83       	st	Z, r24
     1a2:	8b 81       	ldd	r24, Y+3	; 0x03
     1a4:	9c 81       	ldd	r25, Y+4	; 0x04
     1a6:	01 97       	sbiw	r24, 0x01	; 1
     1a8:	9c 83       	std	Y+4, r25	; 0x04
     1aa:	8b 83       	std	Y+3, r24	; 0x03
     1ac:	eb 81       	ldd	r30, Y+3	; 0x03
     1ae:	fc 81       	ldd	r31, Y+4	; 0x04
     1b0:	87 e0       	ldi	r24, 0x07	; 7
     1b2:	80 83       	st	Z, r24
     1b4:	8b 81       	ldd	r24, Y+3	; 0x03
     1b6:	9c 81       	ldd	r25, Y+4	; 0x04
     1b8:	01 97       	sbiw	r24, 0x01	; 1
     1ba:	9c 83       	std	Y+4, r25	; 0x04
     1bc:	8b 83       	std	Y+3, r24	; 0x03
     1be:	eb 81       	ldd	r30, Y+3	; 0x03
     1c0:	fc 81       	ldd	r31, Y+4	; 0x04
     1c2:	88 e0       	ldi	r24, 0x08	; 8
     1c4:	80 83       	st	Z, r24
     1c6:	8b 81       	ldd	r24, Y+3	; 0x03
     1c8:	9c 81       	ldd	r25, Y+4	; 0x04
     1ca:	01 97       	sbiw	r24, 0x01	; 1
     1cc:	9c 83       	std	Y+4, r25	; 0x04
     1ce:	8b 83       	std	Y+3, r24	; 0x03
     1d0:	eb 81       	ldd	r30, Y+3	; 0x03
     1d2:	fc 81       	ldd	r31, Y+4	; 0x04
     1d4:	89 e0       	ldi	r24, 0x09	; 9
     1d6:	80 83       	st	Z, r24
     1d8:	8b 81       	ldd	r24, Y+3	; 0x03
     1da:	9c 81       	ldd	r25, Y+4	; 0x04
     1dc:	01 97       	sbiw	r24, 0x01	; 1
     1de:	9c 83       	std	Y+4, r25	; 0x04
     1e0:	8b 83       	std	Y+3, r24	; 0x03
     1e2:	eb 81       	ldd	r30, Y+3	; 0x03
     1e4:	fc 81       	ldd	r31, Y+4	; 0x04
     1e6:	80 e1       	ldi	r24, 0x10	; 16
     1e8:	80 83       	st	Z, r24
     1ea:	8b 81       	ldd	r24, Y+3	; 0x03
     1ec:	9c 81       	ldd	r25, Y+4	; 0x04
     1ee:	01 97       	sbiw	r24, 0x01	; 1
     1f0:	9c 83       	std	Y+4, r25	; 0x04
     1f2:	8b 83       	std	Y+3, r24	; 0x03
     1f4:	eb 81       	ldd	r30, Y+3	; 0x03
     1f6:	fc 81       	ldd	r31, Y+4	; 0x04
     1f8:	81 e1       	ldi	r24, 0x11	; 17
     1fa:	80 83       	st	Z, r24
     1fc:	8b 81       	ldd	r24, Y+3	; 0x03
     1fe:	9c 81       	ldd	r25, Y+4	; 0x04
     200:	01 97       	sbiw	r24, 0x01	; 1
     202:	9c 83       	std	Y+4, r25	; 0x04
     204:	8b 83       	std	Y+3, r24	; 0x03
     206:	eb 81       	ldd	r30, Y+3	; 0x03
     208:	fc 81       	ldd	r31, Y+4	; 0x04
     20a:	82 e1       	ldi	r24, 0x12	; 18
     20c:	80 83       	st	Z, r24
     20e:	8b 81       	ldd	r24, Y+3	; 0x03
     210:	9c 81       	ldd	r25, Y+4	; 0x04
     212:	01 97       	sbiw	r24, 0x01	; 1
     214:	9c 83       	std	Y+4, r25	; 0x04
     216:	8b 83       	std	Y+3, r24	; 0x03
     218:	eb 81       	ldd	r30, Y+3	; 0x03
     21a:	fc 81       	ldd	r31, Y+4	; 0x04
     21c:	83 e1       	ldi	r24, 0x13	; 19
     21e:	80 83       	st	Z, r24
     220:	8b 81       	ldd	r24, Y+3	; 0x03
     222:	9c 81       	ldd	r25, Y+4	; 0x04
     224:	01 97       	sbiw	r24, 0x01	; 1
     226:	9c 83       	std	Y+4, r25	; 0x04
     228:	8b 83       	std	Y+3, r24	; 0x03
     22a:	eb 81       	ldd	r30, Y+3	; 0x03
     22c:	fc 81       	ldd	r31, Y+4	; 0x04
     22e:	84 e1       	ldi	r24, 0x14	; 20
     230:	80 83       	st	Z, r24
     232:	8b 81       	ldd	r24, Y+3	; 0x03
     234:	9c 81       	ldd	r25, Y+4	; 0x04
     236:	01 97       	sbiw	r24, 0x01	; 1
     238:	9c 83       	std	Y+4, r25	; 0x04
     23a:	8b 83       	std	Y+3, r24	; 0x03
     23c:	eb 81       	ldd	r30, Y+3	; 0x03
     23e:	fc 81       	ldd	r31, Y+4	; 0x04
     240:	85 e1       	ldi	r24, 0x15	; 21
     242:	80 83       	st	Z, r24
     244:	8b 81       	ldd	r24, Y+3	; 0x03
     246:	9c 81       	ldd	r25, Y+4	; 0x04
     248:	01 97       	sbiw	r24, 0x01	; 1
     24a:	9c 83       	std	Y+4, r25	; 0x04
     24c:	8b 83       	std	Y+3, r24	; 0x03
     24e:	eb 81       	ldd	r30, Y+3	; 0x03
     250:	fc 81       	ldd	r31, Y+4	; 0x04
     252:	86 e1       	ldi	r24, 0x16	; 22
     254:	80 83       	st	Z, r24
     256:	8b 81       	ldd	r24, Y+3	; 0x03
     258:	9c 81       	ldd	r25, Y+4	; 0x04
     25a:	01 97       	sbiw	r24, 0x01	; 1
     25c:	9c 83       	std	Y+4, r25	; 0x04
     25e:	8b 83       	std	Y+3, r24	; 0x03
     260:	eb 81       	ldd	r30, Y+3	; 0x03
     262:	fc 81       	ldd	r31, Y+4	; 0x04
     264:	87 e1       	ldi	r24, 0x17	; 23
     266:	80 83       	st	Z, r24
     268:	8b 81       	ldd	r24, Y+3	; 0x03
     26a:	9c 81       	ldd	r25, Y+4	; 0x04
     26c:	01 97       	sbiw	r24, 0x01	; 1
     26e:	9c 83       	std	Y+4, r25	; 0x04
     270:	8b 83       	std	Y+3, r24	; 0x03
     272:	eb 81       	ldd	r30, Y+3	; 0x03
     274:	fc 81       	ldd	r31, Y+4	; 0x04
     276:	88 e1       	ldi	r24, 0x18	; 24
     278:	80 83       	st	Z, r24
     27a:	8b 81       	ldd	r24, Y+3	; 0x03
     27c:	9c 81       	ldd	r25, Y+4	; 0x04
     27e:	01 97       	sbiw	r24, 0x01	; 1
     280:	9c 83       	std	Y+4, r25	; 0x04
     282:	8b 83       	std	Y+3, r24	; 0x03
     284:	eb 81       	ldd	r30, Y+3	; 0x03
     286:	fc 81       	ldd	r31, Y+4	; 0x04
     288:	89 e1       	ldi	r24, 0x19	; 25
     28a:	80 83       	st	Z, r24
     28c:	8b 81       	ldd	r24, Y+3	; 0x03
     28e:	9c 81       	ldd	r25, Y+4	; 0x04
     290:	01 97       	sbiw	r24, 0x01	; 1
     292:	9c 83       	std	Y+4, r25	; 0x04
     294:	8b 83       	std	Y+3, r24	; 0x03
     296:	eb 81       	ldd	r30, Y+3	; 0x03
     298:	fc 81       	ldd	r31, Y+4	; 0x04
     29a:	80 e2       	ldi	r24, 0x20	; 32
     29c:	80 83       	st	Z, r24
     29e:	8b 81       	ldd	r24, Y+3	; 0x03
     2a0:	9c 81       	ldd	r25, Y+4	; 0x04
     2a2:	01 97       	sbiw	r24, 0x01	; 1
     2a4:	9c 83       	std	Y+4, r25	; 0x04
     2a6:	8b 83       	std	Y+3, r24	; 0x03
     2a8:	eb 81       	ldd	r30, Y+3	; 0x03
     2aa:	fc 81       	ldd	r31, Y+4	; 0x04
     2ac:	81 e2       	ldi	r24, 0x21	; 33
     2ae:	80 83       	st	Z, r24
     2b0:	8b 81       	ldd	r24, Y+3	; 0x03
     2b2:	9c 81       	ldd	r25, Y+4	; 0x04
     2b4:	01 97       	sbiw	r24, 0x01	; 1
     2b6:	9c 83       	std	Y+4, r25	; 0x04
     2b8:	8b 83       	std	Y+3, r24	; 0x03
     2ba:	eb 81       	ldd	r30, Y+3	; 0x03
     2bc:	fc 81       	ldd	r31, Y+4	; 0x04
     2be:	82 e2       	ldi	r24, 0x22	; 34
     2c0:	80 83       	st	Z, r24
     2c2:	8b 81       	ldd	r24, Y+3	; 0x03
     2c4:	9c 81       	ldd	r25, Y+4	; 0x04
     2c6:	01 97       	sbiw	r24, 0x01	; 1
     2c8:	9c 83       	std	Y+4, r25	; 0x04
     2ca:	8b 83       	std	Y+3, r24	; 0x03
     2cc:	eb 81       	ldd	r30, Y+3	; 0x03
     2ce:	fc 81       	ldd	r31, Y+4	; 0x04
     2d0:	83 e2       	ldi	r24, 0x23	; 35
     2d2:	80 83       	st	Z, r24
     2d4:	8b 81       	ldd	r24, Y+3	; 0x03
     2d6:	9c 81       	ldd	r25, Y+4	; 0x04
     2d8:	01 97       	sbiw	r24, 0x01	; 1
     2da:	9c 83       	std	Y+4, r25	; 0x04
     2dc:	8b 83       	std	Y+3, r24	; 0x03
     2de:	8f 81       	ldd	r24, Y+7	; 0x07
     2e0:	98 85       	ldd	r25, Y+8	; 0x08
     2e2:	9a 83       	std	Y+2, r25	; 0x02
     2e4:	89 83       	std	Y+1, r24	; 0x01
     2e6:	89 81       	ldd	r24, Y+1	; 0x01
     2e8:	eb 81       	ldd	r30, Y+3	; 0x03
     2ea:	fc 81       	ldd	r31, Y+4	; 0x04
     2ec:	80 83       	st	Z, r24
     2ee:	8b 81       	ldd	r24, Y+3	; 0x03
     2f0:	9c 81       	ldd	r25, Y+4	; 0x04
     2f2:	01 97       	sbiw	r24, 0x01	; 1
     2f4:	9c 83       	std	Y+4, r25	; 0x04
     2f6:	8b 83       	std	Y+3, r24	; 0x03
     2f8:	89 81       	ldd	r24, Y+1	; 0x01
     2fa:	9a 81       	ldd	r25, Y+2	; 0x02
     2fc:	89 2f       	mov	r24, r25
     2fe:	99 27       	eor	r25, r25
     300:	9a 83       	std	Y+2, r25	; 0x02
     302:	89 83       	std	Y+1, r24	; 0x01
     304:	89 81       	ldd	r24, Y+1	; 0x01
     306:	eb 81       	ldd	r30, Y+3	; 0x03
     308:	fc 81       	ldd	r31, Y+4	; 0x04
     30a:	80 83       	st	Z, r24
     30c:	8b 81       	ldd	r24, Y+3	; 0x03
     30e:	9c 81       	ldd	r25, Y+4	; 0x04
     310:	01 97       	sbiw	r24, 0x01	; 1
     312:	9c 83       	std	Y+4, r25	; 0x04
     314:	8b 83       	std	Y+3, r24	; 0x03
     316:	eb 81       	ldd	r30, Y+3	; 0x03
     318:	fc 81       	ldd	r31, Y+4	; 0x04
     31a:	86 e2       	ldi	r24, 0x26	; 38
     31c:	80 83       	st	Z, r24
     31e:	8b 81       	ldd	r24, Y+3	; 0x03
     320:	9c 81       	ldd	r25, Y+4	; 0x04
     322:	01 97       	sbiw	r24, 0x01	; 1
     324:	9c 83       	std	Y+4, r25	; 0x04
     326:	8b 83       	std	Y+3, r24	; 0x03
     328:	eb 81       	ldd	r30, Y+3	; 0x03
     32a:	fc 81       	ldd	r31, Y+4	; 0x04
     32c:	87 e2       	ldi	r24, 0x27	; 39
     32e:	80 83       	st	Z, r24
     330:	8b 81       	ldd	r24, Y+3	; 0x03
     332:	9c 81       	ldd	r25, Y+4	; 0x04
     334:	01 97       	sbiw	r24, 0x01	; 1
     336:	9c 83       	std	Y+4, r25	; 0x04
     338:	8b 83       	std	Y+3, r24	; 0x03
     33a:	eb 81       	ldd	r30, Y+3	; 0x03
     33c:	fc 81       	ldd	r31, Y+4	; 0x04
     33e:	88 e2       	ldi	r24, 0x28	; 40
     340:	80 83       	st	Z, r24
     342:	8b 81       	ldd	r24, Y+3	; 0x03
     344:	9c 81       	ldd	r25, Y+4	; 0x04
     346:	01 97       	sbiw	r24, 0x01	; 1
     348:	9c 83       	std	Y+4, r25	; 0x04
     34a:	8b 83       	std	Y+3, r24	; 0x03
     34c:	eb 81       	ldd	r30, Y+3	; 0x03
     34e:	fc 81       	ldd	r31, Y+4	; 0x04
     350:	89 e2       	ldi	r24, 0x29	; 41
     352:	80 83       	st	Z, r24
     354:	8b 81       	ldd	r24, Y+3	; 0x03
     356:	9c 81       	ldd	r25, Y+4	; 0x04
     358:	01 97       	sbiw	r24, 0x01	; 1
     35a:	9c 83       	std	Y+4, r25	; 0x04
     35c:	8b 83       	std	Y+3, r24	; 0x03
     35e:	eb 81       	ldd	r30, Y+3	; 0x03
     360:	fc 81       	ldd	r31, Y+4	; 0x04
     362:	80 e3       	ldi	r24, 0x30	; 48
     364:	80 83       	st	Z, r24
     366:	8b 81       	ldd	r24, Y+3	; 0x03
     368:	9c 81       	ldd	r25, Y+4	; 0x04
     36a:	01 97       	sbiw	r24, 0x01	; 1
     36c:	9c 83       	std	Y+4, r25	; 0x04
     36e:	8b 83       	std	Y+3, r24	; 0x03
     370:	eb 81       	ldd	r30, Y+3	; 0x03
     372:	fc 81       	ldd	r31, Y+4	; 0x04
     374:	81 e3       	ldi	r24, 0x31	; 49
     376:	80 83       	st	Z, r24
     378:	8b 81       	ldd	r24, Y+3	; 0x03
     37a:	9c 81       	ldd	r25, Y+4	; 0x04
     37c:	01 97       	sbiw	r24, 0x01	; 1
     37e:	9c 83       	std	Y+4, r25	; 0x04
     380:	8b 83       	std	Y+3, r24	; 0x03
     382:	8b 81       	ldd	r24, Y+3	; 0x03
     384:	9c 81       	ldd	r25, Y+4	; 0x04
     386:	28 96       	adiw	r28, 0x08	; 8
     388:	0f b6       	in	r0, 0x3f	; 63
     38a:	f8 94       	cli
     38c:	de bf       	out	0x3e, r29	; 62
     38e:	0f be       	out	0x3f, r0	; 63
     390:	cd bf       	out	0x3d, r28	; 61
     392:	cf 91       	pop	r28
     394:	df 91       	pop	r29
     396:	08 95       	ret

00000398 <xPortStartScheduler>:
	return pxTopOfStack;
}
/*-----------------------------------------------------------*/

BaseType_t xPortStartScheduler( void )
{
     398:	df 93       	push	r29
     39a:	cf 93       	push	r28
     39c:	cd b7       	in	r28, 0x3d	; 61
     39e:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
     3a0:	0e 94 be 02 	call	0x57c	; 0x57c <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
     3a4:	a0 91 58 06 	lds	r26, 0x0658
     3a8:	b0 91 59 06 	lds	r27, 0x0659
     3ac:	cd 91       	ld	r28, X+
     3ae:	cd bf       	out	0x3d, r28	; 61
     3b0:	dd 91       	ld	r29, X+
     3b2:	de bf       	out	0x3e, r29	; 62
     3b4:	ff 91       	pop	r31
     3b6:	ef 91       	pop	r30
     3b8:	df 91       	pop	r29
     3ba:	cf 91       	pop	r28
     3bc:	bf 91       	pop	r27
     3be:	af 91       	pop	r26
     3c0:	9f 91       	pop	r25
     3c2:	8f 91       	pop	r24
     3c4:	7f 91       	pop	r23
     3c6:	6f 91       	pop	r22
     3c8:	5f 91       	pop	r21
     3ca:	4f 91       	pop	r20
     3cc:	3f 91       	pop	r19
     3ce:	2f 91       	pop	r18
     3d0:	1f 91       	pop	r17
     3d2:	0f 91       	pop	r16
     3d4:	ff 90       	pop	r15
     3d6:	ef 90       	pop	r14
     3d8:	df 90       	pop	r13
     3da:	cf 90       	pop	r12
     3dc:	bf 90       	pop	r11
     3de:	af 90       	pop	r10
     3e0:	9f 90       	pop	r9
     3e2:	8f 90       	pop	r8
     3e4:	7f 90       	pop	r7
     3e6:	6f 90       	pop	r6
     3e8:	5f 90       	pop	r5
     3ea:	4f 90       	pop	r4
     3ec:	3f 90       	pop	r3
     3ee:	2f 90       	pop	r2
     3f0:	1f 90       	pop	r1
     3f2:	0f 90       	pop	r0
     3f4:	0f be       	out	0x3f, r0	; 63
     3f6:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
     3f8:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
     3fa:	81 e0       	ldi	r24, 0x01	; 1
}
     3fc:	cf 91       	pop	r28
     3fe:	df 91       	pop	r29
     400:	08 95       	ret

00000402 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     402:	df 93       	push	r29
     404:	cf 93       	push	r28
     406:	cd b7       	in	r28, 0x3d	; 61
     408:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
     40a:	cf 91       	pop	r28
     40c:	df 91       	pop	r29
     40e:	08 95       	ret

00000410 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     410:	0f 92       	push	r0
     412:	0f b6       	in	r0, 0x3f	; 63
     414:	f8 94       	cli
     416:	0f 92       	push	r0
     418:	1f 92       	push	r1
     41a:	11 24       	eor	r1, r1
     41c:	2f 92       	push	r2
     41e:	3f 92       	push	r3
     420:	4f 92       	push	r4
     422:	5f 92       	push	r5
     424:	6f 92       	push	r6
     426:	7f 92       	push	r7
     428:	8f 92       	push	r8
     42a:	9f 92       	push	r9
     42c:	af 92       	push	r10
     42e:	bf 92       	push	r11
     430:	cf 92       	push	r12
     432:	df 92       	push	r13
     434:	ef 92       	push	r14
     436:	ff 92       	push	r15
     438:	0f 93       	push	r16
     43a:	1f 93       	push	r17
     43c:	2f 93       	push	r18
     43e:	3f 93       	push	r19
     440:	4f 93       	push	r20
     442:	5f 93       	push	r21
     444:	6f 93       	push	r22
     446:	7f 93       	push	r23
     448:	8f 93       	push	r24
     44a:	9f 93       	push	r25
     44c:	af 93       	push	r26
     44e:	bf 93       	push	r27
     450:	cf 93       	push	r28
     452:	df 93       	push	r29
     454:	ef 93       	push	r30
     456:	ff 93       	push	r31
     458:	a0 91 58 06 	lds	r26, 0x0658
     45c:	b0 91 59 06 	lds	r27, 0x0659
     460:	0d b6       	in	r0, 0x3d	; 61
     462:	0d 92       	st	X+, r0
     464:	0e b6       	in	r0, 0x3e	; 62
     466:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     468:	0e 94 96 1c 	call	0x392c	; 0x392c <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     46c:	a0 91 58 06 	lds	r26, 0x0658
     470:	b0 91 59 06 	lds	r27, 0x0659
     474:	cd 91       	ld	r28, X+
     476:	cd bf       	out	0x3d, r28	; 61
     478:	dd 91       	ld	r29, X+
     47a:	de bf       	out	0x3e, r29	; 62
     47c:	ff 91       	pop	r31
     47e:	ef 91       	pop	r30
     480:	df 91       	pop	r29
     482:	cf 91       	pop	r28
     484:	bf 91       	pop	r27
     486:	af 91       	pop	r26
     488:	9f 91       	pop	r25
     48a:	8f 91       	pop	r24
     48c:	7f 91       	pop	r23
     48e:	6f 91       	pop	r22
     490:	5f 91       	pop	r21
     492:	4f 91       	pop	r20
     494:	3f 91       	pop	r19
     496:	2f 91       	pop	r18
     498:	1f 91       	pop	r17
     49a:	0f 91       	pop	r16
     49c:	ff 90       	pop	r15
     49e:	ef 90       	pop	r14
     4a0:	df 90       	pop	r13
     4a2:	cf 90       	pop	r12
     4a4:	bf 90       	pop	r11
     4a6:	af 90       	pop	r10
     4a8:	9f 90       	pop	r9
     4aa:	8f 90       	pop	r8
     4ac:	7f 90       	pop	r7
     4ae:	6f 90       	pop	r6
     4b0:	5f 90       	pop	r5
     4b2:	4f 90       	pop	r4
     4b4:	3f 90       	pop	r3
     4b6:	2f 90       	pop	r2
     4b8:	1f 90       	pop	r1
     4ba:	0f 90       	pop	r0
     4bc:	0f be       	out	0x3f, r0	; 63
     4be:	0f 90       	pop	r0

	asm volatile ( "ret" );
     4c0:	08 95       	ret

000004c2 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     4c2:	0f 92       	push	r0
     4c4:	0f b6       	in	r0, 0x3f	; 63
     4c6:	f8 94       	cli
     4c8:	0f 92       	push	r0
     4ca:	1f 92       	push	r1
     4cc:	11 24       	eor	r1, r1
     4ce:	2f 92       	push	r2
     4d0:	3f 92       	push	r3
     4d2:	4f 92       	push	r4
     4d4:	5f 92       	push	r5
     4d6:	6f 92       	push	r6
     4d8:	7f 92       	push	r7
     4da:	8f 92       	push	r8
     4dc:	9f 92       	push	r9
     4de:	af 92       	push	r10
     4e0:	bf 92       	push	r11
     4e2:	cf 92       	push	r12
     4e4:	df 92       	push	r13
     4e6:	ef 92       	push	r14
     4e8:	ff 92       	push	r15
     4ea:	0f 93       	push	r16
     4ec:	1f 93       	push	r17
     4ee:	2f 93       	push	r18
     4f0:	3f 93       	push	r19
     4f2:	4f 93       	push	r20
     4f4:	5f 93       	push	r21
     4f6:	6f 93       	push	r22
     4f8:	7f 93       	push	r23
     4fa:	8f 93       	push	r24
     4fc:	9f 93       	push	r25
     4fe:	af 93       	push	r26
     500:	bf 93       	push	r27
     502:	cf 93       	push	r28
     504:	df 93       	push	r29
     506:	ef 93       	push	r30
     508:	ff 93       	push	r31
     50a:	a0 91 58 06 	lds	r26, 0x0658
     50e:	b0 91 59 06 	lds	r27, 0x0659
     512:	0d b6       	in	r0, 0x3d	; 61
     514:	0d 92       	st	X+, r0
     516:	0e b6       	in	r0, 0x3e	; 62
     518:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
     51a:	0e 94 b1 1b 	call	0x3762	; 0x3762 <xTaskIncrementTick>
     51e:	88 23       	and	r24, r24
     520:	11 f0       	breq	.+4      	; 0x526 <vPortYieldFromTick+0x64>
	{
		vTaskSwitchContext();
     522:	0e 94 96 1c 	call	0x392c	; 0x392c <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
     526:	a0 91 58 06 	lds	r26, 0x0658
     52a:	b0 91 59 06 	lds	r27, 0x0659
     52e:	cd 91       	ld	r28, X+
     530:	cd bf       	out	0x3d, r28	; 61
     532:	dd 91       	ld	r29, X+
     534:	de bf       	out	0x3e, r29	; 62
     536:	ff 91       	pop	r31
     538:	ef 91       	pop	r30
     53a:	df 91       	pop	r29
     53c:	cf 91       	pop	r28
     53e:	bf 91       	pop	r27
     540:	af 91       	pop	r26
     542:	9f 91       	pop	r25
     544:	8f 91       	pop	r24
     546:	7f 91       	pop	r23
     548:	6f 91       	pop	r22
     54a:	5f 91       	pop	r21
     54c:	4f 91       	pop	r20
     54e:	3f 91       	pop	r19
     550:	2f 91       	pop	r18
     552:	1f 91       	pop	r17
     554:	0f 91       	pop	r16
     556:	ff 90       	pop	r15
     558:	ef 90       	pop	r14
     55a:	df 90       	pop	r13
     55c:	cf 90       	pop	r12
     55e:	bf 90       	pop	r11
     560:	af 90       	pop	r10
     562:	9f 90       	pop	r9
     564:	8f 90       	pop	r8
     566:	7f 90       	pop	r7
     568:	6f 90       	pop	r6
     56a:	5f 90       	pop	r5
     56c:	4f 90       	pop	r4
     56e:	3f 90       	pop	r3
     570:	2f 90       	pop	r2
     572:	1f 90       	pop	r1
     574:	0f 90       	pop	r0
     576:	0f be       	out	0x3f, r0	; 63
     578:	0f 90       	pop	r0

	asm volatile ( "ret" );
     57a:	08 95       	ret

0000057c <prvSetupTimerInterrupt>:

/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
     57c:	df 93       	push	r29
     57e:	cf 93       	push	r28
     580:	00 d0       	rcall	.+0      	; 0x582 <prvSetupTimerInterrupt+0x6>
     582:	00 d0       	rcall	.+0      	; 0x584 <prvSetupTimerInterrupt+0x8>
     584:	00 d0       	rcall	.+0      	; 0x586 <prvSetupTimerInterrupt+0xa>
     586:	cd b7       	in	r28, 0x3d	; 61
     588:	de b7       	in	r29, 0x3e	; 62
uint8_t ucHighByte, ucLowByte;

	/* Using 16bit timer 1 to generate the tick.  Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock. */

	ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
     58a:	80 e4       	ldi	r24, 0x40	; 64
     58c:	9f e1       	ldi	r25, 0x1F	; 31
     58e:	a0 e0       	ldi	r26, 0x00	; 0
     590:	b0 e0       	ldi	r27, 0x00	; 0
     592:	8b 83       	std	Y+3, r24	; 0x03
     594:	9c 83       	std	Y+4, r25	; 0x04
     596:	ad 83       	std	Y+5, r26	; 0x05
     598:	be 83       	std	Y+6, r27	; 0x06

	/* We only have 16 bits so have to scale to get our required tick rate. */
	ulCompareMatch /= portCLOCK_PRESCALER;
     59a:	8b 81       	ldd	r24, Y+3	; 0x03
     59c:	9c 81       	ldd	r25, Y+4	; 0x04
     59e:	ad 81       	ldd	r26, Y+5	; 0x05
     5a0:	be 81       	ldd	r27, Y+6	; 0x06
     5a2:	68 94       	set
     5a4:	15 f8       	bld	r1, 5
     5a6:	b6 95       	lsr	r27
     5a8:	a7 95       	ror	r26
     5aa:	97 95       	ror	r25
     5ac:	87 95       	ror	r24
     5ae:	16 94       	lsr	r1
     5b0:	d1 f7       	brne	.-12     	; 0x5a6 <prvSetupTimerInterrupt+0x2a>
     5b2:	8b 83       	std	Y+3, r24	; 0x03
     5b4:	9c 83       	std	Y+4, r25	; 0x04
     5b6:	ad 83       	std	Y+5, r26	; 0x05
     5b8:	be 83       	std	Y+6, r27	; 0x06

	/* Adjust for correct value. */
	ulCompareMatch -= ( uint32_t ) 1;
     5ba:	8b 81       	ldd	r24, Y+3	; 0x03
     5bc:	9c 81       	ldd	r25, Y+4	; 0x04
     5be:	ad 81       	ldd	r26, Y+5	; 0x05
     5c0:	be 81       	ldd	r27, Y+6	; 0x06
     5c2:	01 97       	sbiw	r24, 0x01	; 1
     5c4:	a1 09       	sbc	r26, r1
     5c6:	b1 09       	sbc	r27, r1
     5c8:	8b 83       	std	Y+3, r24	; 0x03
     5ca:	9c 83       	std	Y+4, r25	; 0x04
     5cc:	ad 83       	std	Y+5, r26	; 0x05
     5ce:	be 83       	std	Y+6, r27	; 0x06

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
     5d0:	8b 81       	ldd	r24, Y+3	; 0x03
     5d2:	89 83       	std	Y+1, r24	; 0x01
	ulCompareMatch >>= 8;
     5d4:	8b 81       	ldd	r24, Y+3	; 0x03
     5d6:	9c 81       	ldd	r25, Y+4	; 0x04
     5d8:	ad 81       	ldd	r26, Y+5	; 0x05
     5da:	be 81       	ldd	r27, Y+6	; 0x06
     5dc:	89 2f       	mov	r24, r25
     5de:	9a 2f       	mov	r25, r26
     5e0:	ab 2f       	mov	r26, r27
     5e2:	bb 27       	eor	r27, r27
     5e4:	8b 83       	std	Y+3, r24	; 0x03
     5e6:	9c 83       	std	Y+4, r25	; 0x04
     5e8:	ad 83       	std	Y+5, r26	; 0x05
     5ea:	be 83       	std	Y+6, r27	; 0x06
	ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
     5ec:	8b 81       	ldd	r24, Y+3	; 0x03
     5ee:	8a 83       	std	Y+2, r24	; 0x02
	OCR1AH = ucHighByte;
     5f0:	eb e4       	ldi	r30, 0x4B	; 75
     5f2:	f0 e0       	ldi	r31, 0x00	; 0
     5f4:	8a 81       	ldd	r24, Y+2	; 0x02
     5f6:	80 83       	st	Z, r24
	OCR1AL = ucLowByte;
     5f8:	ea e4       	ldi	r30, 0x4A	; 74
     5fa:	f0 e0       	ldi	r31, 0x00	; 0
     5fc:	89 81       	ldd	r24, Y+1	; 0x01
     5fe:	80 83       	st	Z, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
     600:	8b e0       	ldi	r24, 0x0B	; 11
     602:	89 83       	std	Y+1, r24	; 0x01
	TCCR1B = ucLowByte;
     604:	ee e4       	ldi	r30, 0x4E	; 78
     606:	f0 e0       	ldi	r31, 0x00	; 0
     608:	89 81       	ldd	r24, Y+1	; 0x01
     60a:	80 83       	st	Z, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
     60c:	e9 e5       	ldi	r30, 0x59	; 89
     60e:	f0 e0       	ldi	r31, 0x00	; 0
     610:	80 81       	ld	r24, Z
     612:	89 83       	std	Y+1, r24	; 0x01
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
     614:	89 81       	ldd	r24, Y+1	; 0x01
     616:	80 61       	ori	r24, 0x10	; 16
     618:	89 83       	std	Y+1, r24	; 0x01
	TIMSK = ucLowByte;
     61a:	e9 e5       	ldi	r30, 0x59	; 89
     61c:	f0 e0       	ldi	r31, 0x00	; 0
     61e:	89 81       	ldd	r24, Y+1	; 0x01
     620:	80 83       	st	Z, r24
}
     622:	26 96       	adiw	r28, 0x06	; 6
     624:	0f b6       	in	r0, 0x3f	; 63
     626:	f8 94       	cli
     628:	de bf       	out	0x3e, r29	; 62
     62a:	0f be       	out	0x3f, r0	; 63
     62c:	cd bf       	out	0x3d, r28	; 61
     62e:	cf 91       	pop	r28
     630:	df 91       	pop	r29
     632:	08 95       	ret

00000634 <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
     634:	0e 94 61 02 	call	0x4c2	; 0x4c2 <vPortYieldFromTick>
		asm volatile ( "reti" );
     638:	18 95       	reti

0000063a <xEventGroupCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	EventGroupHandle_t xEventGroupCreate( void )
	{
     63a:	df 93       	push	r29
     63c:	cf 93       	push	r28
     63e:	00 d0       	rcall	.+0      	; 0x640 <xEventGroupCreate+0x6>
     640:	cd b7       	in	r28, 0x3d	; 61
     642:	de b7       	in	r29, 0x3e	; 62
		TickType_t alignment requirements the cast is safe.  In other cases,
		where the natural word size of the architecture is less than
		sizeof( TickType_t ), the TickType_t variables will be accessed in two
		or more reads operations, and the alignment requirements is only that
		of each individual read. */
		pxEventBits = ( EventGroup_t * ) pvPortMalloc( sizeof( EventGroup_t ) ); /*lint !e9087 !e9079 see comment above. */
     644:	8b e0       	ldi	r24, 0x0B	; 11
     646:	90 e0       	ldi	r25, 0x00	; 0
     648:	0e 94 62 06 	call	0xcc4	; 0xcc4 <pvPortMalloc>
     64c:	9a 83       	std	Y+2, r25	; 0x02
     64e:	89 83       	std	Y+1, r24	; 0x01

		if( pxEventBits != NULL )
     650:	89 81       	ldd	r24, Y+1	; 0x01
     652:	9a 81       	ldd	r25, Y+2	; 0x02
     654:	00 97       	sbiw	r24, 0x00	; 0
     656:	49 f0       	breq	.+18     	; 0x66a <xEventGroupCreate+0x30>
		{
			pxEventBits->uxEventBits = 0;
     658:	e9 81       	ldd	r30, Y+1	; 0x01
     65a:	fa 81       	ldd	r31, Y+2	; 0x02
     65c:	11 82       	std	Z+1, r1	; 0x01
     65e:	10 82       	st	Z, r1
			vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
     660:	89 81       	ldd	r24, Y+1	; 0x01
     662:	9a 81       	ldd	r25, Y+2	; 0x02
     664:	02 96       	adiw	r24, 0x02	; 2
     666:	0e 94 de 06 	call	0xdbc	; 0xdbc <vListInitialise>
		else
		{
			traceEVENT_GROUP_CREATE_FAILED(); /*lint !e9063 Else branch only exists to allow tracing and does not generate code if trace macros are not defined. */
		}

		return pxEventBits;
     66a:	89 81       	ldd	r24, Y+1	; 0x01
     66c:	9a 81       	ldd	r25, Y+2	; 0x02
	}
     66e:	0f 90       	pop	r0
     670:	0f 90       	pop	r0
     672:	cf 91       	pop	r28
     674:	df 91       	pop	r29
     676:	08 95       	ret

00000678 <xEventGroupSync>:

#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, const EventBits_t uxBitsToWaitFor, TickType_t xTicksToWait )
{
     678:	df 93       	push	r29
     67a:	cf 93       	push	r28
     67c:	cd b7       	in	r28, 0x3d	; 61
     67e:	de b7       	in	r29, 0x3e	; 62
     680:	60 97       	sbiw	r28, 0x10	; 16
     682:	0f b6       	in	r0, 0x3f	; 63
     684:	f8 94       	cli
     686:	de bf       	out	0x3e, r29	; 62
     688:	0f be       	out	0x3f, r0	; 63
     68a:	cd bf       	out	0x3d, r28	; 61
     68c:	9a 87       	std	Y+10, r25	; 0x0a
     68e:	89 87       	std	Y+9, r24	; 0x09
     690:	7c 87       	std	Y+12, r23	; 0x0c
     692:	6b 87       	std	Y+11, r22	; 0x0b
     694:	5e 87       	std	Y+14, r21	; 0x0e
     696:	4d 87       	std	Y+13, r20	; 0x0d
     698:	38 8b       	std	Y+16, r19	; 0x10
     69a:	2f 87       	std	Y+15, r18	; 0x0f
EventBits_t uxOriginalBitValue, uxReturn;
EventGroup_t *pxEventBits = xEventGroup;
     69c:	89 85       	ldd	r24, Y+9	; 0x09
     69e:	9a 85       	ldd	r25, Y+10	; 0x0a
     6a0:	9c 83       	std	Y+4, r25	; 0x04
     6a2:	8b 83       	std	Y+3, r24	; 0x03
BaseType_t xAlreadyYielded;
BaseType_t xTimeoutOccurred = pdFALSE;
     6a4:	19 82       	std	Y+1, r1	; 0x01
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
     6a6:	0e 94 b5 1a 	call	0x356a	; 0x356a <vTaskSuspendAll>
	{
		uxOriginalBitValue = pxEventBits->uxEventBits;
     6aa:	eb 81       	ldd	r30, Y+3	; 0x03
     6ac:	fc 81       	ldd	r31, Y+4	; 0x04
     6ae:	80 81       	ld	r24, Z
     6b0:	91 81       	ldd	r25, Z+1	; 0x01
     6b2:	98 87       	std	Y+8, r25	; 0x08
     6b4:	8f 83       	std	Y+7, r24	; 0x07

		( void ) xEventGroupSetBits( xEventGroup, uxBitsToSet );
     6b6:	89 85       	ldd	r24, Y+9	; 0x09
     6b8:	9a 85       	ldd	r25, Y+10	; 0x0a
     6ba:	2b 85       	ldd	r18, Y+11	; 0x0b
     6bc:	3c 85       	ldd	r19, Y+12	; 0x0c
     6be:	b9 01       	movw	r22, r18
     6c0:	0e 94 13 05 	call	0xa26	; 0xa26 <xEventGroupSetBits>

		if( ( ( uxOriginalBitValue | uxBitsToSet ) & uxBitsToWaitFor ) == uxBitsToWaitFor )
     6c4:	2f 81       	ldd	r18, Y+7	; 0x07
     6c6:	38 85       	ldd	r19, Y+8	; 0x08
     6c8:	8b 85       	ldd	r24, Y+11	; 0x0b
     6ca:	9c 85       	ldd	r25, Y+12	; 0x0c
     6cc:	28 2b       	or	r18, r24
     6ce:	39 2b       	or	r19, r25
     6d0:	8d 85       	ldd	r24, Y+13	; 0x0d
     6d2:	9e 85       	ldd	r25, Y+14	; 0x0e
     6d4:	28 23       	and	r18, r24
     6d6:	39 23       	and	r19, r25
     6d8:	8d 85       	ldd	r24, Y+13	; 0x0d
     6da:	9e 85       	ldd	r25, Y+14	; 0x0e
     6dc:	28 17       	cp	r18, r24
     6de:	39 07       	cpc	r19, r25
     6e0:	c9 f4       	brne	.+50     	; 0x714 <xEventGroupSync+0x9c>
		{
			/* All the rendezvous bits are now set - no need to block. */
			uxReturn = ( uxOriginalBitValue | uxBitsToSet );
     6e2:	2f 81       	ldd	r18, Y+7	; 0x07
     6e4:	38 85       	ldd	r19, Y+8	; 0x08
     6e6:	8b 85       	ldd	r24, Y+11	; 0x0b
     6e8:	9c 85       	ldd	r25, Y+12	; 0x0c
     6ea:	82 2b       	or	r24, r18
     6ec:	93 2b       	or	r25, r19
     6ee:	9e 83       	std	Y+6, r25	; 0x06
     6f0:	8d 83       	std	Y+5, r24	; 0x05

			/* Rendezvous always clear the bits.  They will have been cleared
			already unless this is the only task in the rendezvous. */
			pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     6f2:	eb 81       	ldd	r30, Y+3	; 0x03
     6f4:	fc 81       	ldd	r31, Y+4	; 0x04
     6f6:	20 81       	ld	r18, Z
     6f8:	31 81       	ldd	r19, Z+1	; 0x01
     6fa:	8d 85       	ldd	r24, Y+13	; 0x0d
     6fc:	9e 85       	ldd	r25, Y+14	; 0x0e
     6fe:	80 95       	com	r24
     700:	90 95       	com	r25
     702:	82 23       	and	r24, r18
     704:	93 23       	and	r25, r19
     706:	eb 81       	ldd	r30, Y+3	; 0x03
     708:	fc 81       	ldd	r31, Y+4	; 0x04
     70a:	91 83       	std	Z+1, r25	; 0x01
     70c:	80 83       	st	Z, r24

			xTicksToWait = 0;
     70e:	18 8a       	std	Y+16, r1	; 0x10
     710:	1f 86       	std	Y+15, r1	; 0x0f
     712:	1e c0       	rjmp	.+60     	; 0x750 <xEventGroupSync+0xd8>
		}
		else
		{
			if( xTicksToWait != ( TickType_t ) 0 )
     714:	8f 85       	ldd	r24, Y+15	; 0x0f
     716:	98 89       	ldd	r25, Y+16	; 0x10
     718:	00 97       	sbiw	r24, 0x00	; 0
     71a:	91 f0       	breq	.+36     	; 0x740 <xEventGroupSync+0xc8>
				traceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWaitFor );

				/* Store the bits that the calling task is waiting for in the
				task's event list item so the kernel knows when a match is
				found.  Then enter the blocked state. */
				vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | eventCLEAR_EVENTS_ON_EXIT_BIT | eventWAIT_FOR_ALL_BITS ), xTicksToWait );
     71c:	8b 81       	ldd	r24, Y+3	; 0x03
     71e:	9c 81       	ldd	r25, Y+4	; 0x04
     720:	bc 01       	movw	r22, r24
     722:	6e 5f       	subi	r22, 0xFE	; 254
     724:	7f 4f       	sbci	r23, 0xFF	; 255
     726:	8d 85       	ldd	r24, Y+13	; 0x0d
     728:	9e 85       	ldd	r25, Y+14	; 0x0e
     72a:	9c 01       	movw	r18, r24
     72c:	35 60       	ori	r19, 0x05	; 5
     72e:	4f 85       	ldd	r20, Y+15	; 0x0f
     730:	58 89       	ldd	r21, Y+16	; 0x10
     732:	cb 01       	movw	r24, r22
     734:	b9 01       	movw	r22, r18
     736:	0e 94 25 1d 	call	0x3a4a	; 0x3a4a <vTaskPlaceOnUnorderedEventList>

				/* This assignment is obsolete as uxReturn will get set after
				the task unblocks, but some compilers mistakenly generate a
				warning about uxReturn being returned without being set if the
				assignment is omitted. */
				uxReturn = 0;
     73a:	1e 82       	std	Y+6, r1	; 0x06
     73c:	1d 82       	std	Y+5, r1	; 0x05
     73e:	08 c0       	rjmp	.+16     	; 0x750 <xEventGroupSync+0xd8>
			}
			else
			{
				/* The rendezvous bits were not set, but no block time was
				specified - just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
     740:	eb 81       	ldd	r30, Y+3	; 0x03
     742:	fc 81       	ldd	r31, Y+4	; 0x04
     744:	80 81       	ld	r24, Z
     746:	91 81       	ldd	r25, Z+1	; 0x01
     748:	9e 83       	std	Y+6, r25	; 0x06
     74a:	8d 83       	std	Y+5, r24	; 0x05
				xTimeoutOccurred = pdTRUE;
     74c:	81 e0       	ldi	r24, 0x01	; 1
     74e:	89 83       	std	Y+1, r24	; 0x01
			}
		}
	}
	xAlreadyYielded = xTaskResumeAll();
     750:	0e 94 c1 1a 	call	0x3582	; 0x3582 <xTaskResumeAll>
     754:	8a 83       	std	Y+2, r24	; 0x02

	if( xTicksToWait != ( TickType_t ) 0 )
     756:	8f 85       	ldd	r24, Y+15	; 0x0f
     758:	98 89       	ldd	r25, Y+16	; 0x10
     75a:	00 97       	sbiw	r24, 0x00	; 0
     75c:	09 f4       	brne	.+2      	; 0x760 <xEventGroupSync+0xe8>
     75e:	3a c0       	rjmp	.+116    	; 0x7d4 <xEventGroupSync+0x15c>
	{
		if( xAlreadyYielded == pdFALSE )
     760:	8a 81       	ldd	r24, Y+2	; 0x02
     762:	88 23       	and	r24, r24
     764:	11 f4       	brne	.+4      	; 0x76a <xEventGroupSync+0xf2>
		{
			portYIELD_WITHIN_API();
     766:	0e 94 08 02 	call	0x410	; 0x410 <vPortYield>

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
     76a:	0e 94 98 1f 	call	0x3f30	; 0x3f30 <uxTaskResetEventItemValue>
     76e:	9e 83       	std	Y+6, r25	; 0x06
     770:	8d 83       	std	Y+5, r24	; 0x05

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
     772:	8d 81       	ldd	r24, Y+5	; 0x05
     774:	9e 81       	ldd	r25, Y+6	; 0x06
     776:	80 70       	andi	r24, 0x00	; 0
     778:	92 70       	andi	r25, 0x02	; 2
     77a:	00 97       	sbiw	r24, 0x00	; 0
     77c:	31 f5       	brne	.+76     	; 0x7ca <xEventGroupSync+0x152>
		{
			/* The task timed out, just return the current event bit value. */
			taskENTER_CRITICAL();
     77e:	0f b6       	in	r0, 0x3f	; 63
     780:	f8 94       	cli
     782:	0f 92       	push	r0
			{
				uxReturn = pxEventBits->uxEventBits;
     784:	eb 81       	ldd	r30, Y+3	; 0x03
     786:	fc 81       	ldd	r31, Y+4	; 0x04
     788:	80 81       	ld	r24, Z
     78a:	91 81       	ldd	r25, Z+1	; 0x01
     78c:	9e 83       	std	Y+6, r25	; 0x06
     78e:	8d 83       	std	Y+5, r24	; 0x05

				/* Although the task got here because it timed out before the
				bits it was waiting for were set, it is possible that since it
				unblocked another task has set the bits.  If this is the case
				then it needs to clear the bits before exiting. */
				if( ( uxReturn & uxBitsToWaitFor ) == uxBitsToWaitFor )
     790:	2d 81       	ldd	r18, Y+5	; 0x05
     792:	3e 81       	ldd	r19, Y+6	; 0x06
     794:	8d 85       	ldd	r24, Y+13	; 0x0d
     796:	9e 85       	ldd	r25, Y+14	; 0x0e
     798:	28 23       	and	r18, r24
     79a:	39 23       	and	r19, r25
     79c:	8d 85       	ldd	r24, Y+13	; 0x0d
     79e:	9e 85       	ldd	r25, Y+14	; 0x0e
     7a0:	28 17       	cp	r18, r24
     7a2:	39 07       	cpc	r19, r25
     7a4:	71 f4       	brne	.+28     	; 0x7c2 <xEventGroupSync+0x14a>
				{
					pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     7a6:	eb 81       	ldd	r30, Y+3	; 0x03
     7a8:	fc 81       	ldd	r31, Y+4	; 0x04
     7aa:	20 81       	ld	r18, Z
     7ac:	31 81       	ldd	r19, Z+1	; 0x01
     7ae:	8d 85       	ldd	r24, Y+13	; 0x0d
     7b0:	9e 85       	ldd	r25, Y+14	; 0x0e
     7b2:	80 95       	com	r24
     7b4:	90 95       	com	r25
     7b6:	82 23       	and	r24, r18
     7b8:	93 23       	and	r25, r19
     7ba:	eb 81       	ldd	r30, Y+3	; 0x03
     7bc:	fc 81       	ldd	r31, Y+4	; 0x04
     7be:	91 83       	std	Z+1, r25	; 0x01
     7c0:	80 83       	st	Z, r24
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
     7c2:	0f 90       	pop	r0
     7c4:	0f be       	out	0x3f, r0	; 63

			xTimeoutOccurred = pdTRUE;
     7c6:	81 e0       	ldi	r24, 0x01	; 1
     7c8:	89 83       	std	Y+1, r24	; 0x01
			/* The task unblocked because the bits were set. */
		}

		/* Control bits might be set as the task had blocked should not be
		returned. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
     7ca:	8d 81       	ldd	r24, Y+5	; 0x05
     7cc:	9e 81       	ldd	r25, Y+6	; 0x06
     7ce:	90 70       	andi	r25, 0x00	; 0
     7d0:	9e 83       	std	Y+6, r25	; 0x06
     7d2:	8d 83       	std	Y+5, r24	; 0x05
	traceEVENT_GROUP_SYNC_END( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTimeoutOccurred );

	/* Prevent compiler warnings when trace macros are not used. */
	( void ) xTimeoutOccurred;

	return uxReturn;
     7d4:	8d 81       	ldd	r24, Y+5	; 0x05
     7d6:	9e 81       	ldd	r25, Y+6	; 0x06
}
     7d8:	60 96       	adiw	r28, 0x10	; 16
     7da:	0f b6       	in	r0, 0x3f	; 63
     7dc:	f8 94       	cli
     7de:	de bf       	out	0x3e, r29	; 62
     7e0:	0f be       	out	0x3f, r0	; 63
     7e2:	cd bf       	out	0x3d, r28	; 61
     7e4:	cf 91       	pop	r28
     7e6:	df 91       	pop	r29
     7e8:	08 95       	ret

000007ea <xEventGroupWaitBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait )
{
     7ea:	0f 93       	push	r16
     7ec:	1f 93       	push	r17
     7ee:	df 93       	push	r29
     7f0:	cf 93       	push	r28
     7f2:	cd b7       	in	r28, 0x3d	; 61
     7f4:	de b7       	in	r29, 0x3e	; 62
     7f6:	63 97       	sbiw	r28, 0x13	; 19
     7f8:	0f b6       	in	r0, 0x3f	; 63
     7fa:	f8 94       	cli
     7fc:	de bf       	out	0x3e, r29	; 62
     7fe:	0f be       	out	0x3f, r0	; 63
     800:	cd bf       	out	0x3d, r28	; 61
     802:	9d 87       	std	Y+13, r25	; 0x0d
     804:	8c 87       	std	Y+12, r24	; 0x0c
     806:	7f 87       	std	Y+15, r23	; 0x0f
     808:	6e 87       	std	Y+14, r22	; 0x0e
     80a:	48 8b       	std	Y+16, r20	; 0x10
     80c:	29 8b       	std	Y+17, r18	; 0x11
     80e:	1b 8b       	std	Y+19, r17	; 0x13
     810:	0a 8b       	std	Y+18, r16	; 0x12
EventGroup_t *pxEventBits = xEventGroup;
     812:	8c 85       	ldd	r24, Y+12	; 0x0c
     814:	9d 85       	ldd	r25, Y+13	; 0x0d
     816:	9b 87       	std	Y+11, r25	; 0x0b
     818:	8a 87       	std	Y+10, r24	; 0x0a
EventBits_t uxReturn, uxControlBits = 0;
     81a:	1f 82       	std	Y+7, r1	; 0x07
     81c:	1e 82       	std	Y+6, r1	; 0x06
BaseType_t xWaitConditionMet, xAlreadyYielded;
BaseType_t xTimeoutOccurred = pdFALSE;
     81e:	1b 82       	std	Y+3, r1	; 0x03
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
     820:	0e 94 b5 1a 	call	0x356a	; 0x356a <vTaskSuspendAll>
	{
		const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
     824:	ea 85       	ldd	r30, Y+10	; 0x0a
     826:	fb 85       	ldd	r31, Y+11	; 0x0b
     828:	80 81       	ld	r24, Z
     82a:	91 81       	ldd	r25, Z+1	; 0x01
     82c:	9a 83       	std	Y+2, r25	; 0x02
     82e:	89 83       	std	Y+1, r24	; 0x01

		/* Check to see if the wait condition is already met or not. */
		xWaitConditionMet = prvTestWaitCondition( uxCurrentEventBits, uxBitsToWaitFor, xWaitForAllBits );
     830:	89 81       	ldd	r24, Y+1	; 0x01
     832:	9a 81       	ldd	r25, Y+2	; 0x02
     834:	2e 85       	ldd	r18, Y+14	; 0x0e
     836:	3f 85       	ldd	r19, Y+15	; 0x0f
     838:	b9 01       	movw	r22, r18
     83a:	49 89       	ldd	r20, Y+17	; 0x11
     83c:	0e 94 30 06 	call	0xc60	; 0xc60 <prvTestWaitCondition>
     840:	8d 83       	std	Y+5, r24	; 0x05

		if( xWaitConditionMet != pdFALSE )
     842:	8d 81       	ldd	r24, Y+5	; 0x05
     844:	88 23       	and	r24, r24
     846:	c1 f0       	breq	.+48     	; 0x878 <__stack+0x19>
		{
			/* The wait condition has already been met so there is no need to
			block. */
			uxReturn = uxCurrentEventBits;
     848:	89 81       	ldd	r24, Y+1	; 0x01
     84a:	9a 81       	ldd	r25, Y+2	; 0x02
     84c:	99 87       	std	Y+9, r25	; 0x09
     84e:	88 87       	std	Y+8, r24	; 0x08
			xTicksToWait = ( TickType_t ) 0;
     850:	1b 8a       	std	Y+19, r1	; 0x13
     852:	1a 8a       	std	Y+18, r1	; 0x12

			/* Clear the wait bits if requested to do so. */
			if( xClearOnExit != pdFALSE )
     854:	88 89       	ldd	r24, Y+16	; 0x10
     856:	88 23       	and	r24, r24
     858:	e9 f1       	breq	.+122    	; 0x8d4 <__stack+0x75>
			{
				pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     85a:	ea 85       	ldd	r30, Y+10	; 0x0a
     85c:	fb 85       	ldd	r31, Y+11	; 0x0b
     85e:	20 81       	ld	r18, Z
     860:	31 81       	ldd	r19, Z+1	; 0x01
     862:	8e 85       	ldd	r24, Y+14	; 0x0e
     864:	9f 85       	ldd	r25, Y+15	; 0x0f
     866:	80 95       	com	r24
     868:	90 95       	com	r25
     86a:	82 23       	and	r24, r18
     86c:	93 23       	and	r25, r19
     86e:	ea 85       	ldd	r30, Y+10	; 0x0a
     870:	fb 85       	ldd	r31, Y+11	; 0x0b
     872:	91 83       	std	Z+1, r25	; 0x01
     874:	80 83       	st	Z, r24
     876:	2e c0       	rjmp	.+92     	; 0x8d4 <__stack+0x75>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		else if( xTicksToWait == ( TickType_t ) 0 )
     878:	8a 89       	ldd	r24, Y+18	; 0x12
     87a:	9b 89       	ldd	r25, Y+19	; 0x13
     87c:	00 97       	sbiw	r24, 0x00	; 0
     87e:	39 f4       	brne	.+14     	; 0x88e <__stack+0x2f>
		{
			/* The wait condition has not been met, but no block time was
			specified, so just return the current value. */
			uxReturn = uxCurrentEventBits;
     880:	89 81       	ldd	r24, Y+1	; 0x01
     882:	9a 81       	ldd	r25, Y+2	; 0x02
     884:	99 87       	std	Y+9, r25	; 0x09
     886:	88 87       	std	Y+8, r24	; 0x08
			xTimeoutOccurred = pdTRUE;
     888:	81 e0       	ldi	r24, 0x01	; 1
     88a:	8b 83       	std	Y+3, r24	; 0x03
     88c:	23 c0       	rjmp	.+70     	; 0x8d4 <__stack+0x75>
		{
			/* The task is going to block to wait for its required bits to be
			set.  uxControlBits are used to remember the specified behaviour of
			this call to xEventGroupWaitBits() - for use when the event bits
			unblock the task. */
			if( xClearOnExit != pdFALSE )
     88e:	88 89       	ldd	r24, Y+16	; 0x10
     890:	88 23       	and	r24, r24
     892:	29 f0       	breq	.+10     	; 0x89e <__stack+0x3f>
			{
				uxControlBits |= eventCLEAR_EVENTS_ON_EXIT_BIT;
     894:	8e 81       	ldd	r24, Y+6	; 0x06
     896:	9f 81       	ldd	r25, Y+7	; 0x07
     898:	91 60       	ori	r25, 0x01	; 1
     89a:	9f 83       	std	Y+7, r25	; 0x07
     89c:	8e 83       	std	Y+6, r24	; 0x06
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			if( xWaitForAllBits != pdFALSE )
     89e:	89 89       	ldd	r24, Y+17	; 0x11
     8a0:	88 23       	and	r24, r24
     8a2:	29 f0       	breq	.+10     	; 0x8ae <__stack+0x4f>
			{
				uxControlBits |= eventWAIT_FOR_ALL_BITS;
     8a4:	8e 81       	ldd	r24, Y+6	; 0x06
     8a6:	9f 81       	ldd	r25, Y+7	; 0x07
     8a8:	94 60       	ori	r25, 0x04	; 4
     8aa:	9f 83       	std	Y+7, r25	; 0x07
     8ac:	8e 83       	std	Y+6, r24	; 0x06
			}

			/* Store the bits that the calling task is waiting for in the
			task's event list item so the kernel knows when a match is
			found.  Then enter the blocked state. */
			vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
     8ae:	8a 85       	ldd	r24, Y+10	; 0x0a
     8b0:	9b 85       	ldd	r25, Y+11	; 0x0b
     8b2:	bc 01       	movw	r22, r24
     8b4:	6e 5f       	subi	r22, 0xFE	; 254
     8b6:	7f 4f       	sbci	r23, 0xFF	; 255
     8b8:	2e 85       	ldd	r18, Y+14	; 0x0e
     8ba:	3f 85       	ldd	r19, Y+15	; 0x0f
     8bc:	8e 81       	ldd	r24, Y+6	; 0x06
     8be:	9f 81       	ldd	r25, Y+7	; 0x07
     8c0:	28 2b       	or	r18, r24
     8c2:	39 2b       	or	r19, r25
     8c4:	4a 89       	ldd	r20, Y+18	; 0x12
     8c6:	5b 89       	ldd	r21, Y+19	; 0x13
     8c8:	cb 01       	movw	r24, r22
     8ca:	b9 01       	movw	r22, r18
     8cc:	0e 94 25 1d 	call	0x3a4a	; 0x3a4a <vTaskPlaceOnUnorderedEventList>

			/* This is obsolete as it will get set after the task unblocks, but
			some compilers mistakenly generate a warning about the variable
			being returned without being set if it is not done. */
			uxReturn = 0;
     8d0:	19 86       	std	Y+9, r1	; 0x09
     8d2:	18 86       	std	Y+8, r1	; 0x08

			traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
		}
	}
	xAlreadyYielded = xTaskResumeAll();
     8d4:	0e 94 c1 1a 	call	0x3582	; 0x3582 <xTaskResumeAll>
     8d8:	8c 83       	std	Y+4, r24	; 0x04

	if( xTicksToWait != ( TickType_t ) 0 )
     8da:	8a 89       	ldd	r24, Y+18	; 0x12
     8dc:	9b 89       	ldd	r25, Y+19	; 0x13
     8de:	00 97       	sbiw	r24, 0x00	; 0
     8e0:	09 f4       	brne	.+2      	; 0x8e4 <__stack+0x85>
     8e2:	3c c0       	rjmp	.+120    	; 0x95c <__stack+0xfd>
	{
		if( xAlreadyYielded == pdFALSE )
     8e4:	8c 81       	ldd	r24, Y+4	; 0x04
     8e6:	88 23       	and	r24, r24
     8e8:	11 f4       	brne	.+4      	; 0x8ee <__stack+0x8f>
		{
			portYIELD_WITHIN_API();
     8ea:	0e 94 08 02 	call	0x410	; 0x410 <vPortYield>

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
     8ee:	0e 94 98 1f 	call	0x3f30	; 0x3f30 <uxTaskResetEventItemValue>
     8f2:	99 87       	std	Y+9, r25	; 0x09
     8f4:	88 87       	std	Y+8, r24	; 0x08

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
     8f6:	88 85       	ldd	r24, Y+8	; 0x08
     8f8:	99 85       	ldd	r25, Y+9	; 0x09
     8fa:	80 70       	andi	r24, 0x00	; 0
     8fc:	92 70       	andi	r25, 0x02	; 2
     8fe:	00 97       	sbiw	r24, 0x00	; 0
     900:	41 f5       	brne	.+80     	; 0x952 <__stack+0xf3>
		{
			taskENTER_CRITICAL();
     902:	0f b6       	in	r0, 0x3f	; 63
     904:	f8 94       	cli
     906:	0f 92       	push	r0
			{
				/* The task timed out, just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
     908:	ea 85       	ldd	r30, Y+10	; 0x0a
     90a:	fb 85       	ldd	r31, Y+11	; 0x0b
     90c:	80 81       	ld	r24, Z
     90e:	91 81       	ldd	r25, Z+1	; 0x01
     910:	99 87       	std	Y+9, r25	; 0x09
     912:	88 87       	std	Y+8, r24	; 0x08

				/* It is possible that the event bits were updated between this
				task leaving the Blocked state and running again. */
				if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
     914:	88 85       	ldd	r24, Y+8	; 0x08
     916:	99 85       	ldd	r25, Y+9	; 0x09
     918:	2e 85       	ldd	r18, Y+14	; 0x0e
     91a:	3f 85       	ldd	r19, Y+15	; 0x0f
     91c:	b9 01       	movw	r22, r18
     91e:	49 89       	ldd	r20, Y+17	; 0x11
     920:	0e 94 30 06 	call	0xc60	; 0xc60 <prvTestWaitCondition>
     924:	88 23       	and	r24, r24
     926:	89 f0       	breq	.+34     	; 0x94a <__stack+0xeb>
				{
					if( xClearOnExit != pdFALSE )
     928:	88 89       	ldd	r24, Y+16	; 0x10
     92a:	88 23       	and	r24, r24
     92c:	71 f0       	breq	.+28     	; 0x94a <__stack+0xeb>
					{
						pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     92e:	ea 85       	ldd	r30, Y+10	; 0x0a
     930:	fb 85       	ldd	r31, Y+11	; 0x0b
     932:	20 81       	ld	r18, Z
     934:	31 81       	ldd	r19, Z+1	; 0x01
     936:	8e 85       	ldd	r24, Y+14	; 0x0e
     938:	9f 85       	ldd	r25, Y+15	; 0x0f
     93a:	80 95       	com	r24
     93c:	90 95       	com	r25
     93e:	82 23       	and	r24, r18
     940:	93 23       	and	r25, r19
     942:	ea 85       	ldd	r30, Y+10	; 0x0a
     944:	fb 85       	ldd	r31, Y+11	; 0x0b
     946:	91 83       	std	Z+1, r25	; 0x01
     948:	80 83       	st	Z, r24
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				xTimeoutOccurred = pdTRUE;
     94a:	81 e0       	ldi	r24, 0x01	; 1
     94c:	8b 83       	std	Y+3, r24	; 0x03
			}
			taskEXIT_CRITICAL();
     94e:	0f 90       	pop	r0
     950:	0f be       	out	0x3f, r0	; 63
		{
			/* The task unblocked because the bits were set. */
		}

		/* The task blocked so control bits may have been set. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
     952:	88 85       	ldd	r24, Y+8	; 0x08
     954:	99 85       	ldd	r25, Y+9	; 0x09
     956:	90 70       	andi	r25, 0x00	; 0
     958:	99 87       	std	Y+9, r25	; 0x09
     95a:	88 87       	std	Y+8, r24	; 0x08
	traceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxBitsToWaitFor, xTimeoutOccurred );

	/* Prevent compiler warnings when trace macros are not used. */
	( void ) xTimeoutOccurred;

	return uxReturn;
     95c:	88 85       	ldd	r24, Y+8	; 0x08
     95e:	99 85       	ldd	r25, Y+9	; 0x09
}
     960:	63 96       	adiw	r28, 0x13	; 19
     962:	0f b6       	in	r0, 0x3f	; 63
     964:	f8 94       	cli
     966:	de bf       	out	0x3e, r29	; 62
     968:	0f be       	out	0x3f, r0	; 63
     96a:	cd bf       	out	0x3d, r28	; 61
     96c:	cf 91       	pop	r28
     96e:	df 91       	pop	r29
     970:	1f 91       	pop	r17
     972:	0f 91       	pop	r16
     974:	08 95       	ret

00000976 <xEventGroupClearBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear )
{
     976:	df 93       	push	r29
     978:	cf 93       	push	r28
     97a:	cd b7       	in	r28, 0x3d	; 61
     97c:	de b7       	in	r29, 0x3e	; 62
     97e:	28 97       	sbiw	r28, 0x08	; 8
     980:	0f b6       	in	r0, 0x3f	; 63
     982:	f8 94       	cli
     984:	de bf       	out	0x3e, r29	; 62
     986:	0f be       	out	0x3f, r0	; 63
     988:	cd bf       	out	0x3d, r28	; 61
     98a:	9e 83       	std	Y+6, r25	; 0x06
     98c:	8d 83       	std	Y+5, r24	; 0x05
     98e:	78 87       	std	Y+8, r23	; 0x08
     990:	6f 83       	std	Y+7, r22	; 0x07
EventGroup_t *pxEventBits = xEventGroup;
     992:	8d 81       	ldd	r24, Y+5	; 0x05
     994:	9e 81       	ldd	r25, Y+6	; 0x06
     996:	9c 83       	std	Y+4, r25	; 0x04
     998:	8b 83       	std	Y+3, r24	; 0x03
	/* Check the user is not attempting to clear the bits used by the kernel
	itself. */
	configASSERT( xEventGroup );
	configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	taskENTER_CRITICAL();
     99a:	0f b6       	in	r0, 0x3f	; 63
     99c:	f8 94       	cli
     99e:	0f 92       	push	r0
	{
		traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear );

		/* The value returned is the event group value prior to the bits being
		cleared. */
		uxReturn = pxEventBits->uxEventBits;
     9a0:	eb 81       	ldd	r30, Y+3	; 0x03
     9a2:	fc 81       	ldd	r31, Y+4	; 0x04
     9a4:	80 81       	ld	r24, Z
     9a6:	91 81       	ldd	r25, Z+1	; 0x01
     9a8:	9a 83       	std	Y+2, r25	; 0x02
     9aa:	89 83       	std	Y+1, r24	; 0x01

		/* Clear the bits. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
     9ac:	eb 81       	ldd	r30, Y+3	; 0x03
     9ae:	fc 81       	ldd	r31, Y+4	; 0x04
     9b0:	20 81       	ld	r18, Z
     9b2:	31 81       	ldd	r19, Z+1	; 0x01
     9b4:	8f 81       	ldd	r24, Y+7	; 0x07
     9b6:	98 85       	ldd	r25, Y+8	; 0x08
     9b8:	80 95       	com	r24
     9ba:	90 95       	com	r25
     9bc:	82 23       	and	r24, r18
     9be:	93 23       	and	r25, r19
     9c0:	eb 81       	ldd	r30, Y+3	; 0x03
     9c2:	fc 81       	ldd	r31, Y+4	; 0x04
     9c4:	91 83       	std	Z+1, r25	; 0x01
     9c6:	80 83       	st	Z, r24
	}
	taskEXIT_CRITICAL();
     9c8:	0f 90       	pop	r0
     9ca:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
     9cc:	89 81       	ldd	r24, Y+1	; 0x01
     9ce:	9a 81       	ldd	r25, Y+2	; 0x02
}
     9d0:	28 96       	adiw	r28, 0x08	; 8
     9d2:	0f b6       	in	r0, 0x3f	; 63
     9d4:	f8 94       	cli
     9d6:	de bf       	out	0x3e, r29	; 62
     9d8:	0f be       	out	0x3f, r0	; 63
     9da:	cd bf       	out	0x3d, r28	; 61
     9dc:	cf 91       	pop	r28
     9de:	df 91       	pop	r29
     9e0:	08 95       	ret

000009e2 <xEventGroupGetBitsFromISR>:

#endif
/*-----------------------------------------------------------*/

EventBits_t xEventGroupGetBitsFromISR( EventGroupHandle_t xEventGroup )
{
     9e2:	df 93       	push	r29
     9e4:	cf 93       	push	r28
     9e6:	cd b7       	in	r28, 0x3d	; 61
     9e8:	de b7       	in	r29, 0x3e	; 62
     9ea:	27 97       	sbiw	r28, 0x07	; 7
     9ec:	0f b6       	in	r0, 0x3f	; 63
     9ee:	f8 94       	cli
     9f0:	de bf       	out	0x3e, r29	; 62
     9f2:	0f be       	out	0x3f, r0	; 63
     9f4:	cd bf       	out	0x3d, r28	; 61
     9f6:	9f 83       	std	Y+7, r25	; 0x07
     9f8:	8e 83       	std	Y+6, r24	; 0x06
UBaseType_t uxSavedInterruptStatus;
EventGroup_t const * const pxEventBits = xEventGroup;
     9fa:	8e 81       	ldd	r24, Y+6	; 0x06
     9fc:	9f 81       	ldd	r25, Y+7	; 0x07
     9fe:	9c 83       	std	Y+4, r25	; 0x04
     a00:	8b 83       	std	Y+3, r24	; 0x03
EventBits_t uxReturn;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
     a02:	1d 82       	std	Y+5, r1	; 0x05
	{
		uxReturn = pxEventBits->uxEventBits;
     a04:	eb 81       	ldd	r30, Y+3	; 0x03
     a06:	fc 81       	ldd	r31, Y+4	; 0x04
     a08:	80 81       	ld	r24, Z
     a0a:	91 81       	ldd	r25, Z+1	; 0x01
     a0c:	9a 83       	std	Y+2, r25	; 0x02
     a0e:	89 83       	std	Y+1, r24	; 0x01
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return uxReturn;
     a10:	89 81       	ldd	r24, Y+1	; 0x01
     a12:	9a 81       	ldd	r25, Y+2	; 0x02
} /*lint !e818 EventGroupHandle_t is a typedef used in other functions to so can't be pointer to const. */
     a14:	27 96       	adiw	r28, 0x07	; 7
     a16:	0f b6       	in	r0, 0x3f	; 63
     a18:	f8 94       	cli
     a1a:	de bf       	out	0x3e, r29	; 62
     a1c:	0f be       	out	0x3f, r0	; 63
     a1e:	cd bf       	out	0x3d, r28	; 61
     a20:	cf 91       	pop	r28
     a22:	df 91       	pop	r29
     a24:	08 95       	ret

00000a26 <xEventGroupSetBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
{
     a26:	df 93       	push	r29
     a28:	cf 93       	push	r28
     a2a:	cd b7       	in	r28, 0x3d	; 61
     a2c:	de b7       	in	r29, 0x3e	; 62
     a2e:	65 97       	sbiw	r28, 0x15	; 21
     a30:	0f b6       	in	r0, 0x3f	; 63
     a32:	f8 94       	cli
     a34:	de bf       	out	0x3e, r29	; 62
     a36:	0f be       	out	0x3f, r0	; 63
     a38:	cd bf       	out	0x3d, r28	; 61
     a3a:	9b 8b       	std	Y+19, r25	; 0x13
     a3c:	8a 8b       	std	Y+18, r24	; 0x12
     a3e:	7d 8b       	std	Y+21, r23	; 0x15
     a40:	6c 8b       	std	Y+20, r22	; 0x14
ListItem_t *pxListItem, *pxNext;
ListItem_t const *pxListEnd;
List_t const * pxList;
EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
     a42:	19 86       	std	Y+9, r1	; 0x09
     a44:	18 86       	std	Y+8, r1	; 0x08
EventGroup_t *pxEventBits = xEventGroup;
     a46:	8a 89       	ldd	r24, Y+18	; 0x12
     a48:	9b 89       	ldd	r25, Y+19	; 0x13
     a4a:	9b 83       	std	Y+3, r25	; 0x03
     a4c:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xMatchFound = pdFALSE;
     a4e:	19 82       	std	Y+1, r1	; 0x01
	/* Check the user is not attempting to set the bits used by the kernel
	itself. */
	configASSERT( xEventGroup );
	configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	pxList = &( pxEventBits->xTasksWaitingForBits );
     a50:	8a 81       	ldd	r24, Y+2	; 0x02
     a52:	9b 81       	ldd	r25, Y+3	; 0x03
     a54:	02 96       	adiw	r24, 0x02	; 2
     a56:	9b 87       	std	Y+11, r25	; 0x0b
     a58:	8a 87       	std	Y+10, r24	; 0x0a
	pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     a5a:	8a 85       	ldd	r24, Y+10	; 0x0a
     a5c:	9b 85       	ldd	r25, Y+11	; 0x0b
     a5e:	03 96       	adiw	r24, 0x03	; 3
     a60:	9d 87       	std	Y+13, r25	; 0x0d
     a62:	8c 87       	std	Y+12, r24	; 0x0c
	vTaskSuspendAll();
     a64:	0e 94 b5 1a 	call	0x356a	; 0x356a <vTaskSuspendAll>
	{
		traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );

		pxListItem = listGET_HEAD_ENTRY( pxList );
     a68:	ea 85       	ldd	r30, Y+10	; 0x0a
     a6a:	fb 85       	ldd	r31, Y+11	; 0x0b
     a6c:	85 81       	ldd	r24, Z+5	; 0x05
     a6e:	96 81       	ldd	r25, Z+6	; 0x06
     a70:	99 8b       	std	Y+17, r25	; 0x11
     a72:	88 8b       	std	Y+16, r24	; 0x10

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;
     a74:	ea 81       	ldd	r30, Y+2	; 0x02
     a76:	fb 81       	ldd	r31, Y+3	; 0x03
     a78:	20 81       	ld	r18, Z
     a7a:	31 81       	ldd	r19, Z+1	; 0x01
     a7c:	8c 89       	ldd	r24, Y+20	; 0x14
     a7e:	9d 89       	ldd	r25, Y+21	; 0x15
     a80:	82 2b       	or	r24, r18
     a82:	93 2b       	or	r25, r19
     a84:	ea 81       	ldd	r30, Y+2	; 0x02
     a86:	fb 81       	ldd	r31, Y+3	; 0x03
     a88:	91 83       	std	Z+1, r25	; 0x01
     a8a:	80 83       	st	Z, r24
     a8c:	59 c0       	rjmp	.+178    	; 0xb40 <xEventGroupSetBits+0x11a>

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
		{
			pxNext = listGET_NEXT( pxListItem );
     a8e:	e8 89       	ldd	r30, Y+16	; 0x10
     a90:	f9 89       	ldd	r31, Y+17	; 0x11
     a92:	82 81       	ldd	r24, Z+2	; 0x02
     a94:	93 81       	ldd	r25, Z+3	; 0x03
     a96:	9f 87       	std	Y+15, r25	; 0x0f
     a98:	8e 87       	std	Y+14, r24	; 0x0e
			uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
     a9a:	e8 89       	ldd	r30, Y+16	; 0x10
     a9c:	f9 89       	ldd	r31, Y+17	; 0x11
     a9e:	80 81       	ld	r24, Z
     aa0:	91 81       	ldd	r25, Z+1	; 0x01
     aa2:	9f 83       	std	Y+7, r25	; 0x07
     aa4:	8e 83       	std	Y+6, r24	; 0x06
			xMatchFound = pdFALSE;
     aa6:	19 82       	std	Y+1, r1	; 0x01

			/* Split the bits waited for from the control bits. */
			uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;
     aa8:	8e 81       	ldd	r24, Y+6	; 0x06
     aaa:	9f 81       	ldd	r25, Y+7	; 0x07
     aac:	80 70       	andi	r24, 0x00	; 0
     aae:	9d 83       	std	Y+5, r25	; 0x05
     ab0:	8c 83       	std	Y+4, r24	; 0x04
			uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
     ab2:	8e 81       	ldd	r24, Y+6	; 0x06
     ab4:	9f 81       	ldd	r25, Y+7	; 0x07
     ab6:	90 70       	andi	r25, 0x00	; 0
     ab8:	9f 83       	std	Y+7, r25	; 0x07
     aba:	8e 83       	std	Y+6, r24	; 0x06

			if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
     abc:	8c 81       	ldd	r24, Y+4	; 0x04
     abe:	9d 81       	ldd	r25, Y+5	; 0x05
     ac0:	80 70       	andi	r24, 0x00	; 0
     ac2:	94 70       	andi	r25, 0x04	; 4
     ac4:	00 97       	sbiw	r24, 0x00	; 0
     ac6:	69 f4       	brne	.+26     	; 0xae2 <xEventGroupSetBits+0xbc>
			{
				/* Just looking for single bit being set. */
				if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
     ac8:	ea 81       	ldd	r30, Y+2	; 0x02
     aca:	fb 81       	ldd	r31, Y+3	; 0x03
     acc:	20 81       	ld	r18, Z
     ace:	31 81       	ldd	r19, Z+1	; 0x01
     ad0:	8e 81       	ldd	r24, Y+6	; 0x06
     ad2:	9f 81       	ldd	r25, Y+7	; 0x07
     ad4:	82 23       	and	r24, r18
     ad6:	93 23       	and	r25, r19
     ad8:	00 97       	sbiw	r24, 0x00	; 0
     ada:	91 f0       	breq	.+36     	; 0xb00 <xEventGroupSetBits+0xda>
				{
					xMatchFound = pdTRUE;
     adc:	81 e0       	ldi	r24, 0x01	; 1
     ade:	89 83       	std	Y+1, r24	; 0x01
     ae0:	0f c0       	rjmp	.+30     	; 0xb00 <xEventGroupSetBits+0xda>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
     ae2:	ea 81       	ldd	r30, Y+2	; 0x02
     ae4:	fb 81       	ldd	r31, Y+3	; 0x03
     ae6:	20 81       	ld	r18, Z
     ae8:	31 81       	ldd	r19, Z+1	; 0x01
     aea:	8e 81       	ldd	r24, Y+6	; 0x06
     aec:	9f 81       	ldd	r25, Y+7	; 0x07
     aee:	28 23       	and	r18, r24
     af0:	39 23       	and	r19, r25
     af2:	8e 81       	ldd	r24, Y+6	; 0x06
     af4:	9f 81       	ldd	r25, Y+7	; 0x07
     af6:	28 17       	cp	r18, r24
     af8:	39 07       	cpc	r19, r25
     afa:	11 f4       	brne	.+4      	; 0xb00 <xEventGroupSetBits+0xda>
			{
				/* All bits are set. */
				xMatchFound = pdTRUE;
     afc:	81 e0       	ldi	r24, 0x01	; 1
     afe:	89 83       	std	Y+1, r24	; 0x01
			else
			{
				/* Need all bits to be set, but not all the bits were set. */
			}

			if( xMatchFound != pdFALSE )
     b00:	89 81       	ldd	r24, Y+1	; 0x01
     b02:	88 23       	and	r24, r24
     b04:	c9 f0       	breq	.+50     	; 0xb38 <xEventGroupSetBits+0x112>
			{
				/* The bits match.  Should the bits be cleared on exit? */
				if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
     b06:	8c 81       	ldd	r24, Y+4	; 0x04
     b08:	9d 81       	ldd	r25, Y+5	; 0x05
     b0a:	80 70       	andi	r24, 0x00	; 0
     b0c:	91 70       	andi	r25, 0x01	; 1
     b0e:	00 97       	sbiw	r24, 0x00	; 0
     b10:	41 f0       	breq	.+16     	; 0xb22 <xEventGroupSetBits+0xfc>
				{
					uxBitsToClear |= uxBitsWaitedFor;
     b12:	88 85       	ldd	r24, Y+8	; 0x08
     b14:	99 85       	ldd	r25, Y+9	; 0x09
     b16:	2e 81       	ldd	r18, Y+6	; 0x06
     b18:	3f 81       	ldd	r19, Y+7	; 0x07
     b1a:	82 2b       	or	r24, r18
     b1c:	93 2b       	or	r25, r19
     b1e:	99 87       	std	Y+9, r25	; 0x09
     b20:	88 87       	std	Y+8, r24	; 0x08
				/* Store the actual event flag value in the task's event list
				item before removing the task from the event list.  The
				eventUNBLOCKED_DUE_TO_BIT_SET bit is set so the task knows
				that is was unblocked due to its required bits matching, rather
				than because it timed out. */
				vTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
     b22:	ea 81       	ldd	r30, Y+2	; 0x02
     b24:	fb 81       	ldd	r31, Y+3	; 0x03
     b26:	80 81       	ld	r24, Z
     b28:	91 81       	ldd	r25, Z+1	; 0x01
     b2a:	9c 01       	movw	r18, r24
     b2c:	32 60       	ori	r19, 0x02	; 2
     b2e:	88 89       	ldd	r24, Y+16	; 0x10
     b30:	99 89       	ldd	r25, Y+17	; 0x11
     b32:	b9 01       	movw	r22, r18
     b34:	0e 94 c0 1d 	call	0x3b80	; 0x3b80 <vTaskRemoveFromUnorderedEventList>
			}

			/* Move onto the next list item.  Note pxListItem->pxNext is not
			used here as the list item may have been removed from the event list
			and inserted into the ready/pending reading list. */
			pxListItem = pxNext;
     b38:	8e 85       	ldd	r24, Y+14	; 0x0e
     b3a:	9f 85       	ldd	r25, Y+15	; 0x0f
     b3c:	99 8b       	std	Y+17, r25	; 0x11
     b3e:	88 8b       	std	Y+16, r24	; 0x10

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
     b40:	28 89       	ldd	r18, Y+16	; 0x10
     b42:	39 89       	ldd	r19, Y+17	; 0x11
     b44:	8c 85       	ldd	r24, Y+12	; 0x0c
     b46:	9d 85       	ldd	r25, Y+13	; 0x0d
     b48:	28 17       	cp	r18, r24
     b4a:	39 07       	cpc	r19, r25
     b4c:	09 f0       	breq	.+2      	; 0xb50 <xEventGroupSetBits+0x12a>
     b4e:	9f cf       	rjmp	.-194    	; 0xa8e <xEventGroupSetBits+0x68>
			pxListItem = pxNext;
		}

		/* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT
		bit was set in the control word. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
     b50:	ea 81       	ldd	r30, Y+2	; 0x02
     b52:	fb 81       	ldd	r31, Y+3	; 0x03
     b54:	20 81       	ld	r18, Z
     b56:	31 81       	ldd	r19, Z+1	; 0x01
     b58:	88 85       	ldd	r24, Y+8	; 0x08
     b5a:	99 85       	ldd	r25, Y+9	; 0x09
     b5c:	80 95       	com	r24
     b5e:	90 95       	com	r25
     b60:	82 23       	and	r24, r18
     b62:	93 23       	and	r25, r19
     b64:	ea 81       	ldd	r30, Y+2	; 0x02
     b66:	fb 81       	ldd	r31, Y+3	; 0x03
     b68:	91 83       	std	Z+1, r25	; 0x01
     b6a:	80 83       	st	Z, r24
	}
	( void ) xTaskResumeAll();
     b6c:	0e 94 c1 1a 	call	0x3582	; 0x3582 <xTaskResumeAll>

	return pxEventBits->uxEventBits;
     b70:	ea 81       	ldd	r30, Y+2	; 0x02
     b72:	fb 81       	ldd	r31, Y+3	; 0x03
     b74:	80 81       	ld	r24, Z
     b76:	91 81       	ldd	r25, Z+1	; 0x01
}
     b78:	65 96       	adiw	r28, 0x15	; 21
     b7a:	0f b6       	in	r0, 0x3f	; 63
     b7c:	f8 94       	cli
     b7e:	de bf       	out	0x3e, r29	; 62
     b80:	0f be       	out	0x3f, r0	; 63
     b82:	cd bf       	out	0x3d, r28	; 61
     b84:	cf 91       	pop	r28
     b86:	df 91       	pop	r29
     b88:	08 95       	ret

00000b8a <vEventGroupDelete>:
/*-----------------------------------------------------------*/

void vEventGroupDelete( EventGroupHandle_t xEventGroup )
{
     b8a:	df 93       	push	r29
     b8c:	cf 93       	push	r28
     b8e:	00 d0       	rcall	.+0      	; 0xb90 <vEventGroupDelete+0x6>
     b90:	00 d0       	rcall	.+0      	; 0xb92 <vEventGroupDelete+0x8>
     b92:	00 d0       	rcall	.+0      	; 0xb94 <vEventGroupDelete+0xa>
     b94:	cd b7       	in	r28, 0x3d	; 61
     b96:	de b7       	in	r29, 0x3e	; 62
     b98:	9e 83       	std	Y+6, r25	; 0x06
     b9a:	8d 83       	std	Y+5, r24	; 0x05
EventGroup_t *pxEventBits = xEventGroup;
     b9c:	8d 81       	ldd	r24, Y+5	; 0x05
     b9e:	9e 81       	ldd	r25, Y+6	; 0x06
     ba0:	9c 83       	std	Y+4, r25	; 0x04
     ba2:	8b 83       	std	Y+3, r24	; 0x03
const List_t *pxTasksWaitingForBits = &( pxEventBits->xTasksWaitingForBits );
     ba4:	8b 81       	ldd	r24, Y+3	; 0x03
     ba6:	9c 81       	ldd	r25, Y+4	; 0x04
     ba8:	02 96       	adiw	r24, 0x02	; 2
     baa:	9a 83       	std	Y+2, r25	; 0x02
     bac:	89 83       	std	Y+1, r24	; 0x01

	vTaskSuspendAll();
     bae:	0e 94 b5 1a 	call	0x356a	; 0x356a <vTaskSuspendAll>
     bb2:	08 c0       	rjmp	.+16     	; 0xbc4 <vEventGroupDelete+0x3a>
		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
		{
			/* Unblock the task, returning 0 as the event list is being deleted
			and cannot therefore have any bits set. */
			configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( const ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
			vTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
     bb4:	e9 81       	ldd	r30, Y+1	; 0x01
     bb6:	fa 81       	ldd	r31, Y+2	; 0x02
     bb8:	85 81       	ldd	r24, Z+5	; 0x05
     bba:	96 81       	ldd	r25, Z+6	; 0x06
     bbc:	60 e0       	ldi	r22, 0x00	; 0
     bbe:	72 e0       	ldi	r23, 0x02	; 2
     bc0:	0e 94 c0 1d 	call	0x3b80	; 0x3b80 <vTaskRemoveFromUnorderedEventList>

	vTaskSuspendAll();
	{
		traceEVENT_GROUP_DELETE( xEventGroup );

		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
     bc4:	e9 81       	ldd	r30, Y+1	; 0x01
     bc6:	fa 81       	ldd	r31, Y+2	; 0x02
     bc8:	80 81       	ld	r24, Z
     bca:	88 23       	and	r24, r24
     bcc:	99 f7       	brne	.-26     	; 0xbb4 <vEventGroupDelete+0x2a>

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
		{
			/* The event group can only have been allocated dynamically - free
			it again. */
			vPortFree( pxEventBits );
     bce:	8b 81       	ldd	r24, Y+3	; 0x03
     bd0:	9c 81       	ldd	r25, Y+4	; 0x04
     bd2:	0e 94 b8 06 	call	0xd70	; 0xd70 <vPortFree>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
	( void ) xTaskResumeAll();
     bd6:	0e 94 c1 1a 	call	0x3582	; 0x3582 <xTaskResumeAll>
}
     bda:	26 96       	adiw	r28, 0x06	; 6
     bdc:	0f b6       	in	r0, 0x3f	; 63
     bde:	f8 94       	cli
     be0:	de bf       	out	0x3e, r29	; 62
     be2:	0f be       	out	0x3f, r0	; 63
     be4:	cd bf       	out	0x3d, r28	; 61
     be6:	cf 91       	pop	r28
     be8:	df 91       	pop	r29
     bea:	08 95       	ret

00000bec <vEventGroupSetBitsCallback>:
/*-----------------------------------------------------------*/

/* For internal use only - execute a 'set bits' command that was pended from
an interrupt. */
void vEventGroupSetBitsCallback( void *pvEventGroup, const uint32_t ulBitsToSet )
{
     bec:	df 93       	push	r29
     bee:	cf 93       	push	r28
     bf0:	00 d0       	rcall	.+0      	; 0xbf2 <vEventGroupSetBitsCallback+0x6>
     bf2:	00 d0       	rcall	.+0      	; 0xbf4 <vEventGroupSetBitsCallback+0x8>
     bf4:	00 d0       	rcall	.+0      	; 0xbf6 <vEventGroupSetBitsCallback+0xa>
     bf6:	cd b7       	in	r28, 0x3d	; 61
     bf8:	de b7       	in	r29, 0x3e	; 62
     bfa:	9a 83       	std	Y+2, r25	; 0x02
     bfc:	89 83       	std	Y+1, r24	; 0x01
     bfe:	4b 83       	std	Y+3, r20	; 0x03
     c00:	5c 83       	std	Y+4, r21	; 0x04
     c02:	6d 83       	std	Y+5, r22	; 0x05
     c04:	7e 83       	std	Y+6, r23	; 0x06
	( void ) xEventGroupSetBits( pvEventGroup, ( EventBits_t ) ulBitsToSet ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
     c06:	89 81       	ldd	r24, Y+1	; 0x01
     c08:	9a 81       	ldd	r25, Y+2	; 0x02
     c0a:	2b 81       	ldd	r18, Y+3	; 0x03
     c0c:	3c 81       	ldd	r19, Y+4	; 0x04
     c0e:	b9 01       	movw	r22, r18
     c10:	0e 94 13 05 	call	0xa26	; 0xa26 <xEventGroupSetBits>
}
     c14:	26 96       	adiw	r28, 0x06	; 6
     c16:	0f b6       	in	r0, 0x3f	; 63
     c18:	f8 94       	cli
     c1a:	de bf       	out	0x3e, r29	; 62
     c1c:	0f be       	out	0x3f, r0	; 63
     c1e:	cd bf       	out	0x3d, r28	; 61
     c20:	cf 91       	pop	r28
     c22:	df 91       	pop	r29
     c24:	08 95       	ret

00000c26 <vEventGroupClearBitsCallback>:
/*-----------------------------------------------------------*/

/* For internal use only - execute a 'clear bits' command that was pended from
an interrupt. */
void vEventGroupClearBitsCallback( void *pvEventGroup, const uint32_t ulBitsToClear )
{
     c26:	df 93       	push	r29
     c28:	cf 93       	push	r28
     c2a:	00 d0       	rcall	.+0      	; 0xc2c <vEventGroupClearBitsCallback+0x6>
     c2c:	00 d0       	rcall	.+0      	; 0xc2e <vEventGroupClearBitsCallback+0x8>
     c2e:	00 d0       	rcall	.+0      	; 0xc30 <vEventGroupClearBitsCallback+0xa>
     c30:	cd b7       	in	r28, 0x3d	; 61
     c32:	de b7       	in	r29, 0x3e	; 62
     c34:	9a 83       	std	Y+2, r25	; 0x02
     c36:	89 83       	std	Y+1, r24	; 0x01
     c38:	4b 83       	std	Y+3, r20	; 0x03
     c3a:	5c 83       	std	Y+4, r21	; 0x04
     c3c:	6d 83       	std	Y+5, r22	; 0x05
     c3e:	7e 83       	std	Y+6, r23	; 0x06
	( void ) xEventGroupClearBits( pvEventGroup, ( EventBits_t ) ulBitsToClear ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
     c40:	89 81       	ldd	r24, Y+1	; 0x01
     c42:	9a 81       	ldd	r25, Y+2	; 0x02
     c44:	2b 81       	ldd	r18, Y+3	; 0x03
     c46:	3c 81       	ldd	r19, Y+4	; 0x04
     c48:	b9 01       	movw	r22, r18
     c4a:	0e 94 bb 04 	call	0x976	; 0x976 <xEventGroupClearBits>
}
     c4e:	26 96       	adiw	r28, 0x06	; 6
     c50:	0f b6       	in	r0, 0x3f	; 63
     c52:	f8 94       	cli
     c54:	de bf       	out	0x3e, r29	; 62
     c56:	0f be       	out	0x3f, r0	; 63
     c58:	cd bf       	out	0x3d, r28	; 61
     c5a:	cf 91       	pop	r28
     c5c:	df 91       	pop	r29
     c5e:	08 95       	ret

00000c60 <prvTestWaitCondition>:
/*-----------------------------------------------------------*/

static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits )
{
     c60:	df 93       	push	r29
     c62:	cf 93       	push	r28
     c64:	00 d0       	rcall	.+0      	; 0xc66 <prvTestWaitCondition+0x6>
     c66:	00 d0       	rcall	.+0      	; 0xc68 <prvTestWaitCondition+0x8>
     c68:	00 d0       	rcall	.+0      	; 0xc6a <prvTestWaitCondition+0xa>
     c6a:	cd b7       	in	r28, 0x3d	; 61
     c6c:	de b7       	in	r29, 0x3e	; 62
     c6e:	9b 83       	std	Y+3, r25	; 0x03
     c70:	8a 83       	std	Y+2, r24	; 0x02
     c72:	7d 83       	std	Y+5, r23	; 0x05
     c74:	6c 83       	std	Y+4, r22	; 0x04
     c76:	4e 83       	std	Y+6, r20	; 0x06
BaseType_t xWaitConditionMet = pdFALSE;
     c78:	19 82       	std	Y+1, r1	; 0x01

	if( xWaitForAllBits == pdFALSE )
     c7a:	8e 81       	ldd	r24, Y+6	; 0x06
     c7c:	88 23       	and	r24, r24
     c7e:	59 f4       	brne	.+22     	; 0xc96 <prvTestWaitCondition+0x36>
	{
		/* Task only has to wait for one bit within uxBitsToWaitFor to be
		set.  Is one already set? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
     c80:	8a 81       	ldd	r24, Y+2	; 0x02
     c82:	9b 81       	ldd	r25, Y+3	; 0x03
     c84:	2c 81       	ldd	r18, Y+4	; 0x04
     c86:	3d 81       	ldd	r19, Y+5	; 0x05
     c88:	82 23       	and	r24, r18
     c8a:	93 23       	and	r25, r19
     c8c:	00 97       	sbiw	r24, 0x00	; 0
     c8e:	81 f0       	breq	.+32     	; 0xcb0 <prvTestWaitCondition+0x50>
		{
			xWaitConditionMet = pdTRUE;
     c90:	81 e0       	ldi	r24, 0x01	; 1
     c92:	89 83       	std	Y+1, r24	; 0x01
     c94:	0d c0       	rjmp	.+26     	; 0xcb0 <prvTestWaitCondition+0x50>
	}
	else
	{
		/* Task has to wait for all the bits in uxBitsToWaitFor to be set.
		Are they set already? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
     c96:	2a 81       	ldd	r18, Y+2	; 0x02
     c98:	3b 81       	ldd	r19, Y+3	; 0x03
     c9a:	8c 81       	ldd	r24, Y+4	; 0x04
     c9c:	9d 81       	ldd	r25, Y+5	; 0x05
     c9e:	28 23       	and	r18, r24
     ca0:	39 23       	and	r19, r25
     ca2:	8c 81       	ldd	r24, Y+4	; 0x04
     ca4:	9d 81       	ldd	r25, Y+5	; 0x05
     ca6:	28 17       	cp	r18, r24
     ca8:	39 07       	cpc	r19, r25
     caa:	11 f4       	brne	.+4      	; 0xcb0 <prvTestWaitCondition+0x50>
		{
			xWaitConditionMet = pdTRUE;
     cac:	81 e0       	ldi	r24, 0x01	; 1
     cae:	89 83       	std	Y+1, r24	; 0x01
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	return xWaitConditionMet;
     cb0:	89 81       	ldd	r24, Y+1	; 0x01
}
     cb2:	26 96       	adiw	r28, 0x06	; 6
     cb4:	0f b6       	in	r0, 0x3f	; 63
     cb6:	f8 94       	cli
     cb8:	de bf       	out	0x3e, r29	; 62
     cba:	0f be       	out	0x3f, r0	; 63
     cbc:	cd bf       	out	0x3d, r28	; 61
     cbe:	cf 91       	pop	r28
     cc0:	df 91       	pop	r29
     cc2:	08 95       	ret

00000cc4 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     cc4:	df 93       	push	r29
     cc6:	cf 93       	push	r28
     cc8:	00 d0       	rcall	.+0      	; 0xcca <pvPortMalloc+0x6>
     cca:	00 d0       	rcall	.+0      	; 0xccc <pvPortMalloc+0x8>
     ccc:	cd b7       	in	r28, 0x3d	; 61
     cce:	de b7       	in	r29, 0x3e	; 62
     cd0:	9c 83       	std	Y+4, r25	; 0x04
     cd2:	8b 83       	std	Y+3, r24	; 0x03
void *pvReturn = NULL;
     cd4:	1a 82       	std	Y+2, r1	; 0x02
     cd6:	19 82       	std	Y+1, r1	; 0x01
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	}
	#endif

	vTaskSuspendAll();
     cd8:	0e 94 b5 1a 	call	0x356a	; 0x356a <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
     cdc:	80 91 7a 00 	lds	r24, 0x007A
     ce0:	90 91 7b 00 	lds	r25, 0x007B
     ce4:	00 97       	sbiw	r24, 0x00	; 0
     ce6:	31 f4       	brne	.+12     	; 0xcf4 <pvPortMalloc+0x30>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
     ce8:	8d e7       	ldi	r24, 0x7D	; 125
     cea:	90 e0       	ldi	r25, 0x00	; 0
     cec:	90 93 7b 00 	sts	0x007B, r25
     cf0:	80 93 7a 00 	sts	0x007A, r24
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
     cf4:	80 91 78 00 	lds	r24, 0x0078
     cf8:	90 91 79 00 	lds	r25, 0x0079
     cfc:	2b 81       	ldd	r18, Y+3	; 0x03
     cfe:	3c 81       	ldd	r19, Y+4	; 0x04
     d00:	82 0f       	add	r24, r18
     d02:	93 1f       	adc	r25, r19
     d04:	25 e0       	ldi	r18, 0x05	; 5
     d06:	8b 3d       	cpi	r24, 0xDB	; 219
     d08:	92 07       	cpc	r25, r18
     d0a:	38 f5       	brcc	.+78     	; 0xd5a <pvPortMalloc+0x96>
     d0c:	20 91 78 00 	lds	r18, 0x0078
     d10:	30 91 79 00 	lds	r19, 0x0079
     d14:	8b 81       	ldd	r24, Y+3	; 0x03
     d16:	9c 81       	ldd	r25, Y+4	; 0x04
     d18:	28 0f       	add	r18, r24
     d1a:	39 1f       	adc	r19, r25
     d1c:	80 91 78 00 	lds	r24, 0x0078
     d20:	90 91 79 00 	lds	r25, 0x0079
     d24:	82 17       	cp	r24, r18
     d26:	93 07       	cpc	r25, r19
     d28:	c0 f4       	brcc	.+48     	; 0xd5a <pvPortMalloc+0x96>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
     d2a:	20 91 7a 00 	lds	r18, 0x007A
     d2e:	30 91 7b 00 	lds	r19, 0x007B
     d32:	80 91 78 00 	lds	r24, 0x0078
     d36:	90 91 79 00 	lds	r25, 0x0079
     d3a:	82 0f       	add	r24, r18
     d3c:	93 1f       	adc	r25, r19
     d3e:	9a 83       	std	Y+2, r25	; 0x02
     d40:	89 83       	std	Y+1, r24	; 0x01
			xNextFreeByte += xWantedSize;
     d42:	20 91 78 00 	lds	r18, 0x0078
     d46:	30 91 79 00 	lds	r19, 0x0079
     d4a:	8b 81       	ldd	r24, Y+3	; 0x03
     d4c:	9c 81       	ldd	r25, Y+4	; 0x04
     d4e:	82 0f       	add	r24, r18
     d50:	93 1f       	adc	r25, r19
     d52:	90 93 79 00 	sts	0x0079, r25
     d56:	80 93 78 00 	sts	0x0078, r24
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     d5a:	0e 94 c1 1a 	call	0x3582	; 0x3582 <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif

	return pvReturn;
     d5e:	89 81       	ldd	r24, Y+1	; 0x01
     d60:	9a 81       	ldd	r25, Y+2	; 0x02
}
     d62:	0f 90       	pop	r0
     d64:	0f 90       	pop	r0
     d66:	0f 90       	pop	r0
     d68:	0f 90       	pop	r0
     d6a:	cf 91       	pop	r28
     d6c:	df 91       	pop	r29
     d6e:	08 95       	ret

00000d70 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     d70:	df 93       	push	r29
     d72:	cf 93       	push	r28
     d74:	00 d0       	rcall	.+0      	; 0xd76 <vPortFree+0x6>
     d76:	cd b7       	in	r28, 0x3d	; 61
     d78:	de b7       	in	r29, 0x3e	; 62
     d7a:	9a 83       	std	Y+2, r25	; 0x02
     d7c:	89 83       	std	Y+1, r24	; 0x01
	http://www.FreeRTOS.org for more information. */
	( void ) pv;

	/* Force an assert as it is invalid to call this function. */
	configASSERT( pv == NULL );
}
     d7e:	0f 90       	pop	r0
     d80:	0f 90       	pop	r0
     d82:	cf 91       	pop	r28
     d84:	df 91       	pop	r29
     d86:	08 95       	ret

00000d88 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
     d88:	df 93       	push	r29
     d8a:	cf 93       	push	r28
     d8c:	cd b7       	in	r28, 0x3d	; 61
     d8e:	de b7       	in	r29, 0x3e	; 62
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
     d90:	10 92 79 00 	sts	0x0079, r1
     d94:	10 92 78 00 	sts	0x0078, r1
}
     d98:	cf 91       	pop	r28
     d9a:	df 91       	pop	r29
     d9c:	08 95       	ret

00000d9e <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
     d9e:	df 93       	push	r29
     da0:	cf 93       	push	r28
     da2:	cd b7       	in	r28, 0x3d	; 61
     da4:	de b7       	in	r29, 0x3e	; 62
	return ( configADJUSTED_HEAP_SIZE - xNextFreeByte );
     da6:	20 91 78 00 	lds	r18, 0x0078
     daa:	30 91 79 00 	lds	r19, 0x0079
     dae:	8b ed       	ldi	r24, 0xDB	; 219
     db0:	95 e0       	ldi	r25, 0x05	; 5
     db2:	82 1b       	sub	r24, r18
     db4:	93 0b       	sbc	r25, r19
}
     db6:	cf 91       	pop	r28
     db8:	df 91       	pop	r29
     dba:	08 95       	ret

00000dbc <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     dbc:	df 93       	push	r29
     dbe:	cf 93       	push	r28
     dc0:	00 d0       	rcall	.+0      	; 0xdc2 <vListInitialise+0x6>
     dc2:	cd b7       	in	r28, 0x3d	; 61
     dc4:	de b7       	in	r29, 0x3e	; 62
     dc6:	9a 83       	std	Y+2, r25	; 0x02
     dc8:	89 83       	std	Y+1, r24	; 0x01
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     dca:	89 81       	ldd	r24, Y+1	; 0x01
     dcc:	9a 81       	ldd	r25, Y+2	; 0x02
     dce:	03 96       	adiw	r24, 0x03	; 3
     dd0:	e9 81       	ldd	r30, Y+1	; 0x01
     dd2:	fa 81       	ldd	r31, Y+2	; 0x02
     dd4:	92 83       	std	Z+2, r25	; 0x02
     dd6:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     dd8:	e9 81       	ldd	r30, Y+1	; 0x01
     dda:	fa 81       	ldd	r31, Y+2	; 0x02
     ddc:	8f ef       	ldi	r24, 0xFF	; 255
     dde:	9f ef       	ldi	r25, 0xFF	; 255
     de0:	94 83       	std	Z+4, r25	; 0x04
     de2:	83 83       	std	Z+3, r24	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     de4:	89 81       	ldd	r24, Y+1	; 0x01
     de6:	9a 81       	ldd	r25, Y+2	; 0x02
     de8:	03 96       	adiw	r24, 0x03	; 3
     dea:	e9 81       	ldd	r30, Y+1	; 0x01
     dec:	fa 81       	ldd	r31, Y+2	; 0x02
     dee:	96 83       	std	Z+6, r25	; 0x06
     df0:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     df2:	89 81       	ldd	r24, Y+1	; 0x01
     df4:	9a 81       	ldd	r25, Y+2	; 0x02
     df6:	03 96       	adiw	r24, 0x03	; 3
     df8:	e9 81       	ldd	r30, Y+1	; 0x01
     dfa:	fa 81       	ldd	r31, Y+2	; 0x02
     dfc:	90 87       	std	Z+8, r25	; 0x08
     dfe:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     e00:	e9 81       	ldd	r30, Y+1	; 0x01
     e02:	fa 81       	ldd	r31, Y+2	; 0x02
     e04:	10 82       	st	Z, r1

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
     e06:	0f 90       	pop	r0
     e08:	0f 90       	pop	r0
     e0a:	cf 91       	pop	r28
     e0c:	df 91       	pop	r29
     e0e:	08 95       	ret

00000e10 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
     e10:	df 93       	push	r29
     e12:	cf 93       	push	r28
     e14:	00 d0       	rcall	.+0      	; 0xe16 <vListInitialiseItem+0x6>
     e16:	cd b7       	in	r28, 0x3d	; 61
     e18:	de b7       	in	r29, 0x3e	; 62
     e1a:	9a 83       	std	Y+2, r25	; 0x02
     e1c:	89 83       	std	Y+1, r24	; 0x01
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pxContainer = NULL;
     e1e:	e9 81       	ldd	r30, Y+1	; 0x01
     e20:	fa 81       	ldd	r31, Y+2	; 0x02
     e22:	11 86       	std	Z+9, r1	; 0x09
     e24:	10 86       	std	Z+8, r1	; 0x08

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
     e26:	0f 90       	pop	r0
     e28:	0f 90       	pop	r0
     e2a:	cf 91       	pop	r28
     e2c:	df 91       	pop	r29
     e2e:	08 95       	ret

00000e30 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     e30:	df 93       	push	r29
     e32:	cf 93       	push	r28
     e34:	00 d0       	rcall	.+0      	; 0xe36 <vListInsertEnd+0x6>
     e36:	00 d0       	rcall	.+0      	; 0xe38 <vListInsertEnd+0x8>
     e38:	00 d0       	rcall	.+0      	; 0xe3a <vListInsertEnd+0xa>
     e3a:	cd b7       	in	r28, 0x3d	; 61
     e3c:	de b7       	in	r29, 0x3e	; 62
     e3e:	9c 83       	std	Y+4, r25	; 0x04
     e40:	8b 83       	std	Y+3, r24	; 0x03
     e42:	7e 83       	std	Y+6, r23	; 0x06
     e44:	6d 83       	std	Y+5, r22	; 0x05
ListItem_t * const pxIndex = pxList->pxIndex;
     e46:	eb 81       	ldd	r30, Y+3	; 0x03
     e48:	fc 81       	ldd	r31, Y+4	; 0x04
     e4a:	81 81       	ldd	r24, Z+1	; 0x01
     e4c:	92 81       	ldd	r25, Z+2	; 0x02
     e4e:	9a 83       	std	Y+2, r25	; 0x02
     e50:	89 83       	std	Y+1, r24	; 0x01
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     e52:	ed 81       	ldd	r30, Y+5	; 0x05
     e54:	fe 81       	ldd	r31, Y+6	; 0x06
     e56:	89 81       	ldd	r24, Y+1	; 0x01
     e58:	9a 81       	ldd	r25, Y+2	; 0x02
     e5a:	93 83       	std	Z+3, r25	; 0x03
     e5c:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     e5e:	e9 81       	ldd	r30, Y+1	; 0x01
     e60:	fa 81       	ldd	r31, Y+2	; 0x02
     e62:	84 81       	ldd	r24, Z+4	; 0x04
     e64:	95 81       	ldd	r25, Z+5	; 0x05
     e66:	ed 81       	ldd	r30, Y+5	; 0x05
     e68:	fe 81       	ldd	r31, Y+6	; 0x06
     e6a:	95 83       	std	Z+5, r25	; 0x05
     e6c:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
     e6e:	e9 81       	ldd	r30, Y+1	; 0x01
     e70:	fa 81       	ldd	r31, Y+2	; 0x02
     e72:	04 80       	ldd	r0, Z+4	; 0x04
     e74:	f5 81       	ldd	r31, Z+5	; 0x05
     e76:	e0 2d       	mov	r30, r0
     e78:	8d 81       	ldd	r24, Y+5	; 0x05
     e7a:	9e 81       	ldd	r25, Y+6	; 0x06
     e7c:	93 83       	std	Z+3, r25	; 0x03
     e7e:	82 83       	std	Z+2, r24	; 0x02
	pxIndex->pxPrevious = pxNewListItem;
     e80:	e9 81       	ldd	r30, Y+1	; 0x01
     e82:	fa 81       	ldd	r31, Y+2	; 0x02
     e84:	8d 81       	ldd	r24, Y+5	; 0x05
     e86:	9e 81       	ldd	r25, Y+6	; 0x06
     e88:	95 83       	std	Z+5, r25	; 0x05
     e8a:	84 83       	std	Z+4, r24	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pxContainer = pxList;
     e8c:	ed 81       	ldd	r30, Y+5	; 0x05
     e8e:	fe 81       	ldd	r31, Y+6	; 0x06
     e90:	8b 81       	ldd	r24, Y+3	; 0x03
     e92:	9c 81       	ldd	r25, Y+4	; 0x04
     e94:	91 87       	std	Z+9, r25	; 0x09
     e96:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     e98:	eb 81       	ldd	r30, Y+3	; 0x03
     e9a:	fc 81       	ldd	r31, Y+4	; 0x04
     e9c:	80 81       	ld	r24, Z
     e9e:	8f 5f       	subi	r24, 0xFF	; 255
     ea0:	eb 81       	ldd	r30, Y+3	; 0x03
     ea2:	fc 81       	ldd	r31, Y+4	; 0x04
     ea4:	80 83       	st	Z, r24
}
     ea6:	26 96       	adiw	r28, 0x06	; 6
     ea8:	0f b6       	in	r0, 0x3f	; 63
     eaa:	f8 94       	cli
     eac:	de bf       	out	0x3e, r29	; 62
     eae:	0f be       	out	0x3f, r0	; 63
     eb0:	cd bf       	out	0x3d, r28	; 61
     eb2:	cf 91       	pop	r28
     eb4:	df 91       	pop	r29
     eb6:	08 95       	ret

00000eb8 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     eb8:	df 93       	push	r29
     eba:	cf 93       	push	r28
     ebc:	cd b7       	in	r28, 0x3d	; 61
     ebe:	de b7       	in	r29, 0x3e	; 62
     ec0:	28 97       	sbiw	r28, 0x08	; 8
     ec2:	0f b6       	in	r0, 0x3f	; 63
     ec4:	f8 94       	cli
     ec6:	de bf       	out	0x3e, r29	; 62
     ec8:	0f be       	out	0x3f, r0	; 63
     eca:	cd bf       	out	0x3d, r28	; 61
     ecc:	9e 83       	std	Y+6, r25	; 0x06
     ece:	8d 83       	std	Y+5, r24	; 0x05
     ed0:	78 87       	std	Y+8, r23	; 0x08
     ed2:	6f 83       	std	Y+7, r22	; 0x07
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     ed4:	ef 81       	ldd	r30, Y+7	; 0x07
     ed6:	f8 85       	ldd	r31, Y+8	; 0x08
     ed8:	80 81       	ld	r24, Z
     eda:	91 81       	ldd	r25, Z+1	; 0x01
     edc:	9a 83       	std	Y+2, r25	; 0x02
     ede:	89 83       	std	Y+1, r24	; 0x01
	new list item should be placed after it.  This ensures that TCBs which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     ee0:	89 81       	ldd	r24, Y+1	; 0x01
     ee2:	9a 81       	ldd	r25, Y+2	; 0x02
     ee4:	2f ef       	ldi	r18, 0xFF	; 255
     ee6:	8f 3f       	cpi	r24, 0xFF	; 255
     ee8:	92 07       	cpc	r25, r18
     eea:	39 f4       	brne	.+14     	; 0xefa <vListInsert+0x42>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     eec:	ed 81       	ldd	r30, Y+5	; 0x05
     eee:	fe 81       	ldd	r31, Y+6	; 0x06
     ef0:	87 81       	ldd	r24, Z+7	; 0x07
     ef2:	90 85       	ldd	r25, Z+8	; 0x08
     ef4:	9c 83       	std	Y+4, r25	; 0x04
     ef6:	8b 83       	std	Y+3, r24	; 0x03
     ef8:	18 c0       	rjmp	.+48     	; 0xf2a <vListInsert+0x72>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
     efa:	8d 81       	ldd	r24, Y+5	; 0x05
     efc:	9e 81       	ldd	r25, Y+6	; 0x06
     efe:	03 96       	adiw	r24, 0x03	; 3
     f00:	9c 83       	std	Y+4, r25	; 0x04
     f02:	8b 83       	std	Y+3, r24	; 0x03
     f04:	06 c0       	rjmp	.+12     	; 0xf12 <vListInsert+0x5a>
     f06:	eb 81       	ldd	r30, Y+3	; 0x03
     f08:	fc 81       	ldd	r31, Y+4	; 0x04
     f0a:	82 81       	ldd	r24, Z+2	; 0x02
     f0c:	93 81       	ldd	r25, Z+3	; 0x03
     f0e:	9c 83       	std	Y+4, r25	; 0x04
     f10:	8b 83       	std	Y+3, r24	; 0x03
     f12:	eb 81       	ldd	r30, Y+3	; 0x03
     f14:	fc 81       	ldd	r31, Y+4	; 0x04
     f16:	02 80       	ldd	r0, Z+2	; 0x02
     f18:	f3 81       	ldd	r31, Z+3	; 0x03
     f1a:	e0 2d       	mov	r30, r0
     f1c:	20 81       	ld	r18, Z
     f1e:	31 81       	ldd	r19, Z+1	; 0x01
     f20:	89 81       	ldd	r24, Y+1	; 0x01
     f22:	9a 81       	ldd	r25, Y+2	; 0x02
     f24:	82 17       	cp	r24, r18
     f26:	93 07       	cpc	r25, r19
     f28:	70 f7       	brcc	.-36     	; 0xf06 <vListInsert+0x4e>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     f2a:	eb 81       	ldd	r30, Y+3	; 0x03
     f2c:	fc 81       	ldd	r31, Y+4	; 0x04
     f2e:	82 81       	ldd	r24, Z+2	; 0x02
     f30:	93 81       	ldd	r25, Z+3	; 0x03
     f32:	ef 81       	ldd	r30, Y+7	; 0x07
     f34:	f8 85       	ldd	r31, Y+8	; 0x08
     f36:	93 83       	std	Z+3, r25	; 0x03
     f38:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     f3a:	ef 81       	ldd	r30, Y+7	; 0x07
     f3c:	f8 85       	ldd	r31, Y+8	; 0x08
     f3e:	02 80       	ldd	r0, Z+2	; 0x02
     f40:	f3 81       	ldd	r31, Z+3	; 0x03
     f42:	e0 2d       	mov	r30, r0
     f44:	8f 81       	ldd	r24, Y+7	; 0x07
     f46:	98 85       	ldd	r25, Y+8	; 0x08
     f48:	95 83       	std	Z+5, r25	; 0x05
     f4a:	84 83       	std	Z+4, r24	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     f4c:	ef 81       	ldd	r30, Y+7	; 0x07
     f4e:	f8 85       	ldd	r31, Y+8	; 0x08
     f50:	8b 81       	ldd	r24, Y+3	; 0x03
     f52:	9c 81       	ldd	r25, Y+4	; 0x04
     f54:	95 83       	std	Z+5, r25	; 0x05
     f56:	84 83       	std	Z+4, r24	; 0x04
	pxIterator->pxNext = pxNewListItem;
     f58:	eb 81       	ldd	r30, Y+3	; 0x03
     f5a:	fc 81       	ldd	r31, Y+4	; 0x04
     f5c:	8f 81       	ldd	r24, Y+7	; 0x07
     f5e:	98 85       	ldd	r25, Y+8	; 0x08
     f60:	93 83       	std	Z+3, r25	; 0x03
     f62:	82 83       	std	Z+2, r24	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pxContainer = pxList;
     f64:	ef 81       	ldd	r30, Y+7	; 0x07
     f66:	f8 85       	ldd	r31, Y+8	; 0x08
     f68:	8d 81       	ldd	r24, Y+5	; 0x05
     f6a:	9e 81       	ldd	r25, Y+6	; 0x06
     f6c:	91 87       	std	Z+9, r25	; 0x09
     f6e:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     f70:	ed 81       	ldd	r30, Y+5	; 0x05
     f72:	fe 81       	ldd	r31, Y+6	; 0x06
     f74:	80 81       	ld	r24, Z
     f76:	8f 5f       	subi	r24, 0xFF	; 255
     f78:	ed 81       	ldd	r30, Y+5	; 0x05
     f7a:	fe 81       	ldd	r31, Y+6	; 0x06
     f7c:	80 83       	st	Z, r24
}
     f7e:	28 96       	adiw	r28, 0x08	; 8
     f80:	0f b6       	in	r0, 0x3f	; 63
     f82:	f8 94       	cli
     f84:	de bf       	out	0x3e, r29	; 62
     f86:	0f be       	out	0x3f, r0	; 63
     f88:	cd bf       	out	0x3d, r28	; 61
     f8a:	cf 91       	pop	r28
     f8c:	df 91       	pop	r29
     f8e:	08 95       	ret

00000f90 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     f90:	df 93       	push	r29
     f92:	cf 93       	push	r28
     f94:	00 d0       	rcall	.+0      	; 0xf96 <uxListRemove+0x6>
     f96:	00 d0       	rcall	.+0      	; 0xf98 <uxListRemove+0x8>
     f98:	cd b7       	in	r28, 0x3d	; 61
     f9a:	de b7       	in	r29, 0x3e	; 62
     f9c:	9c 83       	std	Y+4, r25	; 0x04
     f9e:	8b 83       	std	Y+3, r24	; 0x03
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
     fa0:	eb 81       	ldd	r30, Y+3	; 0x03
     fa2:	fc 81       	ldd	r31, Y+4	; 0x04
     fa4:	80 85       	ldd	r24, Z+8	; 0x08
     fa6:	91 85       	ldd	r25, Z+9	; 0x09
     fa8:	9a 83       	std	Y+2, r25	; 0x02
     faa:	89 83       	std	Y+1, r24	; 0x01

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     fac:	eb 81       	ldd	r30, Y+3	; 0x03
     fae:	fc 81       	ldd	r31, Y+4	; 0x04
     fb0:	a2 81       	ldd	r26, Z+2	; 0x02
     fb2:	b3 81       	ldd	r27, Z+3	; 0x03
     fb4:	eb 81       	ldd	r30, Y+3	; 0x03
     fb6:	fc 81       	ldd	r31, Y+4	; 0x04
     fb8:	84 81       	ldd	r24, Z+4	; 0x04
     fba:	95 81       	ldd	r25, Z+5	; 0x05
     fbc:	15 96       	adiw	r26, 0x05	; 5
     fbe:	9c 93       	st	X, r25
     fc0:	8e 93       	st	-X, r24
     fc2:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     fc4:	eb 81       	ldd	r30, Y+3	; 0x03
     fc6:	fc 81       	ldd	r31, Y+4	; 0x04
     fc8:	a4 81       	ldd	r26, Z+4	; 0x04
     fca:	b5 81       	ldd	r27, Z+5	; 0x05
     fcc:	eb 81       	ldd	r30, Y+3	; 0x03
     fce:	fc 81       	ldd	r31, Y+4	; 0x04
     fd0:	82 81       	ldd	r24, Z+2	; 0x02
     fd2:	93 81       	ldd	r25, Z+3	; 0x03
     fd4:	13 96       	adiw	r26, 0x03	; 3
     fd6:	9c 93       	st	X, r25
     fd8:	8e 93       	st	-X, r24
     fda:	12 97       	sbiw	r26, 0x02	; 2

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     fdc:	e9 81       	ldd	r30, Y+1	; 0x01
     fde:	fa 81       	ldd	r31, Y+2	; 0x02
     fe0:	21 81       	ldd	r18, Z+1	; 0x01
     fe2:	32 81       	ldd	r19, Z+2	; 0x02
     fe4:	8b 81       	ldd	r24, Y+3	; 0x03
     fe6:	9c 81       	ldd	r25, Y+4	; 0x04
     fe8:	28 17       	cp	r18, r24
     fea:	39 07       	cpc	r19, r25
     fec:	41 f4       	brne	.+16     	; 0xffe <uxListRemove+0x6e>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     fee:	eb 81       	ldd	r30, Y+3	; 0x03
     ff0:	fc 81       	ldd	r31, Y+4	; 0x04
     ff2:	84 81       	ldd	r24, Z+4	; 0x04
     ff4:	95 81       	ldd	r25, Z+5	; 0x05
     ff6:	e9 81       	ldd	r30, Y+1	; 0x01
     ff8:	fa 81       	ldd	r31, Y+2	; 0x02
     ffa:	92 83       	std	Z+2, r25	; 0x02
     ffc:	81 83       	std	Z+1, r24	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pxContainer = NULL;
     ffe:	eb 81       	ldd	r30, Y+3	; 0x03
    1000:	fc 81       	ldd	r31, Y+4	; 0x04
    1002:	11 86       	std	Z+9, r1	; 0x09
    1004:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    1006:	e9 81       	ldd	r30, Y+1	; 0x01
    1008:	fa 81       	ldd	r31, Y+2	; 0x02
    100a:	80 81       	ld	r24, Z
    100c:	81 50       	subi	r24, 0x01	; 1
    100e:	e9 81       	ldd	r30, Y+1	; 0x01
    1010:	fa 81       	ldd	r31, Y+2	; 0x02
    1012:	80 83       	st	Z, r24

	return pxList->uxNumberOfItems;
    1014:	e9 81       	ldd	r30, Y+1	; 0x01
    1016:	fa 81       	ldd	r31, Y+2	; 0x02
    1018:	80 81       	ld	r24, Z
}
    101a:	0f 90       	pop	r0
    101c:	0f 90       	pop	r0
    101e:	0f 90       	pop	r0
    1020:	0f 90       	pop	r0
    1022:	cf 91       	pop	r28
    1024:	df 91       	pop	r29
    1026:	08 95       	ret

00001028 <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
    1028:	df 93       	push	r29
    102a:	cf 93       	push	r28
    102c:	00 d0       	rcall	.+0      	; 0x102e <xQueueGenericReset+0x6>
    102e:	00 d0       	rcall	.+0      	; 0x1030 <xQueueGenericReset+0x8>
    1030:	0f 92       	push	r0
    1032:	cd b7       	in	r28, 0x3d	; 61
    1034:	de b7       	in	r29, 0x3e	; 62
    1036:	9c 83       	std	Y+4, r25	; 0x04
    1038:	8b 83       	std	Y+3, r24	; 0x03
    103a:	6d 83       	std	Y+5, r22	; 0x05
Queue_t * const pxQueue = xQueue;
    103c:	8b 81       	ldd	r24, Y+3	; 0x03
    103e:	9c 81       	ldd	r25, Y+4	; 0x04
    1040:	9a 83       	std	Y+2, r25	; 0x02
    1042:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    1044:	0f b6       	in	r0, 0x3f	; 63
    1046:	f8 94       	cli
    1048:	0f 92       	push	r0
	{
		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    104a:	e9 81       	ldd	r30, Y+1	; 0x01
    104c:	fa 81       	ldd	r31, Y+2	; 0x02
    104e:	40 81       	ld	r20, Z
    1050:	51 81       	ldd	r21, Z+1	; 0x01
    1052:	e9 81       	ldd	r30, Y+1	; 0x01
    1054:	fa 81       	ldd	r31, Y+2	; 0x02
    1056:	83 8d       	ldd	r24, Z+27	; 0x1b
    1058:	28 2f       	mov	r18, r24
    105a:	30 e0       	ldi	r19, 0x00	; 0
    105c:	e9 81       	ldd	r30, Y+1	; 0x01
    105e:	fa 81       	ldd	r31, Y+2	; 0x02
    1060:	84 8d       	ldd	r24, Z+28	; 0x1c
    1062:	88 2f       	mov	r24, r24
    1064:	90 e0       	ldi	r25, 0x00	; 0
    1066:	bc 01       	movw	r22, r24
    1068:	26 9f       	mul	r18, r22
    106a:	c0 01       	movw	r24, r0
    106c:	27 9f       	mul	r18, r23
    106e:	90 0d       	add	r25, r0
    1070:	36 9f       	mul	r19, r22
    1072:	90 0d       	add	r25, r0
    1074:	11 24       	eor	r1, r1
    1076:	84 0f       	add	r24, r20
    1078:	95 1f       	adc	r25, r21
    107a:	e9 81       	ldd	r30, Y+1	; 0x01
    107c:	fa 81       	ldd	r31, Y+2	; 0x02
    107e:	95 83       	std	Z+5, r25	; 0x05
    1080:	84 83       	std	Z+4, r24	; 0x04
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    1082:	e9 81       	ldd	r30, Y+1	; 0x01
    1084:	fa 81       	ldd	r31, Y+2	; 0x02
    1086:	12 8e       	std	Z+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    1088:	e9 81       	ldd	r30, Y+1	; 0x01
    108a:	fa 81       	ldd	r31, Y+2	; 0x02
    108c:	80 81       	ld	r24, Z
    108e:	91 81       	ldd	r25, Z+1	; 0x01
    1090:	e9 81       	ldd	r30, Y+1	; 0x01
    1092:	fa 81       	ldd	r31, Y+2	; 0x02
    1094:	93 83       	std	Z+3, r25	; 0x03
    1096:	82 83       	std	Z+2, r24	; 0x02
		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    1098:	e9 81       	ldd	r30, Y+1	; 0x01
    109a:	fa 81       	ldd	r31, Y+2	; 0x02
    109c:	40 81       	ld	r20, Z
    109e:	51 81       	ldd	r21, Z+1	; 0x01
    10a0:	e9 81       	ldd	r30, Y+1	; 0x01
    10a2:	fa 81       	ldd	r31, Y+2	; 0x02
    10a4:	83 8d       	ldd	r24, Z+27	; 0x1b
    10a6:	88 2f       	mov	r24, r24
    10a8:	90 e0       	ldi	r25, 0x00	; 0
    10aa:	9c 01       	movw	r18, r24
    10ac:	21 50       	subi	r18, 0x01	; 1
    10ae:	30 40       	sbci	r19, 0x00	; 0
    10b0:	e9 81       	ldd	r30, Y+1	; 0x01
    10b2:	fa 81       	ldd	r31, Y+2	; 0x02
    10b4:	84 8d       	ldd	r24, Z+28	; 0x1c
    10b6:	88 2f       	mov	r24, r24
    10b8:	90 e0       	ldi	r25, 0x00	; 0
    10ba:	bc 01       	movw	r22, r24
    10bc:	26 9f       	mul	r18, r22
    10be:	c0 01       	movw	r24, r0
    10c0:	27 9f       	mul	r18, r23
    10c2:	90 0d       	add	r25, r0
    10c4:	36 9f       	mul	r19, r22
    10c6:	90 0d       	add	r25, r0
    10c8:	11 24       	eor	r1, r1
    10ca:	84 0f       	add	r24, r20
    10cc:	95 1f       	adc	r25, r21
    10ce:	e9 81       	ldd	r30, Y+1	; 0x01
    10d0:	fa 81       	ldd	r31, Y+2	; 0x02
    10d2:	97 83       	std	Z+7, r25	; 0x07
    10d4:	86 83       	std	Z+6, r24	; 0x06
		pxQueue->cRxLock = queueUNLOCKED;
    10d6:	e9 81       	ldd	r30, Y+1	; 0x01
    10d8:	fa 81       	ldd	r31, Y+2	; 0x02
    10da:	8f ef       	ldi	r24, 0xFF	; 255
    10dc:	85 8f       	std	Z+29, r24	; 0x1d
		pxQueue->cTxLock = queueUNLOCKED;
    10de:	e9 81       	ldd	r30, Y+1	; 0x01
    10e0:	fa 81       	ldd	r31, Y+2	; 0x02
    10e2:	8f ef       	ldi	r24, 0xFF	; 255
    10e4:	86 8f       	std	Z+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
    10e6:	8d 81       	ldd	r24, Y+5	; 0x05
    10e8:	88 23       	and	r24, r24
    10ea:	79 f4       	brne	.+30     	; 0x110a <xQueueGenericReset+0xe2>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    10ec:	e9 81       	ldd	r30, Y+1	; 0x01
    10ee:	fa 81       	ldd	r31, Y+2	; 0x02
    10f0:	80 85       	ldd	r24, Z+8	; 0x08
    10f2:	88 23       	and	r24, r24
    10f4:	a1 f0       	breq	.+40     	; 0x111e <xQueueGenericReset+0xf6>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    10f6:	89 81       	ldd	r24, Y+1	; 0x01
    10f8:	9a 81       	ldd	r25, Y+2	; 0x02
    10fa:	08 96       	adiw	r24, 0x08	; 8
    10fc:	0e 94 55 1d 	call	0x3aaa	; 0x3aaa <xTaskRemoveFromEventList>
    1100:	88 23       	and	r24, r24
    1102:	69 f0       	breq	.+26     	; 0x111e <xQueueGenericReset+0xf6>
				{
					queueYIELD_IF_USING_PREEMPTION();
    1104:	0e 94 08 02 	call	0x410	; 0x410 <vPortYield>
    1108:	0a c0       	rjmp	.+20     	; 0x111e <xQueueGenericReset+0xf6>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    110a:	89 81       	ldd	r24, Y+1	; 0x01
    110c:	9a 81       	ldd	r25, Y+2	; 0x02
    110e:	08 96       	adiw	r24, 0x08	; 8
    1110:	0e 94 de 06 	call	0xdbc	; 0xdbc <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    1114:	89 81       	ldd	r24, Y+1	; 0x01
    1116:	9a 81       	ldd	r25, Y+2	; 0x02
    1118:	41 96       	adiw	r24, 0x11	; 17
    111a:	0e 94 de 06 	call	0xdbc	; 0xdbc <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    111e:	0f 90       	pop	r0
    1120:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
    1122:	81 e0       	ldi	r24, 0x01	; 1
}
    1124:	0f 90       	pop	r0
    1126:	0f 90       	pop	r0
    1128:	0f 90       	pop	r0
    112a:	0f 90       	pop	r0
    112c:	0f 90       	pop	r0
    112e:	cf 91       	pop	r28
    1130:	df 91       	pop	r29
    1132:	08 95       	ret

00001134 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
	{
    1134:	0f 93       	push	r16
    1136:	1f 93       	push	r17
    1138:	df 93       	push	r29
    113a:	cf 93       	push	r28
    113c:	cd b7       	in	r28, 0x3d	; 61
    113e:	de b7       	in	r29, 0x3e	; 62
    1140:	29 97       	sbiw	r28, 0x09	; 9
    1142:	0f b6       	in	r0, 0x3f	; 63
    1144:	f8 94       	cli
    1146:	de bf       	out	0x3e, r29	; 62
    1148:	0f be       	out	0x3f, r0	; 63
    114a:	cd bf       	out	0x3d, r28	; 61
    114c:	8f 83       	std	Y+7, r24	; 0x07
    114e:	68 87       	std	Y+8, r22	; 0x08
    1150:	49 87       	std	Y+9, r20	; 0x09
	size_t xQueueSizeInBytes;
	uint8_t *pucQueueStorage;

		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

		if( uxItemSize == ( UBaseType_t ) 0 )
    1152:	88 85       	ldd	r24, Y+8	; 0x08
    1154:	88 23       	and	r24, r24
    1156:	19 f4       	brne	.+6      	; 0x115e <xQueueGenericCreate+0x2a>
		{
			/* There is not going to be a queue storage area. */
			xQueueSizeInBytes = ( size_t ) 0;
    1158:	1c 82       	std	Y+4, r1	; 0x04
    115a:	1b 82       	std	Y+3, r1	; 0x03
    115c:	10 c0       	rjmp	.+32     	; 0x117e <xQueueGenericCreate+0x4a>
		}
		else
		{
			/* Allocate enough space to hold the maximum number of items that
			can be in the queue at any time. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    115e:	8f 81       	ldd	r24, Y+7	; 0x07
    1160:	28 2f       	mov	r18, r24
    1162:	30 e0       	ldi	r19, 0x00	; 0
    1164:	88 85       	ldd	r24, Y+8	; 0x08
    1166:	88 2f       	mov	r24, r24
    1168:	90 e0       	ldi	r25, 0x00	; 0
    116a:	ac 01       	movw	r20, r24
    116c:	24 9f       	mul	r18, r20
    116e:	c0 01       	movw	r24, r0
    1170:	25 9f       	mul	r18, r21
    1172:	90 0d       	add	r25, r0
    1174:	34 9f       	mul	r19, r20
    1176:	90 0d       	add	r25, r0
    1178:	11 24       	eor	r1, r1
    117a:	9c 83       	std	Y+4, r25	; 0x04
    117c:	8b 83       	std	Y+3, r24	; 0x03
		alignment requirements of the Queue_t structure - which in this case
		is an int8_t *.  Therefore, whenever the stack alignment requirements
		are greater than or equal to the pointer to char requirements the cast
		is safe.  In other cases alignment requirements are not strict (one or
		two bytes). */
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
    117e:	8b 81       	ldd	r24, Y+3	; 0x03
    1180:	9c 81       	ldd	r25, Y+4	; 0x04
    1182:	4f 96       	adiw	r24, 0x1f	; 31
    1184:	0e 94 62 06 	call	0xcc4	; 0xcc4 <pvPortMalloc>
    1188:	9e 83       	std	Y+6, r25	; 0x06
    118a:	8d 83       	std	Y+5, r24	; 0x05

		if( pxNewQueue != NULL )
    118c:	8d 81       	ldd	r24, Y+5	; 0x05
    118e:	9e 81       	ldd	r25, Y+6	; 0x06
    1190:	00 97       	sbiw	r24, 0x00	; 0
    1192:	a1 f0       	breq	.+40     	; 0x11bc <xQueueGenericCreate+0x88>
		{
			/* Jump past the queue structure to find the location of the queue
			storage area. */
			pucQueueStorage = ( uint8_t * ) pxNewQueue;
    1194:	8d 81       	ldd	r24, Y+5	; 0x05
    1196:	9e 81       	ldd	r25, Y+6	; 0x06
    1198:	9a 83       	std	Y+2, r25	; 0x02
    119a:	89 83       	std	Y+1, r24	; 0x01
			pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    119c:	89 81       	ldd	r24, Y+1	; 0x01
    119e:	9a 81       	ldd	r25, Y+2	; 0x02
    11a0:	4f 96       	adiw	r24, 0x1f	; 31
    11a2:	9a 83       	std	Y+2, r25	; 0x02
    11a4:	89 83       	std	Y+1, r24	; 0x01
				deleted. */
				pxNewQueue->ucStaticallyAllocated = pdFALSE;
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
    11a6:	29 81       	ldd	r18, Y+1	; 0x01
    11a8:	3a 81       	ldd	r19, Y+2	; 0x02
    11aa:	ed 81       	ldd	r30, Y+5	; 0x05
    11ac:	fe 81       	ldd	r31, Y+6	; 0x06
    11ae:	8f 81       	ldd	r24, Y+7	; 0x07
    11b0:	68 85       	ldd	r22, Y+8	; 0x08
    11b2:	a9 01       	movw	r20, r18
    11b4:	29 85       	ldd	r18, Y+9	; 0x09
    11b6:	8f 01       	movw	r16, r30
    11b8:	0e 94 eb 08 	call	0x11d6	; 0x11d6 <prvInitialiseNewQueue>
		{
			traceQUEUE_CREATE_FAILED( ucQueueType );
			mtCOVERAGE_TEST_MARKER();
		}

		return pxNewQueue;
    11bc:	8d 81       	ldd	r24, Y+5	; 0x05
    11be:	9e 81       	ldd	r25, Y+6	; 0x06
	}
    11c0:	29 96       	adiw	r28, 0x09	; 9
    11c2:	0f b6       	in	r0, 0x3f	; 63
    11c4:	f8 94       	cli
    11c6:	de bf       	out	0x3e, r29	; 62
    11c8:	0f be       	out	0x3f, r0	; 63
    11ca:	cd bf       	out	0x3d, r28	; 61
    11cc:	cf 91       	pop	r28
    11ce:	df 91       	pop	r29
    11d0:	1f 91       	pop	r17
    11d2:	0f 91       	pop	r16
    11d4:	08 95       	ret

000011d6 <prvInitialiseNewQueue>:

#endif /* configSUPPORT_STATIC_ALLOCATION */
/*-----------------------------------------------------------*/

static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, const uint8_t ucQueueType, Queue_t *pxNewQueue )
{
    11d6:	0f 93       	push	r16
    11d8:	1f 93       	push	r17
    11da:	df 93       	push	r29
    11dc:	cf 93       	push	r28
    11de:	cd b7       	in	r28, 0x3d	; 61
    11e0:	de b7       	in	r29, 0x3e	; 62
    11e2:	27 97       	sbiw	r28, 0x07	; 7
    11e4:	0f b6       	in	r0, 0x3f	; 63
    11e6:	f8 94       	cli
    11e8:	de bf       	out	0x3e, r29	; 62
    11ea:	0f be       	out	0x3f, r0	; 63
    11ec:	cd bf       	out	0x3d, r28	; 61
    11ee:	89 83       	std	Y+1, r24	; 0x01
    11f0:	6a 83       	std	Y+2, r22	; 0x02
    11f2:	5c 83       	std	Y+4, r21	; 0x04
    11f4:	4b 83       	std	Y+3, r20	; 0x03
    11f6:	2d 83       	std	Y+5, r18	; 0x05
    11f8:	1f 83       	std	Y+7, r17	; 0x07
    11fa:	0e 83       	std	Y+6, r16	; 0x06
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	if( uxItemSize == ( UBaseType_t ) 0 )
    11fc:	8a 81       	ldd	r24, Y+2	; 0x02
    11fe:	88 23       	and	r24, r24
    1200:	39 f4       	brne	.+14     	; 0x1210 <prvInitialiseNewQueue+0x3a>
	{
		/* No RAM was allocated for the queue storage area, but PC head cannot
		be set to NULL because NULL is used as a key to say the queue is used as
		a mutex.  Therefore just set pcHead to point to the queue as a benign
		value that is known to be within the memory map. */
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
    1202:	8e 81       	ldd	r24, Y+6	; 0x06
    1204:	9f 81       	ldd	r25, Y+7	; 0x07
    1206:	ee 81       	ldd	r30, Y+6	; 0x06
    1208:	ff 81       	ldd	r31, Y+7	; 0x07
    120a:	91 83       	std	Z+1, r25	; 0x01
    120c:	80 83       	st	Z, r24
    120e:	06 c0       	rjmp	.+12     	; 0x121c <prvInitialiseNewQueue+0x46>
	}
	else
	{
		/* Set the head to the start of the queue storage area. */
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
    1210:	8b 81       	ldd	r24, Y+3	; 0x03
    1212:	9c 81       	ldd	r25, Y+4	; 0x04
    1214:	ee 81       	ldd	r30, Y+6	; 0x06
    1216:	ff 81       	ldd	r31, Y+7	; 0x07
    1218:	91 83       	std	Z+1, r25	; 0x01
    121a:	80 83       	st	Z, r24
	}

	/* Initialise the queue members as described where the queue type is
	defined. */
	pxNewQueue->uxLength = uxQueueLength;
    121c:	ee 81       	ldd	r30, Y+6	; 0x06
    121e:	ff 81       	ldd	r31, Y+7	; 0x07
    1220:	89 81       	ldd	r24, Y+1	; 0x01
    1222:	83 8f       	std	Z+27, r24	; 0x1b
	pxNewQueue->uxItemSize = uxItemSize;
    1224:	ee 81       	ldd	r30, Y+6	; 0x06
    1226:	ff 81       	ldd	r31, Y+7	; 0x07
    1228:	8a 81       	ldd	r24, Y+2	; 0x02
    122a:	84 8f       	std	Z+28, r24	; 0x1c
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    122c:	8e 81       	ldd	r24, Y+6	; 0x06
    122e:	9f 81       	ldd	r25, Y+7	; 0x07
    1230:	61 e0       	ldi	r22, 0x01	; 1
    1232:	0e 94 14 08 	call	0x1028	; 0x1028 <xQueueGenericReset>
		pxNewQueue->pxQueueSetContainer = NULL;
	}
	#endif /* configUSE_QUEUE_SETS */

	traceQUEUE_CREATE( pxNewQueue );
}
    1236:	27 96       	adiw	r28, 0x07	; 7
    1238:	0f b6       	in	r0, 0x3f	; 63
    123a:	f8 94       	cli
    123c:	de bf       	out	0x3e, r29	; 62
    123e:	0f be       	out	0x3f, r0	; 63
    1240:	cd bf       	out	0x3d, r28	; 61
    1242:	cf 91       	pop	r28
    1244:	df 91       	pop	r29
    1246:	1f 91       	pop	r17
    1248:	0f 91       	pop	r16
    124a:	08 95       	ret

0000124c <xQueueGenericSend>:

#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    124c:	df 93       	push	r29
    124e:	cf 93       	push	r28
    1250:	cd b7       	in	r28, 0x3d	; 61
    1252:	de b7       	in	r29, 0x3e	; 62
    1254:	2f 97       	sbiw	r28, 0x0f	; 15
    1256:	0f b6       	in	r0, 0x3f	; 63
    1258:	f8 94       	cli
    125a:	de bf       	out	0x3e, r29	; 62
    125c:	0f be       	out	0x3f, r0	; 63
    125e:	cd bf       	out	0x3d, r28	; 61
    1260:	99 87       	std	Y+9, r25	; 0x09
    1262:	88 87       	std	Y+8, r24	; 0x08
    1264:	7b 87       	std	Y+11, r23	; 0x0b
    1266:	6a 87       	std	Y+10, r22	; 0x0a
    1268:	5d 87       	std	Y+13, r21	; 0x0d
    126a:	4c 87       	std	Y+12, r20	; 0x0c
    126c:	2e 87       	std	Y+14, r18	; 0x0e
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    126e:	1c 82       	std	Y+4, r1	; 0x04
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
    1270:	88 85       	ldd	r24, Y+8	; 0x08
    1272:	99 85       	ldd	r25, Y+9	; 0x09
    1274:	9a 83       	std	Y+2, r25	; 0x02
    1276:	89 83       	std	Y+1, r24	; 0x01
	/*lint -save -e904 This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    1278:	0f b6       	in	r0, 0x3f	; 63
    127a:	f8 94       	cli
    127c:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    127e:	e9 81       	ldd	r30, Y+1	; 0x01
    1280:	fa 81       	ldd	r31, Y+2	; 0x02
    1282:	92 8d       	ldd	r25, Z+26	; 0x1a
    1284:	e9 81       	ldd	r30, Y+1	; 0x01
    1286:	fa 81       	ldd	r31, Y+2	; 0x02
    1288:	83 8d       	ldd	r24, Z+27	; 0x1b
    128a:	98 17       	cp	r25, r24
    128c:	18 f0       	brcs	.+6      	; 0x1294 <xQueueGenericSend+0x48>
    128e:	8e 85       	ldd	r24, Y+14	; 0x0e
    1290:	82 30       	cpi	r24, 0x02	; 2
    1292:	11 f5       	brne	.+68     	; 0x12d8 <xQueueGenericSend+0x8c>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1294:	89 81       	ldd	r24, Y+1	; 0x01
    1296:	9a 81       	ldd	r25, Y+2	; 0x02
    1298:	2a 85       	ldd	r18, Y+10	; 0x0a
    129a:	3b 85       	ldd	r19, Y+11	; 0x0b
    129c:	b9 01       	movw	r22, r18
    129e:	4e 85       	ldd	r20, Y+14	; 0x0e
    12a0:	0e 94 78 0d 	call	0x1af0	; 0x1af0 <prvCopyDataToQueue>
    12a4:	8b 83       	std	Y+3, r24	; 0x03

					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    12a6:	e9 81       	ldd	r30, Y+1	; 0x01
    12a8:	fa 81       	ldd	r31, Y+2	; 0x02
    12aa:	81 89       	ldd	r24, Z+17	; 0x11
    12ac:	88 23       	and	r24, r24
    12ae:	51 f0       	breq	.+20     	; 0x12c4 <xQueueGenericSend+0x78>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    12b0:	89 81       	ldd	r24, Y+1	; 0x01
    12b2:	9a 81       	ldd	r25, Y+2	; 0x02
    12b4:	41 96       	adiw	r24, 0x11	; 17
    12b6:	0e 94 55 1d 	call	0x3aaa	; 0x3aaa <xTaskRemoveFromEventList>
    12ba:	88 23       	and	r24, r24
    12bc:	41 f0       	breq	.+16     	; 0x12ce <xQueueGenericSend+0x82>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
    12be:	0e 94 08 02 	call	0x410	; 0x410 <vPortYield>
    12c2:	05 c0       	rjmp	.+10     	; 0x12ce <xQueueGenericSend+0x82>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
    12c4:	8b 81       	ldd	r24, Y+3	; 0x03
    12c6:	88 23       	and	r24, r24
    12c8:	11 f0       	breq	.+4      	; 0x12ce <xQueueGenericSend+0x82>
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
    12ca:	0e 94 08 02 	call	0x410	; 0x410 <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    12ce:	0f 90       	pop	r0
    12d0:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    12d2:	81 e0       	ldi	r24, 0x01	; 1
    12d4:	8f 87       	std	Y+15, r24	; 0x0f
    12d6:	5c c0       	rjmp	.+184    	; 0x1390 <xQueueGenericSend+0x144>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    12d8:	8c 85       	ldd	r24, Y+12	; 0x0c
    12da:	9d 85       	ldd	r25, Y+13	; 0x0d
    12dc:	00 97       	sbiw	r24, 0x00	; 0
    12de:	21 f4       	brne	.+8      	; 0x12e8 <xQueueGenericSend+0x9c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    12e0:	0f 90       	pop	r0
    12e2:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    12e4:	1f 86       	std	Y+15, r1	; 0x0f
    12e6:	54 c0       	rjmp	.+168    	; 0x1390 <xQueueGenericSend+0x144>
				}
				else if( xEntryTimeSet == pdFALSE )
    12e8:	8c 81       	ldd	r24, Y+4	; 0x04
    12ea:	88 23       	and	r24, r24
    12ec:	31 f4       	brne	.+12     	; 0x12fa <xQueueGenericSend+0xae>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    12ee:	ce 01       	movw	r24, r28
    12f0:	05 96       	adiw	r24, 0x05	; 5
    12f2:	0e 94 3b 1e 	call	0x3c76	; 0x3c76 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    12f6:	81 e0       	ldi	r24, 0x01	; 1
    12f8:	8c 83       	std	Y+4, r24	; 0x04
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    12fa:	0f 90       	pop	r0
    12fc:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    12fe:	0e 94 b5 1a 	call	0x356a	; 0x356a <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1302:	0f b6       	in	r0, 0x3f	; 63
    1304:	f8 94       	cli
    1306:	0f 92       	push	r0
    1308:	e9 81       	ldd	r30, Y+1	; 0x01
    130a:	fa 81       	ldd	r31, Y+2	; 0x02
    130c:	85 8d       	ldd	r24, Z+29	; 0x1d
    130e:	8f 3f       	cpi	r24, 0xFF	; 255
    1310:	19 f4       	brne	.+6      	; 0x1318 <xQueueGenericSend+0xcc>
    1312:	e9 81       	ldd	r30, Y+1	; 0x01
    1314:	fa 81       	ldd	r31, Y+2	; 0x02
    1316:	15 8e       	std	Z+29, r1	; 0x1d
    1318:	e9 81       	ldd	r30, Y+1	; 0x01
    131a:	fa 81       	ldd	r31, Y+2	; 0x02
    131c:	86 8d       	ldd	r24, Z+30	; 0x1e
    131e:	8f 3f       	cpi	r24, 0xFF	; 255
    1320:	19 f4       	brne	.+6      	; 0x1328 <xQueueGenericSend+0xdc>
    1322:	e9 81       	ldd	r30, Y+1	; 0x01
    1324:	fa 81       	ldd	r31, Y+2	; 0x02
    1326:	16 8e       	std	Z+30, r1	; 0x1e
    1328:	0f 90       	pop	r0
    132a:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    132c:	ce 01       	movw	r24, r28
    132e:	05 96       	adiw	r24, 0x05	; 5
    1330:	9e 01       	movw	r18, r28
    1332:	24 5f       	subi	r18, 0xF4	; 244
    1334:	3f 4f       	sbci	r19, 0xFF	; 255
    1336:	b9 01       	movw	r22, r18
    1338:	0e 94 54 1e 	call	0x3ca8	; 0x3ca8 <xTaskCheckForTimeOut>
    133c:	88 23       	and	r24, r24
    133e:	09 f5       	brne	.+66     	; 0x1382 <xQueueGenericSend+0x136>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    1340:	89 81       	ldd	r24, Y+1	; 0x01
    1342:	9a 81       	ldd	r25, Y+2	; 0x02
    1344:	0e 94 f4 0e 	call	0x1de8	; 0x1de8 <prvIsQueueFull>
    1348:	88 23       	and	r24, r24
    134a:	a1 f0       	breq	.+40     	; 0x1374 <xQueueGenericSend+0x128>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    134c:	89 81       	ldd	r24, Y+1	; 0x01
    134e:	9a 81       	ldd	r25, Y+2	; 0x02
    1350:	08 96       	adiw	r24, 0x08	; 8
    1352:	2c 85       	ldd	r18, Y+12	; 0x0c
    1354:	3d 85       	ldd	r19, Y+13	; 0x0d
    1356:	b9 01       	movw	r22, r18
    1358:	0e 94 03 1d 	call	0x3a06	; 0x3a06 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible that interrupts occurring now
				remove this task from the event list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    135c:	89 81       	ldd	r24, Y+1	; 0x01
    135e:	9a 81       	ldd	r25, Y+2	; 0x02
    1360:	0e 94 65 0e 	call	0x1cca	; 0x1cca <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    1364:	0e 94 c1 1a 	call	0x3582	; 0x3582 <xTaskResumeAll>
    1368:	88 23       	and	r24, r24
    136a:	09 f0       	breq	.+2      	; 0x136e <xQueueGenericSend+0x122>
    136c:	85 cf       	rjmp	.-246    	; 0x1278 <xQueueGenericSend+0x2c>
				{
					portYIELD_WITHIN_API();
    136e:	0e 94 08 02 	call	0x410	; 0x410 <vPortYield>
    1372:	82 cf       	rjmp	.-252    	; 0x1278 <xQueueGenericSend+0x2c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1374:	89 81       	ldd	r24, Y+1	; 0x01
    1376:	9a 81       	ldd	r25, Y+2	; 0x02
    1378:	0e 94 65 0e 	call	0x1cca	; 0x1cca <prvUnlockQueue>
				( void ) xTaskResumeAll();
    137c:	0e 94 c1 1a 	call	0x3582	; 0x3582 <xTaskResumeAll>
    1380:	7b cf       	rjmp	.-266    	; 0x1278 <xQueueGenericSend+0x2c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    1382:	89 81       	ldd	r24, Y+1	; 0x01
    1384:	9a 81       	ldd	r25, Y+2	; 0x02
    1386:	0e 94 65 0e 	call	0x1cca	; 0x1cca <prvUnlockQueue>
			( void ) xTaskResumeAll();
    138a:	0e 94 c1 1a 	call	0x3582	; 0x3582 <xTaskResumeAll>

			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    138e:	1f 86       	std	Y+15, r1	; 0x0f
    1390:	8f 85       	ldd	r24, Y+15	; 0x0f
		}
	} /*lint -restore */
}
    1392:	2f 96       	adiw	r28, 0x0f	; 15
    1394:	0f b6       	in	r0, 0x3f	; 63
    1396:	f8 94       	cli
    1398:	de bf       	out	0x3e, r29	; 62
    139a:	0f be       	out	0x3f, r0	; 63
    139c:	cd bf       	out	0x3d, r28	; 61
    139e:	cf 91       	pop	r28
    13a0:	df 91       	pop	r29
    13a2:	08 95       	ret

000013a4 <xQueueGenericSendFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    13a4:	df 93       	push	r29
    13a6:	cf 93       	push	r28
    13a8:	cd b7       	in	r28, 0x3d	; 61
    13aa:	de b7       	in	r29, 0x3e	; 62
    13ac:	2c 97       	sbiw	r28, 0x0c	; 12
    13ae:	0f b6       	in	r0, 0x3f	; 63
    13b0:	f8 94       	cli
    13b2:	de bf       	out	0x3e, r29	; 62
    13b4:	0f be       	out	0x3f, r0	; 63
    13b6:	cd bf       	out	0x3d, r28	; 61
    13b8:	9f 83       	std	Y+7, r25	; 0x07
    13ba:	8e 83       	std	Y+6, r24	; 0x06
    13bc:	79 87       	std	Y+9, r23	; 0x09
    13be:	68 87       	std	Y+8, r22	; 0x08
    13c0:	5b 87       	std	Y+11, r21	; 0x0b
    13c2:	4a 87       	std	Y+10, r20	; 0x0a
    13c4:	2c 87       	std	Y+12, r18	; 0x0c
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
    13c6:	8e 81       	ldd	r24, Y+6	; 0x06
    13c8:	9f 81       	ldd	r25, Y+7	; 0x07
    13ca:	9b 83       	std	Y+3, r25	; 0x03
    13cc:	8a 83       	std	Y+2, r24	; 0x02
	/* Similar to xQueueGenericSend, except without blocking if there is no room
	in the queue.  Also don't directly wake a task that was blocked on a queue
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    13ce:	1c 82       	std	Y+4, r1	; 0x04
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    13d0:	ea 81       	ldd	r30, Y+2	; 0x02
    13d2:	fb 81       	ldd	r31, Y+3	; 0x03
    13d4:	92 8d       	ldd	r25, Z+26	; 0x1a
    13d6:	ea 81       	ldd	r30, Y+2	; 0x02
    13d8:	fb 81       	ldd	r31, Y+3	; 0x03
    13da:	83 8d       	ldd	r24, Z+27	; 0x1b
    13dc:	98 17       	cp	r25, r24
    13de:	18 f0       	brcs	.+6      	; 0x13e6 <xQueueGenericSendFromISR+0x42>
    13e0:	8c 85       	ldd	r24, Y+12	; 0x0c
    13e2:	82 30       	cpi	r24, 0x02	; 2
    13e4:	61 f5       	brne	.+88     	; 0x143e <xQueueGenericSendFromISR+0x9a>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    13e6:	ea 81       	ldd	r30, Y+2	; 0x02
    13e8:	fb 81       	ldd	r31, Y+3	; 0x03
    13ea:	86 8d       	ldd	r24, Z+30	; 0x1e
    13ec:	89 83       	std	Y+1, r24	; 0x01
			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
			in a task disinheriting a priority and prvCopyDataToQueue() can be
			called here even though the disinherit function does not check if
			the scheduler is suspended before accessing the ready lists. */
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    13ee:	8a 81       	ldd	r24, Y+2	; 0x02
    13f0:	9b 81       	ldd	r25, Y+3	; 0x03
    13f2:	28 85       	ldd	r18, Y+8	; 0x08
    13f4:	39 85       	ldd	r19, Y+9	; 0x09
    13f6:	b9 01       	movw	r22, r18
    13f8:	4c 85       	ldd	r20, Y+12	; 0x0c
    13fa:	0e 94 78 0d 	call	0x1af0	; 0x1af0 <prvCopyDataToQueue>

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    13fe:	89 81       	ldd	r24, Y+1	; 0x01
    1400:	8f 3f       	cpi	r24, 0xFF	; 255
    1402:	a9 f4       	brne	.+42     	; 0x142e <xQueueGenericSendFromISR+0x8a>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1404:	ea 81       	ldd	r30, Y+2	; 0x02
    1406:	fb 81       	ldd	r31, Y+3	; 0x03
    1408:	81 89       	ldd	r24, Z+17	; 0x11
    140a:	88 23       	and	r24, r24
    140c:	a9 f0       	breq	.+42     	; 0x1438 <xQueueGenericSendFromISR+0x94>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    140e:	8a 81       	ldd	r24, Y+2	; 0x02
    1410:	9b 81       	ldd	r25, Y+3	; 0x03
    1412:	41 96       	adiw	r24, 0x11	; 17
    1414:	0e 94 55 1d 	call	0x3aaa	; 0x3aaa <xTaskRemoveFromEventList>
    1418:	88 23       	and	r24, r24
    141a:	71 f0       	breq	.+28     	; 0x1438 <xQueueGenericSendFromISR+0x94>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    141c:	8a 85       	ldd	r24, Y+10	; 0x0a
    141e:	9b 85       	ldd	r25, Y+11	; 0x0b
    1420:	00 97       	sbiw	r24, 0x00	; 0
    1422:	51 f0       	breq	.+20     	; 0x1438 <xQueueGenericSendFromISR+0x94>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    1424:	ea 85       	ldd	r30, Y+10	; 0x0a
    1426:	fb 85       	ldd	r31, Y+11	; 0x0b
    1428:	81 e0       	ldi	r24, 0x01	; 1
    142a:	80 83       	st	Z, r24
    142c:	05 c0       	rjmp	.+10     	; 0x1438 <xQueueGenericSendFromISR+0x94>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    142e:	89 81       	ldd	r24, Y+1	; 0x01
    1430:	8f 5f       	subi	r24, 0xFF	; 255
    1432:	ea 81       	ldd	r30, Y+2	; 0x02
    1434:	fb 81       	ldd	r31, Y+3	; 0x03
    1436:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    1438:	81 e0       	ldi	r24, 0x01	; 1
    143a:	8d 83       	std	Y+5, r24	; 0x05
    143c:	01 c0       	rjmp	.+2      	; 0x1440 <xQueueGenericSendFromISR+0x9c>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    143e:	1d 82       	std	Y+5, r1	; 0x05
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    1440:	8d 81       	ldd	r24, Y+5	; 0x05
}
    1442:	2c 96       	adiw	r28, 0x0c	; 12
    1444:	0f b6       	in	r0, 0x3f	; 63
    1446:	f8 94       	cli
    1448:	de bf       	out	0x3e, r29	; 62
    144a:	0f be       	out	0x3f, r0	; 63
    144c:	cd bf       	out	0x3d, r28	; 61
    144e:	cf 91       	pop	r28
    1450:	df 91       	pop	r29
    1452:	08 95       	ret

00001454 <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
{
    1454:	df 93       	push	r29
    1456:	cf 93       	push	r28
    1458:	cd b7       	in	r28, 0x3d	; 61
    145a:	de b7       	in	r29, 0x3e	; 62
    145c:	2a 97       	sbiw	r28, 0x0a	; 10
    145e:	0f b6       	in	r0, 0x3f	; 63
    1460:	f8 94       	cli
    1462:	de bf       	out	0x3e, r29	; 62
    1464:	0f be       	out	0x3f, r0	; 63
    1466:	cd bf       	out	0x3d, r28	; 61
    1468:	98 87       	std	Y+8, r25	; 0x08
    146a:	8f 83       	std	Y+7, r24	; 0x07
    146c:	7a 87       	std	Y+10, r23	; 0x0a
    146e:	69 87       	std	Y+9, r22	; 0x09
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
    1470:	8f 81       	ldd	r24, Y+7	; 0x07
    1472:	98 85       	ldd	r25, Y+8	; 0x08
    1474:	9c 83       	std	Y+4, r25	; 0x04
    1476:	8b 83       	std	Y+3, r24	; 0x03
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    1478:	1d 82       	std	Y+5, r1	; 0x05
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    147a:	eb 81       	ldd	r30, Y+3	; 0x03
    147c:	fc 81       	ldd	r31, Y+4	; 0x04
    147e:	82 8d       	ldd	r24, Z+26	; 0x1a
    1480:	8a 83       	std	Y+2, r24	; 0x02

		/* When the queue is used to implement a semaphore no data is ever
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( uxMessagesWaiting < pxQueue->uxLength )
    1482:	eb 81       	ldd	r30, Y+3	; 0x03
    1484:	fc 81       	ldd	r31, Y+4	; 0x04
    1486:	93 8d       	ldd	r25, Z+27	; 0x1b
    1488:	8a 81       	ldd	r24, Y+2	; 0x02
    148a:	89 17       	cp	r24, r25
    148c:	48 f5       	brcc	.+82     	; 0x14e0 <xQueueGiveFromISR+0x8c>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    148e:	eb 81       	ldd	r30, Y+3	; 0x03
    1490:	fc 81       	ldd	r31, Y+4	; 0x04
    1492:	86 8d       	ldd	r24, Z+30	; 0x1e
    1494:	89 83       	std	Y+1, r24	; 0x01
			holder - and if there is a mutex holder then the mutex cannot be
			given from an ISR.  As this is the ISR version of the function it
			can be assumed there is no mutex holder and no need to determine if
			priority disinheritance is needed.  Simply increase the count of
			messages (semaphores) available. */
			pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    1496:	8a 81       	ldd	r24, Y+2	; 0x02
    1498:	8f 5f       	subi	r24, 0xFF	; 255
    149a:	eb 81       	ldd	r30, Y+3	; 0x03
    149c:	fc 81       	ldd	r31, Y+4	; 0x04
    149e:	82 8f       	std	Z+26, r24	; 0x1a

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    14a0:	89 81       	ldd	r24, Y+1	; 0x01
    14a2:	8f 3f       	cpi	r24, 0xFF	; 255
    14a4:	a9 f4       	brne	.+42     	; 0x14d0 <xQueueGiveFromISR+0x7c>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    14a6:	eb 81       	ldd	r30, Y+3	; 0x03
    14a8:	fc 81       	ldd	r31, Y+4	; 0x04
    14aa:	81 89       	ldd	r24, Z+17	; 0x11
    14ac:	88 23       	and	r24, r24
    14ae:	a9 f0       	breq	.+42     	; 0x14da <xQueueGiveFromISR+0x86>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    14b0:	8b 81       	ldd	r24, Y+3	; 0x03
    14b2:	9c 81       	ldd	r25, Y+4	; 0x04
    14b4:	41 96       	adiw	r24, 0x11	; 17
    14b6:	0e 94 55 1d 	call	0x3aaa	; 0x3aaa <xTaskRemoveFromEventList>
    14ba:	88 23       	and	r24, r24
    14bc:	71 f0       	breq	.+28     	; 0x14da <xQueueGiveFromISR+0x86>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    14be:	89 85       	ldd	r24, Y+9	; 0x09
    14c0:	9a 85       	ldd	r25, Y+10	; 0x0a
    14c2:	00 97       	sbiw	r24, 0x00	; 0
    14c4:	51 f0       	breq	.+20     	; 0x14da <xQueueGiveFromISR+0x86>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    14c6:	e9 85       	ldd	r30, Y+9	; 0x09
    14c8:	fa 85       	ldd	r31, Y+10	; 0x0a
    14ca:	81 e0       	ldi	r24, 0x01	; 1
    14cc:	80 83       	st	Z, r24
    14ce:	05 c0       	rjmp	.+10     	; 0x14da <xQueueGiveFromISR+0x86>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    14d0:	89 81       	ldd	r24, Y+1	; 0x01
    14d2:	8f 5f       	subi	r24, 0xFF	; 255
    14d4:	eb 81       	ldd	r30, Y+3	; 0x03
    14d6:	fc 81       	ldd	r31, Y+4	; 0x04
    14d8:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    14da:	81 e0       	ldi	r24, 0x01	; 1
    14dc:	8e 83       	std	Y+6, r24	; 0x06
    14de:	01 c0       	rjmp	.+2      	; 0x14e2 <xQueueGiveFromISR+0x8e>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    14e0:	1e 82       	std	Y+6, r1	; 0x06
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    14e2:	8e 81       	ldd	r24, Y+6	; 0x06
}
    14e4:	2a 96       	adiw	r28, 0x0a	; 10
    14e6:	0f b6       	in	r0, 0x3f	; 63
    14e8:	f8 94       	cli
    14ea:	de bf       	out	0x3e, r29	; 62
    14ec:	0f be       	out	0x3f, r0	; 63
    14ee:	cd bf       	out	0x3d, r28	; 61
    14f0:	cf 91       	pop	r28
    14f2:	df 91       	pop	r29
    14f4:	08 95       	ret

000014f6 <xQueueReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
    14f6:	df 93       	push	r29
    14f8:	cf 93       	push	r28
    14fa:	cd b7       	in	r28, 0x3d	; 61
    14fc:	de b7       	in	r29, 0x3e	; 62
    14fe:	2e 97       	sbiw	r28, 0x0e	; 14
    1500:	0f b6       	in	r0, 0x3f	; 63
    1502:	f8 94       	cli
    1504:	de bf       	out	0x3e, r29	; 62
    1506:	0f be       	out	0x3f, r0	; 63
    1508:	cd bf       	out	0x3d, r28	; 61
    150a:	99 87       	std	Y+9, r25	; 0x09
    150c:	88 87       	std	Y+8, r24	; 0x08
    150e:	7b 87       	std	Y+11, r23	; 0x0b
    1510:	6a 87       	std	Y+10, r22	; 0x0a
    1512:	5d 87       	std	Y+13, r21	; 0x0d
    1514:	4c 87       	std	Y+12, r20	; 0x0c
BaseType_t xEntryTimeSet = pdFALSE;
    1516:	1c 82       	std	Y+4, r1	; 0x04
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
    1518:	88 85       	ldd	r24, Y+8	; 0x08
    151a:	99 85       	ldd	r25, Y+9	; 0x09
    151c:	9b 83       	std	Y+3, r25	; 0x03
    151e:	8a 83       	std	Y+2, r24	; 0x02
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    1520:	0f b6       	in	r0, 0x3f	; 63
    1522:	f8 94       	cli
    1524:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1526:	ea 81       	ldd	r30, Y+2	; 0x02
    1528:	fb 81       	ldd	r31, Y+3	; 0x03
    152a:	82 8d       	ldd	r24, Z+26	; 0x1a
    152c:	89 83       	std	Y+1, r24	; 0x01

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    152e:	89 81       	ldd	r24, Y+1	; 0x01
    1530:	88 23       	and	r24, r24
    1532:	f9 f0       	breq	.+62     	; 0x1572 <xQueueReceive+0x7c>
			{
				/* Data available, remove one item. */
				prvCopyDataFromQueue( pxQueue, pvBuffer );
    1534:	8a 81       	ldd	r24, Y+2	; 0x02
    1536:	9b 81       	ldd	r25, Y+3	; 0x03
    1538:	2a 85       	ldd	r18, Y+10	; 0x0a
    153a:	3b 85       	ldd	r19, Y+11	; 0x0b
    153c:	b9 01       	movw	r22, r18
    153e:	0e 94 1e 0e 	call	0x1c3c	; 0x1c3c <prvCopyDataFromQueue>
				traceQUEUE_RECEIVE( pxQueue );
				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    1542:	89 81       	ldd	r24, Y+1	; 0x01
    1544:	81 50       	subi	r24, 0x01	; 1
    1546:	ea 81       	ldd	r30, Y+2	; 0x02
    1548:	fb 81       	ldd	r31, Y+3	; 0x03
    154a:	82 8f       	std	Z+26, r24	; 0x1a

				/* There is now space in the queue, were any tasks waiting to
				post to the queue?  If so, unblock the highest priority waiting
				task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    154c:	ea 81       	ldd	r30, Y+2	; 0x02
    154e:	fb 81       	ldd	r31, Y+3	; 0x03
    1550:	80 85       	ldd	r24, Z+8	; 0x08
    1552:	88 23       	and	r24, r24
    1554:	49 f0       	breq	.+18     	; 0x1568 <xQueueReceive+0x72>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1556:	8a 81       	ldd	r24, Y+2	; 0x02
    1558:	9b 81       	ldd	r25, Y+3	; 0x03
    155a:	08 96       	adiw	r24, 0x08	; 8
    155c:	0e 94 55 1d 	call	0x3aaa	; 0x3aaa <xTaskRemoveFromEventList>
    1560:	88 23       	and	r24, r24
    1562:	11 f0       	breq	.+4      	; 0x1568 <xQueueReceive+0x72>
					{
						queueYIELD_IF_USING_PREEMPTION();
    1564:	0e 94 08 02 	call	0x410	; 0x410 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    1568:	0f 90       	pop	r0
    156a:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    156c:	81 e0       	ldi	r24, 0x01	; 1
    156e:	8e 87       	std	Y+14, r24	; 0x0e
    1570:	63 c0       	rjmp	.+198    	; 0x1638 <xQueueReceive+0x142>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1572:	8c 85       	ldd	r24, Y+12	; 0x0c
    1574:	9d 85       	ldd	r25, Y+13	; 0x0d
    1576:	00 97       	sbiw	r24, 0x00	; 0
    1578:	21 f4       	brne	.+8      	; 0x1582 <xQueueReceive+0x8c>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    157a:	0f 90       	pop	r0
    157c:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    157e:	1e 86       	std	Y+14, r1	; 0x0e
    1580:	5b c0       	rjmp	.+182    	; 0x1638 <xQueueReceive+0x142>
				}
				else if( xEntryTimeSet == pdFALSE )
    1582:	8c 81       	ldd	r24, Y+4	; 0x04
    1584:	88 23       	and	r24, r24
    1586:	31 f4       	brne	.+12     	; 0x1594 <xQueueReceive+0x9e>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    1588:	ce 01       	movw	r24, r28
    158a:	05 96       	adiw	r24, 0x05	; 5
    158c:	0e 94 3b 1e 	call	0x3c76	; 0x3c76 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1590:	81 e0       	ldi	r24, 0x01	; 1
    1592:	8c 83       	std	Y+4, r24	; 0x04
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1594:	0f 90       	pop	r0
    1596:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1598:	0e 94 b5 1a 	call	0x356a	; 0x356a <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    159c:	0f b6       	in	r0, 0x3f	; 63
    159e:	f8 94       	cli
    15a0:	0f 92       	push	r0
    15a2:	ea 81       	ldd	r30, Y+2	; 0x02
    15a4:	fb 81       	ldd	r31, Y+3	; 0x03
    15a6:	85 8d       	ldd	r24, Z+29	; 0x1d
    15a8:	8f 3f       	cpi	r24, 0xFF	; 255
    15aa:	19 f4       	brne	.+6      	; 0x15b2 <xQueueReceive+0xbc>
    15ac:	ea 81       	ldd	r30, Y+2	; 0x02
    15ae:	fb 81       	ldd	r31, Y+3	; 0x03
    15b0:	15 8e       	std	Z+29, r1	; 0x1d
    15b2:	ea 81       	ldd	r30, Y+2	; 0x02
    15b4:	fb 81       	ldd	r31, Y+3	; 0x03
    15b6:	86 8d       	ldd	r24, Z+30	; 0x1e
    15b8:	8f 3f       	cpi	r24, 0xFF	; 255
    15ba:	19 f4       	brne	.+6      	; 0x15c2 <xQueueReceive+0xcc>
    15bc:	ea 81       	ldd	r30, Y+2	; 0x02
    15be:	fb 81       	ldd	r31, Y+3	; 0x03
    15c0:	16 8e       	std	Z+30, r1	; 0x1e
    15c2:	0f 90       	pop	r0
    15c4:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    15c6:	ce 01       	movw	r24, r28
    15c8:	05 96       	adiw	r24, 0x05	; 5
    15ca:	9e 01       	movw	r18, r28
    15cc:	24 5f       	subi	r18, 0xF4	; 244
    15ce:	3f 4f       	sbci	r19, 0xFF	; 255
    15d0:	b9 01       	movw	r22, r18
    15d2:	0e 94 54 1e 	call	0x3ca8	; 0x3ca8 <xTaskCheckForTimeOut>
    15d6:	88 23       	and	r24, r24
    15d8:	09 f5       	brne	.+66     	; 0x161c <xQueueReceive+0x126>
		{
			/* The timeout has not expired.  If the queue is still empty place
			the task on the list of tasks waiting to receive from the queue. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    15da:	8a 81       	ldd	r24, Y+2	; 0x02
    15dc:	9b 81       	ldd	r25, Y+3	; 0x03
    15de:	0e 94 b8 0e 	call	0x1d70	; 0x1d70 <prvIsQueueEmpty>
    15e2:	88 23       	and	r24, r24
    15e4:	a1 f0       	breq	.+40     	; 0x160e <xQueueReceive+0x118>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    15e6:	8a 81       	ldd	r24, Y+2	; 0x02
    15e8:	9b 81       	ldd	r25, Y+3	; 0x03
    15ea:	41 96       	adiw	r24, 0x11	; 17
    15ec:	2c 85       	ldd	r18, Y+12	; 0x0c
    15ee:	3d 85       	ldd	r19, Y+13	; 0x0d
    15f0:	b9 01       	movw	r22, r18
    15f2:	0e 94 03 1d 	call	0x3a06	; 0x3a06 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    15f6:	8a 81       	ldd	r24, Y+2	; 0x02
    15f8:	9b 81       	ldd	r25, Y+3	; 0x03
    15fa:	0e 94 65 0e 	call	0x1cca	; 0x1cca <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    15fe:	0e 94 c1 1a 	call	0x3582	; 0x3582 <xTaskResumeAll>
    1602:	88 23       	and	r24, r24
    1604:	09 f0       	breq	.+2      	; 0x1608 <xQueueReceive+0x112>
    1606:	8c cf       	rjmp	.-232    	; 0x1520 <xQueueReceive+0x2a>
				{
					portYIELD_WITHIN_API();
    1608:	0e 94 08 02 	call	0x410	; 0x410 <vPortYield>
    160c:	89 cf       	rjmp	.-238    	; 0x1520 <xQueueReceive+0x2a>
			}
			else
			{
				/* The queue contains data again.  Loop back to try and read the
				data. */
				prvUnlockQueue( pxQueue );
    160e:	8a 81       	ldd	r24, Y+2	; 0x02
    1610:	9b 81       	ldd	r25, Y+3	; 0x03
    1612:	0e 94 65 0e 	call	0x1cca	; 0x1cca <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1616:	0e 94 c1 1a 	call	0x3582	; 0x3582 <xTaskResumeAll>
    161a:	82 cf       	rjmp	.-252    	; 0x1520 <xQueueReceive+0x2a>
		}
		else
		{
			/* Timed out.  If there is no data in the queue exit, otherwise loop
			back and attempt to read the data. */
			prvUnlockQueue( pxQueue );
    161c:	8a 81       	ldd	r24, Y+2	; 0x02
    161e:	9b 81       	ldd	r25, Y+3	; 0x03
    1620:	0e 94 65 0e 	call	0x1cca	; 0x1cca <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1624:	0e 94 c1 1a 	call	0x3582	; 0x3582 <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1628:	8a 81       	ldd	r24, Y+2	; 0x02
    162a:	9b 81       	ldd	r25, Y+3	; 0x03
    162c:	0e 94 b8 0e 	call	0x1d70	; 0x1d70 <prvIsQueueEmpty>
    1630:	88 23       	and	r24, r24
    1632:	09 f4       	brne	.+2      	; 0x1636 <xQueueReceive+0x140>
    1634:	75 cf       	rjmp	.-278    	; 0x1520 <xQueueReceive+0x2a>
			{
				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    1636:	1e 86       	std	Y+14, r1	; 0x0e
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
    1638:	8e 85       	ldd	r24, Y+14	; 0x0e
}
    163a:	2e 96       	adiw	r28, 0x0e	; 14
    163c:	0f b6       	in	r0, 0x3f	; 63
    163e:	f8 94       	cli
    1640:	de bf       	out	0x3e, r29	; 62
    1642:	0f be       	out	0x3f, r0	; 63
    1644:	cd bf       	out	0x3d, r28	; 61
    1646:	cf 91       	pop	r28
    1648:	df 91       	pop	r29
    164a:	08 95       	ret

0000164c <xQueueSemaphoreTake>:
/*-----------------------------------------------------------*/

BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue, TickType_t xTicksToWait )
{
    164c:	df 93       	push	r29
    164e:	cf 93       	push	r28
    1650:	cd b7       	in	r28, 0x3d	; 61
    1652:	de b7       	in	r29, 0x3e	; 62
    1654:	2c 97       	sbiw	r28, 0x0c	; 12
    1656:	0f b6       	in	r0, 0x3f	; 63
    1658:	f8 94       	cli
    165a:	de bf       	out	0x3e, r29	; 62
    165c:	0f be       	out	0x3f, r0	; 63
    165e:	cd bf       	out	0x3d, r28	; 61
    1660:	99 87       	std	Y+9, r25	; 0x09
    1662:	88 87       	std	Y+8, r24	; 0x08
    1664:	7b 87       	std	Y+11, r23	; 0x0b
    1666:	6a 87       	std	Y+10, r22	; 0x0a
BaseType_t xEntryTimeSet = pdFALSE;
    1668:	1c 82       	std	Y+4, r1	; 0x04
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
    166a:	88 85       	ldd	r24, Y+8	; 0x08
    166c:	99 85       	ldd	r25, Y+9	; 0x09
    166e:	9b 83       	std	Y+3, r25	; 0x03
    1670:	8a 83       	std	Y+2, r24	; 0x02
	/*lint -save -e904 This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    1672:	0f b6       	in	r0, 0x3f	; 63
    1674:	f8 94       	cli
    1676:	0f 92       	push	r0
		{
			/* Semaphores are queues with an item size of 0, and where the
			number of messages in the queue is the semaphore's count value. */
			const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
    1678:	ea 81       	ldd	r30, Y+2	; 0x02
    167a:	fb 81       	ldd	r31, Y+3	; 0x03
    167c:	82 8d       	ldd	r24, Z+26	; 0x1a
    167e:	89 83       	std	Y+1, r24	; 0x01

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxSemaphoreCount > ( UBaseType_t ) 0 )
    1680:	89 81       	ldd	r24, Y+1	; 0x01
    1682:	88 23       	and	r24, r24
    1684:	c1 f0       	breq	.+48     	; 0x16b6 <xQueueSemaphoreTake+0x6a>
			{
				traceQUEUE_RECEIVE( pxQueue );

				/* Semaphores are queues with a data size of zero and where the
				messages waiting is the semaphore's count.  Reduce the count. */
				pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
    1686:	89 81       	ldd	r24, Y+1	; 0x01
    1688:	81 50       	subi	r24, 0x01	; 1
    168a:	ea 81       	ldd	r30, Y+2	; 0x02
    168c:	fb 81       	ldd	r31, Y+3	; 0x03
    168e:	82 8f       	std	Z+26, r24	; 0x1a
				}
				#endif /* configUSE_MUTEXES */

				/* Check to see if other tasks are blocked waiting to give the
				semaphore, and if so, unblock the highest priority such task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1690:	ea 81       	ldd	r30, Y+2	; 0x02
    1692:	fb 81       	ldd	r31, Y+3	; 0x03
    1694:	80 85       	ldd	r24, Z+8	; 0x08
    1696:	88 23       	and	r24, r24
    1698:	49 f0       	breq	.+18     	; 0x16ac <xQueueSemaphoreTake+0x60>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    169a:	8a 81       	ldd	r24, Y+2	; 0x02
    169c:	9b 81       	ldd	r25, Y+3	; 0x03
    169e:	08 96       	adiw	r24, 0x08	; 8
    16a0:	0e 94 55 1d 	call	0x3aaa	; 0x3aaa <xTaskRemoveFromEventList>
    16a4:	88 23       	and	r24, r24
    16a6:	11 f0       	breq	.+4      	; 0x16ac <xQueueSemaphoreTake+0x60>
					{
						queueYIELD_IF_USING_PREEMPTION();
    16a8:	0e 94 08 02 	call	0x410	; 0x410 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    16ac:	0f 90       	pop	r0
    16ae:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    16b0:	81 e0       	ldi	r24, 0x01	; 1
    16b2:	8c 87       	std	Y+12, r24	; 0x0c
    16b4:	63 c0       	rjmp	.+198    	; 0x177c <xQueueSemaphoreTake+0x130>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    16b6:	8a 85       	ldd	r24, Y+10	; 0x0a
    16b8:	9b 85       	ldd	r25, Y+11	; 0x0b
    16ba:	00 97       	sbiw	r24, 0x00	; 0
    16bc:	21 f4       	brne	.+8      	; 0x16c6 <xQueueSemaphoreTake+0x7a>
					}
					#endif /* configUSE_MUTEXES */

					/* The semaphore count was 0 and no block time is specified
					(or the block time has expired) so exit now. */
					taskEXIT_CRITICAL();
    16be:	0f 90       	pop	r0
    16c0:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    16c2:	1c 86       	std	Y+12, r1	; 0x0c
    16c4:	5b c0       	rjmp	.+182    	; 0x177c <xQueueSemaphoreTake+0x130>
				}
				else if( xEntryTimeSet == pdFALSE )
    16c6:	8c 81       	ldd	r24, Y+4	; 0x04
    16c8:	88 23       	and	r24, r24
    16ca:	31 f4       	brne	.+12     	; 0x16d8 <xQueueSemaphoreTake+0x8c>
				{
					/* The semaphore count was 0 and a block time was specified
					so configure the timeout structure ready to block. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    16cc:	ce 01       	movw	r24, r28
    16ce:	05 96       	adiw	r24, 0x05	; 5
    16d0:	0e 94 3b 1e 	call	0x3c76	; 0x3c76 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    16d4:	81 e0       	ldi	r24, 0x01	; 1
    16d6:	8c 83       	std	Y+4, r24	; 0x04
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    16d8:	0f 90       	pop	r0
    16da:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can give to and take from the semaphore
		now the critical section has been exited. */

		vTaskSuspendAll();
    16dc:	0e 94 b5 1a 	call	0x356a	; 0x356a <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    16e0:	0f b6       	in	r0, 0x3f	; 63
    16e2:	f8 94       	cli
    16e4:	0f 92       	push	r0
    16e6:	ea 81       	ldd	r30, Y+2	; 0x02
    16e8:	fb 81       	ldd	r31, Y+3	; 0x03
    16ea:	85 8d       	ldd	r24, Z+29	; 0x1d
    16ec:	8f 3f       	cpi	r24, 0xFF	; 255
    16ee:	19 f4       	brne	.+6      	; 0x16f6 <xQueueSemaphoreTake+0xaa>
    16f0:	ea 81       	ldd	r30, Y+2	; 0x02
    16f2:	fb 81       	ldd	r31, Y+3	; 0x03
    16f4:	15 8e       	std	Z+29, r1	; 0x1d
    16f6:	ea 81       	ldd	r30, Y+2	; 0x02
    16f8:	fb 81       	ldd	r31, Y+3	; 0x03
    16fa:	86 8d       	ldd	r24, Z+30	; 0x1e
    16fc:	8f 3f       	cpi	r24, 0xFF	; 255
    16fe:	19 f4       	brne	.+6      	; 0x1706 <xQueueSemaphoreTake+0xba>
    1700:	ea 81       	ldd	r30, Y+2	; 0x02
    1702:	fb 81       	ldd	r31, Y+3	; 0x03
    1704:	16 8e       	std	Z+30, r1	; 0x1e
    1706:	0f 90       	pop	r0
    1708:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    170a:	ce 01       	movw	r24, r28
    170c:	05 96       	adiw	r24, 0x05	; 5
    170e:	9e 01       	movw	r18, r28
    1710:	26 5f       	subi	r18, 0xF6	; 246
    1712:	3f 4f       	sbci	r19, 0xFF	; 255
    1714:	b9 01       	movw	r22, r18
    1716:	0e 94 54 1e 	call	0x3ca8	; 0x3ca8 <xTaskCheckForTimeOut>
    171a:	88 23       	and	r24, r24
    171c:	09 f5       	brne	.+66     	; 0x1760 <xQueueSemaphoreTake+0x114>
		{
			/* A block time is specified and not expired.  If the semaphore
			count is 0 then enter the Blocked state to wait for a semaphore to
			become available.  As semaphores are implemented with queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    171e:	8a 81       	ldd	r24, Y+2	; 0x02
    1720:	9b 81       	ldd	r25, Y+3	; 0x03
    1722:	0e 94 b8 0e 	call	0x1d70	; 0x1d70 <prvIsQueueEmpty>
    1726:	88 23       	and	r24, r24
    1728:	a1 f0       	breq	.+40     	; 0x1752 <xQueueSemaphoreTake+0x106>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    172a:	8a 81       	ldd	r24, Y+2	; 0x02
    172c:	9b 81       	ldd	r25, Y+3	; 0x03
    172e:	41 96       	adiw	r24, 0x11	; 17
    1730:	2a 85       	ldd	r18, Y+10	; 0x0a
    1732:	3b 85       	ldd	r19, Y+11	; 0x0b
    1734:	b9 01       	movw	r22, r18
    1736:	0e 94 03 1d 	call	0x3a06	; 0x3a06 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    173a:	8a 81       	ldd	r24, Y+2	; 0x02
    173c:	9b 81       	ldd	r25, Y+3	; 0x03
    173e:	0e 94 65 0e 	call	0x1cca	; 0x1cca <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    1742:	0e 94 c1 1a 	call	0x3582	; 0x3582 <xTaskResumeAll>
    1746:	88 23       	and	r24, r24
    1748:	09 f0       	breq	.+2      	; 0x174c <xQueueSemaphoreTake+0x100>
    174a:	93 cf       	rjmp	.-218    	; 0x1672 <xQueueSemaphoreTake+0x26>
				{
					portYIELD_WITHIN_API();
    174c:	0e 94 08 02 	call	0x410	; 0x410 <vPortYield>
    1750:	90 cf       	rjmp	.-224    	; 0x1672 <xQueueSemaphoreTake+0x26>
			}
			else
			{
				/* There was no timeout and the semaphore count was not 0, so
				attempt to take the semaphore again. */
				prvUnlockQueue( pxQueue );
    1752:	8a 81       	ldd	r24, Y+2	; 0x02
    1754:	9b 81       	ldd	r25, Y+3	; 0x03
    1756:	0e 94 65 0e 	call	0x1cca	; 0x1cca <prvUnlockQueue>
				( void ) xTaskResumeAll();
    175a:	0e 94 c1 1a 	call	0x3582	; 0x3582 <xTaskResumeAll>
    175e:	89 cf       	rjmp	.-238    	; 0x1672 <xQueueSemaphoreTake+0x26>
			}
		}
		else
		{
			/* Timed out. */
			prvUnlockQueue( pxQueue );
    1760:	8a 81       	ldd	r24, Y+2	; 0x02
    1762:	9b 81       	ldd	r25, Y+3	; 0x03
    1764:	0e 94 65 0e 	call	0x1cca	; 0x1cca <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1768:	0e 94 c1 1a 	call	0x3582	; 0x3582 <xTaskResumeAll>

			/* If the semaphore count is 0 exit now as the timeout has
			expired.  Otherwise return to attempt to take the semaphore that is
			known to be available.  As semaphores are implemented by queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    176c:	8a 81       	ldd	r24, Y+2	; 0x02
    176e:	9b 81       	ldd	r25, Y+3	; 0x03
    1770:	0e 94 b8 0e 	call	0x1d70	; 0x1d70 <prvIsQueueEmpty>
    1774:	88 23       	and	r24, r24
    1776:	09 f4       	brne	.+2      	; 0x177a <xQueueSemaphoreTake+0x12e>
    1778:	7c cf       	rjmp	.-264    	; 0x1672 <xQueueSemaphoreTake+0x26>
					}
				}
				#endif /* configUSE_MUTEXES */

				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    177a:	1c 86       	std	Y+12, r1	; 0x0c
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
    177c:	8c 85       	ldd	r24, Y+12	; 0x0c
}
    177e:	2c 96       	adiw	r28, 0x0c	; 12
    1780:	0f b6       	in	r0, 0x3f	; 63
    1782:	f8 94       	cli
    1784:	de bf       	out	0x3e, r29	; 62
    1786:	0f be       	out	0x3f, r0	; 63
    1788:	cd bf       	out	0x3d, r28	; 61
    178a:	cf 91       	pop	r28
    178c:	df 91       	pop	r29
    178e:	08 95       	ret

00001790 <xQueuePeek>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeek( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
    1790:	df 93       	push	r29
    1792:	cf 93       	push	r28
    1794:	cd b7       	in	r28, 0x3d	; 61
    1796:	de b7       	in	r29, 0x3e	; 62
    1798:	60 97       	sbiw	r28, 0x10	; 16
    179a:	0f b6       	in	r0, 0x3f	; 63
    179c:	f8 94       	cli
    179e:	de bf       	out	0x3e, r29	; 62
    17a0:	0f be       	out	0x3f, r0	; 63
    17a2:	cd bf       	out	0x3d, r28	; 61
    17a4:	9b 87       	std	Y+11, r25	; 0x0b
    17a6:	8a 87       	std	Y+10, r24	; 0x0a
    17a8:	7d 87       	std	Y+13, r23	; 0x0d
    17aa:	6c 87       	std	Y+12, r22	; 0x0c
    17ac:	5f 87       	std	Y+15, r21	; 0x0f
    17ae:	4e 87       	std	Y+14, r20	; 0x0e
BaseType_t xEntryTimeSet = pdFALSE;
    17b0:	1e 82       	std	Y+6, r1	; 0x06
TimeOut_t xTimeOut;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = xQueue;
    17b2:	8a 85       	ldd	r24, Y+10	; 0x0a
    17b4:	9b 85       	ldd	r25, Y+11	; 0x0b
    17b6:	9b 83       	std	Y+3, r25	; 0x03
    17b8:	8a 83       	std	Y+2, r24	; 0x02
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    17ba:	0f b6       	in	r0, 0x3f	; 63
    17bc:	f8 94       	cli
    17be:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    17c0:	ea 81       	ldd	r30, Y+2	; 0x02
    17c2:	fb 81       	ldd	r31, Y+3	; 0x03
    17c4:	82 8d       	ldd	r24, Z+26	; 0x1a
    17c6:	89 83       	std	Y+1, r24	; 0x01

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    17c8:	89 81       	ldd	r24, Y+1	; 0x01
    17ca:	88 23       	and	r24, r24
    17cc:	31 f1       	breq	.+76     	; 0x181a <xQueuePeek+0x8a>
			{
				/* Remember the read position so it can be reset after the data
				is read from the queue as this function is only peeking the
				data, not removing it. */
				pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    17ce:	ea 81       	ldd	r30, Y+2	; 0x02
    17d0:	fb 81       	ldd	r31, Y+3	; 0x03
    17d2:	86 81       	ldd	r24, Z+6	; 0x06
    17d4:	97 81       	ldd	r25, Z+7	; 0x07
    17d6:	9d 83       	std	Y+5, r25	; 0x05
    17d8:	8c 83       	std	Y+4, r24	; 0x04

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    17da:	8a 81       	ldd	r24, Y+2	; 0x02
    17dc:	9b 81       	ldd	r25, Y+3	; 0x03
    17de:	2c 85       	ldd	r18, Y+12	; 0x0c
    17e0:	3d 85       	ldd	r19, Y+13	; 0x0d
    17e2:	b9 01       	movw	r22, r18
    17e4:	0e 94 1e 0e 	call	0x1c3c	; 0x1c3c <prvCopyDataFromQueue>
				traceQUEUE_PEEK( pxQueue );

				/* The data is not being removed, so reset the read pointer. */
				pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    17e8:	ea 81       	ldd	r30, Y+2	; 0x02
    17ea:	fb 81       	ldd	r31, Y+3	; 0x03
    17ec:	8c 81       	ldd	r24, Y+4	; 0x04
    17ee:	9d 81       	ldd	r25, Y+5	; 0x05
    17f0:	97 83       	std	Z+7, r25	; 0x07
    17f2:	86 83       	std	Z+6, r24	; 0x06

				/* The data is being left in the queue, so see if there are
				any other tasks waiting for the data. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    17f4:	ea 81       	ldd	r30, Y+2	; 0x02
    17f6:	fb 81       	ldd	r31, Y+3	; 0x03
    17f8:	81 89       	ldd	r24, Z+17	; 0x11
    17fa:	88 23       	and	r24, r24
    17fc:	49 f0       	breq	.+18     	; 0x1810 <xQueuePeek+0x80>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    17fe:	8a 81       	ldd	r24, Y+2	; 0x02
    1800:	9b 81       	ldd	r25, Y+3	; 0x03
    1802:	41 96       	adiw	r24, 0x11	; 17
    1804:	0e 94 55 1d 	call	0x3aaa	; 0x3aaa <xTaskRemoveFromEventList>
    1808:	88 23       	and	r24, r24
    180a:	11 f0       	breq	.+4      	; 0x1810 <xQueuePeek+0x80>
					{
						/* The task waiting has a higher priority than this task. */
						queueYIELD_IF_USING_PREEMPTION();
    180c:	0e 94 08 02 	call	0x410	; 0x410 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    1810:	0f 90       	pop	r0
    1812:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1814:	81 e0       	ldi	r24, 0x01	; 1
    1816:	88 8b       	std	Y+16, r24	; 0x10
    1818:	63 c0       	rjmp	.+198    	; 0x18e0 <xQueuePeek+0x150>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    181a:	8e 85       	ldd	r24, Y+14	; 0x0e
    181c:	9f 85       	ldd	r25, Y+15	; 0x0f
    181e:	00 97       	sbiw	r24, 0x00	; 0
    1820:	21 f4       	brne	.+8      	; 0x182a <xQueuePeek+0x9a>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1822:	0f 90       	pop	r0
    1824:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_PEEK_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    1826:	18 8a       	std	Y+16, r1	; 0x10
    1828:	5b c0       	rjmp	.+182    	; 0x18e0 <xQueuePeek+0x150>
				}
				else if( xEntryTimeSet == pdFALSE )
    182a:	8e 81       	ldd	r24, Y+6	; 0x06
    182c:	88 23       	and	r24, r24
    182e:	31 f4       	brne	.+12     	; 0x183c <xQueuePeek+0xac>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure ready to enter the blocked
					state. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    1830:	ce 01       	movw	r24, r28
    1832:	07 96       	adiw	r24, 0x07	; 7
    1834:	0e 94 3b 1e 	call	0x3c76	; 0x3c76 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1838:	81 e0       	ldi	r24, 0x01	; 1
    183a:	8e 83       	std	Y+6, r24	; 0x06
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    183c:	0f 90       	pop	r0
    183e:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1840:	0e 94 b5 1a 	call	0x356a	; 0x356a <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1844:	0f b6       	in	r0, 0x3f	; 63
    1846:	f8 94       	cli
    1848:	0f 92       	push	r0
    184a:	ea 81       	ldd	r30, Y+2	; 0x02
    184c:	fb 81       	ldd	r31, Y+3	; 0x03
    184e:	85 8d       	ldd	r24, Z+29	; 0x1d
    1850:	8f 3f       	cpi	r24, 0xFF	; 255
    1852:	19 f4       	brne	.+6      	; 0x185a <xQueuePeek+0xca>
    1854:	ea 81       	ldd	r30, Y+2	; 0x02
    1856:	fb 81       	ldd	r31, Y+3	; 0x03
    1858:	15 8e       	std	Z+29, r1	; 0x1d
    185a:	ea 81       	ldd	r30, Y+2	; 0x02
    185c:	fb 81       	ldd	r31, Y+3	; 0x03
    185e:	86 8d       	ldd	r24, Z+30	; 0x1e
    1860:	8f 3f       	cpi	r24, 0xFF	; 255
    1862:	19 f4       	brne	.+6      	; 0x186a <xQueuePeek+0xda>
    1864:	ea 81       	ldd	r30, Y+2	; 0x02
    1866:	fb 81       	ldd	r31, Y+3	; 0x03
    1868:	16 8e       	std	Z+30, r1	; 0x1e
    186a:	0f 90       	pop	r0
    186c:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    186e:	ce 01       	movw	r24, r28
    1870:	07 96       	adiw	r24, 0x07	; 7
    1872:	9e 01       	movw	r18, r28
    1874:	22 5f       	subi	r18, 0xF2	; 242
    1876:	3f 4f       	sbci	r19, 0xFF	; 255
    1878:	b9 01       	movw	r22, r18
    187a:	0e 94 54 1e 	call	0x3ca8	; 0x3ca8 <xTaskCheckForTimeOut>
    187e:	88 23       	and	r24, r24
    1880:	09 f5       	brne	.+66     	; 0x18c4 <xQueuePeek+0x134>
		{
			/* Timeout has not expired yet, check to see if there is data in the
			queue now, and if not enter the Blocked state to wait for data. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1882:	8a 81       	ldd	r24, Y+2	; 0x02
    1884:	9b 81       	ldd	r25, Y+3	; 0x03
    1886:	0e 94 b8 0e 	call	0x1d70	; 0x1d70 <prvIsQueueEmpty>
    188a:	88 23       	and	r24, r24
    188c:	a1 f0       	breq	.+40     	; 0x18b6 <xQueuePeek+0x126>
			{
				traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    188e:	8a 81       	ldd	r24, Y+2	; 0x02
    1890:	9b 81       	ldd	r25, Y+3	; 0x03
    1892:	41 96       	adiw	r24, 0x11	; 17
    1894:	2e 85       	ldd	r18, Y+14	; 0x0e
    1896:	3f 85       	ldd	r19, Y+15	; 0x0f
    1898:	b9 01       	movw	r22, r18
    189a:	0e 94 03 1d 	call	0x3a06	; 0x3a06 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    189e:	8a 81       	ldd	r24, Y+2	; 0x02
    18a0:	9b 81       	ldd	r25, Y+3	; 0x03
    18a2:	0e 94 65 0e 	call	0x1cca	; 0x1cca <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    18a6:	0e 94 c1 1a 	call	0x3582	; 0x3582 <xTaskResumeAll>
    18aa:	88 23       	and	r24, r24
    18ac:	09 f0       	breq	.+2      	; 0x18b0 <xQueuePeek+0x120>
    18ae:	85 cf       	rjmp	.-246    	; 0x17ba <xQueuePeek+0x2a>
				{
					portYIELD_WITHIN_API();
    18b0:	0e 94 08 02 	call	0x410	; 0x410 <vPortYield>
    18b4:	82 cf       	rjmp	.-252    	; 0x17ba <xQueuePeek+0x2a>
			}
			else
			{
				/* There is data in the queue now, so don't enter the blocked
				state, instead return to try and obtain the data. */
				prvUnlockQueue( pxQueue );
    18b6:	8a 81       	ldd	r24, Y+2	; 0x02
    18b8:	9b 81       	ldd	r25, Y+3	; 0x03
    18ba:	0e 94 65 0e 	call	0x1cca	; 0x1cca <prvUnlockQueue>
				( void ) xTaskResumeAll();
    18be:	0e 94 c1 1a 	call	0x3582	; 0x3582 <xTaskResumeAll>
    18c2:	7b cf       	rjmp	.-266    	; 0x17ba <xQueuePeek+0x2a>
		}
		else
		{
			/* The timeout has expired.  If there is still no data in the queue
			exit, otherwise go back and try to read the data again. */
			prvUnlockQueue( pxQueue );
    18c4:	8a 81       	ldd	r24, Y+2	; 0x02
    18c6:	9b 81       	ldd	r25, Y+3	; 0x03
    18c8:	0e 94 65 0e 	call	0x1cca	; 0x1cca <prvUnlockQueue>
			( void ) xTaskResumeAll();
    18cc:	0e 94 c1 1a 	call	0x3582	; 0x3582 <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    18d0:	8a 81       	ldd	r24, Y+2	; 0x02
    18d2:	9b 81       	ldd	r25, Y+3	; 0x03
    18d4:	0e 94 b8 0e 	call	0x1d70	; 0x1d70 <prvIsQueueEmpty>
    18d8:	88 23       	and	r24, r24
    18da:	09 f4       	brne	.+2      	; 0x18de <xQueuePeek+0x14e>
    18dc:	6e cf       	rjmp	.-292    	; 0x17ba <xQueuePeek+0x2a>
			{
				traceQUEUE_PEEK_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    18de:	18 8a       	std	Y+16, r1	; 0x10
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
    18e0:	88 89       	ldd	r24, Y+16	; 0x10
}
    18e2:	60 96       	adiw	r28, 0x10	; 16
    18e4:	0f b6       	in	r0, 0x3f	; 63
    18e6:	f8 94       	cli
    18e8:	de bf       	out	0x3e, r29	; 62
    18ea:	0f be       	out	0x3f, r0	; 63
    18ec:	cd bf       	out	0x3d, r28	; 61
    18ee:	cf 91       	pop	r28
    18f0:	df 91       	pop	r29
    18f2:	08 95       	ret

000018f4 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
{
    18f4:	df 93       	push	r29
    18f6:	cf 93       	push	r28
    18f8:	cd b7       	in	r28, 0x3d	; 61
    18fa:	de b7       	in	r29, 0x3e	; 62
    18fc:	2c 97       	sbiw	r28, 0x0c	; 12
    18fe:	0f b6       	in	r0, 0x3f	; 63
    1900:	f8 94       	cli
    1902:	de bf       	out	0x3e, r29	; 62
    1904:	0f be       	out	0x3f, r0	; 63
    1906:	cd bf       	out	0x3d, r28	; 61
    1908:	98 87       	std	Y+8, r25	; 0x08
    190a:	8f 83       	std	Y+7, r24	; 0x07
    190c:	7a 87       	std	Y+10, r23	; 0x0a
    190e:	69 87       	std	Y+9, r22	; 0x09
    1910:	5c 87       	std	Y+12, r21	; 0x0c
    1912:	4b 87       	std	Y+11, r20	; 0x0b
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
    1914:	8f 81       	ldd	r24, Y+7	; 0x07
    1916:	98 85       	ldd	r25, Y+8	; 0x08
    1918:	9c 83       	std	Y+4, r25	; 0x04
    191a:	8b 83       	std	Y+3, r24	; 0x03
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    191c:	1d 82       	std	Y+5, r1	; 0x05
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    191e:	eb 81       	ldd	r30, Y+3	; 0x03
    1920:	fc 81       	ldd	r31, Y+4	; 0x04
    1922:	82 8d       	ldd	r24, Z+26	; 0x1a
    1924:	8a 83       	std	Y+2, r24	; 0x02

		/* Cannot block in an ISR, so check there is data available. */
		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    1926:	8a 81       	ldd	r24, Y+2	; 0x02
    1928:	88 23       	and	r24, r24
    192a:	81 f1       	breq	.+96     	; 0x198c <xQueueReceiveFromISR+0x98>
		{
			const int8_t cRxLock = pxQueue->cRxLock;
    192c:	eb 81       	ldd	r30, Y+3	; 0x03
    192e:	fc 81       	ldd	r31, Y+4	; 0x04
    1930:	85 8d       	ldd	r24, Z+29	; 0x1d
    1932:	89 83       	std	Y+1, r24	; 0x01

			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    1934:	8b 81       	ldd	r24, Y+3	; 0x03
    1936:	9c 81       	ldd	r25, Y+4	; 0x04
    1938:	29 85       	ldd	r18, Y+9	; 0x09
    193a:	3a 85       	ldd	r19, Y+10	; 0x0a
    193c:	b9 01       	movw	r22, r18
    193e:	0e 94 1e 0e 	call	0x1c3c	; 0x1c3c <prvCopyDataFromQueue>
			pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    1942:	8a 81       	ldd	r24, Y+2	; 0x02
    1944:	81 50       	subi	r24, 0x01	; 1
    1946:	eb 81       	ldd	r30, Y+3	; 0x03
    1948:	fc 81       	ldd	r31, Y+4	; 0x04
    194a:	82 8f       	std	Z+26, r24	; 0x1a

			/* If the queue is locked the event list will not be modified.
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( cRxLock == queueUNLOCKED )
    194c:	89 81       	ldd	r24, Y+1	; 0x01
    194e:	8f 3f       	cpi	r24, 0xFF	; 255
    1950:	a9 f4       	brne	.+42     	; 0x197c <xQueueReceiveFromISR+0x88>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1952:	eb 81       	ldd	r30, Y+3	; 0x03
    1954:	fc 81       	ldd	r31, Y+4	; 0x04
    1956:	80 85       	ldd	r24, Z+8	; 0x08
    1958:	88 23       	and	r24, r24
    195a:	a9 f0       	breq	.+42     	; 0x1986 <xQueueReceiveFromISR+0x92>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    195c:	8b 81       	ldd	r24, Y+3	; 0x03
    195e:	9c 81       	ldd	r25, Y+4	; 0x04
    1960:	08 96       	adiw	r24, 0x08	; 8
    1962:	0e 94 55 1d 	call	0x3aaa	; 0x3aaa <xTaskRemoveFromEventList>
    1966:	88 23       	and	r24, r24
    1968:	71 f0       	breq	.+28     	; 0x1986 <xQueueReceiveFromISR+0x92>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
    196a:	8b 85       	ldd	r24, Y+11	; 0x0b
    196c:	9c 85       	ldd	r25, Y+12	; 0x0c
    196e:	00 97       	sbiw	r24, 0x00	; 0
    1970:	51 f0       	breq	.+20     	; 0x1986 <xQueueReceiveFromISR+0x92>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    1972:	eb 85       	ldd	r30, Y+11	; 0x0b
    1974:	fc 85       	ldd	r31, Y+12	; 0x0c
    1976:	81 e0       	ldi	r24, 0x01	; 1
    1978:	80 83       	st	Z, r24
    197a:	05 c0       	rjmp	.+10     	; 0x1986 <xQueueReceiveFromISR+0x92>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
    197c:	89 81       	ldd	r24, Y+1	; 0x01
    197e:	8f 5f       	subi	r24, 0xFF	; 255
    1980:	eb 81       	ldd	r30, Y+3	; 0x03
    1982:	fc 81       	ldd	r31, Y+4	; 0x04
    1984:	85 8f       	std	Z+29, r24	; 0x1d
			}

			xReturn = pdPASS;
    1986:	81 e0       	ldi	r24, 0x01	; 1
    1988:	8e 83       	std	Y+6, r24	; 0x06
    198a:	01 c0       	rjmp	.+2      	; 0x198e <xQueueReceiveFromISR+0x9a>
		}
		else
		{
			xReturn = pdFAIL;
    198c:	1e 82       	std	Y+6, r1	; 0x06
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    198e:	8e 81       	ldd	r24, Y+6	; 0x06
}
    1990:	2c 96       	adiw	r28, 0x0c	; 12
    1992:	0f b6       	in	r0, 0x3f	; 63
    1994:	f8 94       	cli
    1996:	de bf       	out	0x3e, r29	; 62
    1998:	0f be       	out	0x3f, r0	; 63
    199a:	cd bf       	out	0x3d, r28	; 61
    199c:	cf 91       	pop	r28
    199e:	df 91       	pop	r29
    19a0:	08 95       	ret

000019a2 <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
{
    19a2:	df 93       	push	r29
    19a4:	cf 93       	push	r28
    19a6:	cd b7       	in	r28, 0x3d	; 61
    19a8:	de b7       	in	r29, 0x3e	; 62
    19aa:	2a 97       	sbiw	r28, 0x0a	; 10
    19ac:	0f b6       	in	r0, 0x3f	; 63
    19ae:	f8 94       	cli
    19b0:	de bf       	out	0x3e, r29	; 62
    19b2:	0f be       	out	0x3f, r0	; 63
    19b4:	cd bf       	out	0x3d, r28	; 61
    19b6:	98 87       	std	Y+8, r25	; 0x08
    19b8:	8f 83       	std	Y+7, r24	; 0x07
    19ba:	7a 87       	std	Y+10, r23	; 0x0a
    19bc:	69 87       	std	Y+9, r22	; 0x09
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = xQueue;
    19be:	8f 81       	ldd	r24, Y+7	; 0x07
    19c0:	98 85       	ldd	r25, Y+8	; 0x08
    19c2:	9a 83       	std	Y+2, r25	; 0x02
    19c4:	89 83       	std	Y+1, r24	; 0x01
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    19c6:	1d 82       	std	Y+5, r1	; 0x05
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    19c8:	e9 81       	ldd	r30, Y+1	; 0x01
    19ca:	fa 81       	ldd	r31, Y+2	; 0x02
    19cc:	82 8d       	ldd	r24, Z+26	; 0x1a
    19ce:	88 23       	and	r24, r24
    19d0:	b1 f0       	breq	.+44     	; 0x19fe <xQueuePeekFromISR+0x5c>
		{
			traceQUEUE_PEEK_FROM_ISR( pxQueue );

			/* Remember the read position so it can be reset as nothing is
			actually being removed from the queue. */
			pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    19d2:	e9 81       	ldd	r30, Y+1	; 0x01
    19d4:	fa 81       	ldd	r31, Y+2	; 0x02
    19d6:	86 81       	ldd	r24, Z+6	; 0x06
    19d8:	97 81       	ldd	r25, Z+7	; 0x07
    19da:	9c 83       	std	Y+4, r25	; 0x04
    19dc:	8b 83       	std	Y+3, r24	; 0x03
			prvCopyDataFromQueue( pxQueue, pvBuffer );
    19de:	89 81       	ldd	r24, Y+1	; 0x01
    19e0:	9a 81       	ldd	r25, Y+2	; 0x02
    19e2:	29 85       	ldd	r18, Y+9	; 0x09
    19e4:	3a 85       	ldd	r19, Y+10	; 0x0a
    19e6:	b9 01       	movw	r22, r18
    19e8:	0e 94 1e 0e 	call	0x1c3c	; 0x1c3c <prvCopyDataFromQueue>
			pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    19ec:	e9 81       	ldd	r30, Y+1	; 0x01
    19ee:	fa 81       	ldd	r31, Y+2	; 0x02
    19f0:	8b 81       	ldd	r24, Y+3	; 0x03
    19f2:	9c 81       	ldd	r25, Y+4	; 0x04
    19f4:	97 83       	std	Z+7, r25	; 0x07
    19f6:	86 83       	std	Z+6, r24	; 0x06

			xReturn = pdPASS;
    19f8:	81 e0       	ldi	r24, 0x01	; 1
    19fa:	8e 83       	std	Y+6, r24	; 0x06
    19fc:	01 c0       	rjmp	.+2      	; 0x1a00 <xQueuePeekFromISR+0x5e>
		}
		else
		{
			xReturn = pdFAIL;
    19fe:	1e 82       	std	Y+6, r1	; 0x06
			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    1a00:	8e 81       	ldd	r24, Y+6	; 0x06
}
    1a02:	2a 96       	adiw	r28, 0x0a	; 10
    1a04:	0f b6       	in	r0, 0x3f	; 63
    1a06:	f8 94       	cli
    1a08:	de bf       	out	0x3e, r29	; 62
    1a0a:	0f be       	out	0x3f, r0	; 63
    1a0c:	cd bf       	out	0x3d, r28	; 61
    1a0e:	cf 91       	pop	r28
    1a10:	df 91       	pop	r29
    1a12:	08 95       	ret

00001a14 <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
{
    1a14:	df 93       	push	r29
    1a16:	cf 93       	push	r28
    1a18:	00 d0       	rcall	.+0      	; 0x1a1a <uxQueueMessagesWaiting+0x6>
    1a1a:	0f 92       	push	r0
    1a1c:	cd b7       	in	r28, 0x3d	; 61
    1a1e:	de b7       	in	r29, 0x3e	; 62
    1a20:	9b 83       	std	Y+3, r25	; 0x03
    1a22:	8a 83       	std	Y+2, r24	; 0x02
UBaseType_t uxReturn;

	configASSERT( xQueue );

	taskENTER_CRITICAL();
    1a24:	0f b6       	in	r0, 0x3f	; 63
    1a26:	f8 94       	cli
    1a28:	0f 92       	push	r0
	{
		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    1a2a:	ea 81       	ldd	r30, Y+2	; 0x02
    1a2c:	fb 81       	ldd	r31, Y+3	; 0x03
    1a2e:	82 8d       	ldd	r24, Z+26	; 0x1a
    1a30:	89 83       	std	Y+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    1a32:	0f 90       	pop	r0
    1a34:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    1a36:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    1a38:	0f 90       	pop	r0
    1a3a:	0f 90       	pop	r0
    1a3c:	0f 90       	pop	r0
    1a3e:	cf 91       	pop	r28
    1a40:	df 91       	pop	r29
    1a42:	08 95       	ret

00001a44 <uxQueueSpacesAvailable>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
{
    1a44:	df 93       	push	r29
    1a46:	cf 93       	push	r28
    1a48:	00 d0       	rcall	.+0      	; 0x1a4a <uxQueueSpacesAvailable+0x6>
    1a4a:	00 d0       	rcall	.+0      	; 0x1a4c <uxQueueSpacesAvailable+0x8>
    1a4c:	0f 92       	push	r0
    1a4e:	cd b7       	in	r28, 0x3d	; 61
    1a50:	de b7       	in	r29, 0x3e	; 62
    1a52:	9d 83       	std	Y+5, r25	; 0x05
    1a54:	8c 83       	std	Y+4, r24	; 0x04
UBaseType_t uxReturn;
Queue_t * const pxQueue = xQueue;
    1a56:	8c 81       	ldd	r24, Y+4	; 0x04
    1a58:	9d 81       	ldd	r25, Y+5	; 0x05
    1a5a:	9a 83       	std	Y+2, r25	; 0x02
    1a5c:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    1a5e:	0f b6       	in	r0, 0x3f	; 63
    1a60:	f8 94       	cli
    1a62:	0f 92       	push	r0
	{
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    1a64:	e9 81       	ldd	r30, Y+1	; 0x01
    1a66:	fa 81       	ldd	r31, Y+2	; 0x02
    1a68:	93 8d       	ldd	r25, Z+27	; 0x1b
    1a6a:	e9 81       	ldd	r30, Y+1	; 0x01
    1a6c:	fa 81       	ldd	r31, Y+2	; 0x02
    1a6e:	82 8d       	ldd	r24, Z+26	; 0x1a
    1a70:	29 2f       	mov	r18, r25
    1a72:	28 1b       	sub	r18, r24
    1a74:	82 2f       	mov	r24, r18
    1a76:	8b 83       	std	Y+3, r24	; 0x03
	}
	taskEXIT_CRITICAL();
    1a78:	0f 90       	pop	r0
    1a7a:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    1a7c:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    1a7e:	0f 90       	pop	r0
    1a80:	0f 90       	pop	r0
    1a82:	0f 90       	pop	r0
    1a84:	0f 90       	pop	r0
    1a86:	0f 90       	pop	r0
    1a88:	cf 91       	pop	r28
    1a8a:	df 91       	pop	r29
    1a8c:	08 95       	ret

00001a8e <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
{
    1a8e:	df 93       	push	r29
    1a90:	cf 93       	push	r28
    1a92:	00 d0       	rcall	.+0      	; 0x1a94 <uxQueueMessagesWaitingFromISR+0x6>
    1a94:	00 d0       	rcall	.+0      	; 0x1a96 <uxQueueMessagesWaitingFromISR+0x8>
    1a96:	0f 92       	push	r0
    1a98:	cd b7       	in	r28, 0x3d	; 61
    1a9a:	de b7       	in	r29, 0x3e	; 62
    1a9c:	9d 83       	std	Y+5, r25	; 0x05
    1a9e:	8c 83       	std	Y+4, r24	; 0x04
UBaseType_t uxReturn;
Queue_t * const pxQueue = xQueue;
    1aa0:	8c 81       	ldd	r24, Y+4	; 0x04
    1aa2:	9d 81       	ldd	r25, Y+5	; 0x05
    1aa4:	9a 83       	std	Y+2, r25	; 0x02
    1aa6:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );
	uxReturn = pxQueue->uxMessagesWaiting;
    1aa8:	e9 81       	ldd	r30, Y+1	; 0x01
    1aaa:	fa 81       	ldd	r31, Y+2	; 0x02
    1aac:	82 8d       	ldd	r24, Z+26	; 0x1a
    1aae:	8b 83       	std	Y+3, r24	; 0x03

	return uxReturn;
    1ab0:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    1ab2:	0f 90       	pop	r0
    1ab4:	0f 90       	pop	r0
    1ab6:	0f 90       	pop	r0
    1ab8:	0f 90       	pop	r0
    1aba:	0f 90       	pop	r0
    1abc:	cf 91       	pop	r28
    1abe:	df 91       	pop	r29
    1ac0:	08 95       	ret

00001ac2 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( QueueHandle_t xQueue )
{
    1ac2:	df 93       	push	r29
    1ac4:	cf 93       	push	r28
    1ac6:	00 d0       	rcall	.+0      	; 0x1ac8 <vQueueDelete+0x6>
    1ac8:	00 d0       	rcall	.+0      	; 0x1aca <vQueueDelete+0x8>
    1aca:	cd b7       	in	r28, 0x3d	; 61
    1acc:	de b7       	in	r29, 0x3e	; 62
    1ace:	9c 83       	std	Y+4, r25	; 0x04
    1ad0:	8b 83       	std	Y+3, r24	; 0x03
Queue_t * const pxQueue = xQueue;
    1ad2:	8b 81       	ldd	r24, Y+3	; 0x03
    1ad4:	9c 81       	ldd	r25, Y+4	; 0x04
    1ad6:	9a 83       	std	Y+2, r25	; 0x02
    1ad8:	89 83       	std	Y+1, r24	; 0x01

	#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
	{
		/* The queue can only have been allocated dynamically - free it
		again. */
		vPortFree( pxQueue );
    1ada:	89 81       	ldd	r24, Y+1	; 0x01
    1adc:	9a 81       	ldd	r25, Y+2	; 0x02
    1ade:	0e 94 b8 06 	call	0xd70	; 0xd70 <vPortFree>
		/* The queue must have been statically allocated, so is not going to be
		deleted.  Avoid compiler warnings about the unused parameter. */
		( void ) pxQueue;
	}
	#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
}
    1ae2:	0f 90       	pop	r0
    1ae4:	0f 90       	pop	r0
    1ae6:	0f 90       	pop	r0
    1ae8:	0f 90       	pop	r0
    1aea:	cf 91       	pop	r28
    1aec:	df 91       	pop	r29
    1aee:	08 95       	ret

00001af0 <prvCopyDataToQueue>:

#endif /* configUSE_MUTEXES */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
    1af0:	df 93       	push	r29
    1af2:	cf 93       	push	r28
    1af4:	cd b7       	in	r28, 0x3d	; 61
    1af6:	de b7       	in	r29, 0x3e	; 62
    1af8:	27 97       	sbiw	r28, 0x07	; 7
    1afa:	0f b6       	in	r0, 0x3f	; 63
    1afc:	f8 94       	cli
    1afe:	de bf       	out	0x3e, r29	; 62
    1b00:	0f be       	out	0x3f, r0	; 63
    1b02:	cd bf       	out	0x3d, r28	; 61
    1b04:	9c 83       	std	Y+4, r25	; 0x04
    1b06:	8b 83       	std	Y+3, r24	; 0x03
    1b08:	7e 83       	std	Y+6, r23	; 0x06
    1b0a:	6d 83       	std	Y+5, r22	; 0x05
    1b0c:	4f 83       	std	Y+7, r20	; 0x07
BaseType_t xReturn = pdFALSE;
    1b0e:	1a 82       	std	Y+2, r1	; 0x02
UBaseType_t uxMessagesWaiting;

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1b10:	eb 81       	ldd	r30, Y+3	; 0x03
    1b12:	fc 81       	ldd	r31, Y+4	; 0x04
    1b14:	82 8d       	ldd	r24, Z+26	; 0x1a
    1b16:	89 83       	std	Y+1, r24	; 0x01

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    1b18:	eb 81       	ldd	r30, Y+3	; 0x03
    1b1a:	fc 81       	ldd	r31, Y+4	; 0x04
    1b1c:	84 8d       	ldd	r24, Z+28	; 0x1c
    1b1e:	88 23       	and	r24, r24
    1b20:	09 f4       	brne	.+2      	; 0x1b24 <prvCopyDataToQueue+0x34>
    1b22:	7d c0       	rjmp	.+250    	; 0x1c1e <prvCopyDataToQueue+0x12e>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
    1b24:	8f 81       	ldd	r24, Y+7	; 0x07
    1b26:	88 23       	and	r24, r24
    1b28:	99 f5       	brne	.+102    	; 0x1b90 <prvCopyDataToQueue+0xa0>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    1b2a:	eb 81       	ldd	r30, Y+3	; 0x03
    1b2c:	fc 81       	ldd	r31, Y+4	; 0x04
    1b2e:	62 81       	ldd	r22, Z+2	; 0x02
    1b30:	73 81       	ldd	r23, Z+3	; 0x03
    1b32:	eb 81       	ldd	r30, Y+3	; 0x03
    1b34:	fc 81       	ldd	r31, Y+4	; 0x04
    1b36:	84 8d       	ldd	r24, Z+28	; 0x1c
    1b38:	48 2f       	mov	r20, r24
    1b3a:	50 e0       	ldi	r21, 0x00	; 0
    1b3c:	2d 81       	ldd	r18, Y+5	; 0x05
    1b3e:	3e 81       	ldd	r19, Y+6	; 0x06
    1b40:	cb 01       	movw	r24, r22
    1b42:	b9 01       	movw	r22, r18
    1b44:	0e 94 87 24 	call	0x490e	; 0x490e <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    1b48:	eb 81       	ldd	r30, Y+3	; 0x03
    1b4a:	fc 81       	ldd	r31, Y+4	; 0x04
    1b4c:	22 81       	ldd	r18, Z+2	; 0x02
    1b4e:	33 81       	ldd	r19, Z+3	; 0x03
    1b50:	eb 81       	ldd	r30, Y+3	; 0x03
    1b52:	fc 81       	ldd	r31, Y+4	; 0x04
    1b54:	84 8d       	ldd	r24, Z+28	; 0x1c
    1b56:	88 2f       	mov	r24, r24
    1b58:	90 e0       	ldi	r25, 0x00	; 0
    1b5a:	82 0f       	add	r24, r18
    1b5c:	93 1f       	adc	r25, r19
    1b5e:	eb 81       	ldd	r30, Y+3	; 0x03
    1b60:	fc 81       	ldd	r31, Y+4	; 0x04
    1b62:	93 83       	std	Z+3, r25	; 0x03
    1b64:	82 83       	std	Z+2, r24	; 0x02
		if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    1b66:	eb 81       	ldd	r30, Y+3	; 0x03
    1b68:	fc 81       	ldd	r31, Y+4	; 0x04
    1b6a:	22 81       	ldd	r18, Z+2	; 0x02
    1b6c:	33 81       	ldd	r19, Z+3	; 0x03
    1b6e:	eb 81       	ldd	r30, Y+3	; 0x03
    1b70:	fc 81       	ldd	r31, Y+4	; 0x04
    1b72:	84 81       	ldd	r24, Z+4	; 0x04
    1b74:	95 81       	ldd	r25, Z+5	; 0x05
    1b76:	28 17       	cp	r18, r24
    1b78:	39 07       	cpc	r19, r25
    1b7a:	08 f4       	brcc	.+2      	; 0x1b7e <prvCopyDataToQueue+0x8e>
    1b7c:	50 c0       	rjmp	.+160    	; 0x1c1e <prvCopyDataToQueue+0x12e>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    1b7e:	eb 81       	ldd	r30, Y+3	; 0x03
    1b80:	fc 81       	ldd	r31, Y+4	; 0x04
    1b82:	80 81       	ld	r24, Z
    1b84:	91 81       	ldd	r25, Z+1	; 0x01
    1b86:	eb 81       	ldd	r30, Y+3	; 0x03
    1b88:	fc 81       	ldd	r31, Y+4	; 0x04
    1b8a:	93 83       	std	Z+3, r25	; 0x03
    1b8c:	82 83       	std	Z+2, r24	; 0x02
    1b8e:	47 c0       	rjmp	.+142    	; 0x1c1e <prvCopyDataToQueue+0x12e>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
    1b90:	eb 81       	ldd	r30, Y+3	; 0x03
    1b92:	fc 81       	ldd	r31, Y+4	; 0x04
    1b94:	66 81       	ldd	r22, Z+6	; 0x06
    1b96:	77 81       	ldd	r23, Z+7	; 0x07
    1b98:	eb 81       	ldd	r30, Y+3	; 0x03
    1b9a:	fc 81       	ldd	r31, Y+4	; 0x04
    1b9c:	84 8d       	ldd	r24, Z+28	; 0x1c
    1b9e:	48 2f       	mov	r20, r24
    1ba0:	50 e0       	ldi	r21, 0x00	; 0
    1ba2:	2d 81       	ldd	r18, Y+5	; 0x05
    1ba4:	3e 81       	ldd	r19, Y+6	; 0x06
    1ba6:	cb 01       	movw	r24, r22
    1ba8:	b9 01       	movw	r22, r18
    1baa:	0e 94 87 24 	call	0x490e	; 0x490e <memcpy>
		pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
    1bae:	eb 81       	ldd	r30, Y+3	; 0x03
    1bb0:	fc 81       	ldd	r31, Y+4	; 0x04
    1bb2:	26 81       	ldd	r18, Z+6	; 0x06
    1bb4:	37 81       	ldd	r19, Z+7	; 0x07
    1bb6:	eb 81       	ldd	r30, Y+3	; 0x03
    1bb8:	fc 81       	ldd	r31, Y+4	; 0x04
    1bba:	84 8d       	ldd	r24, Z+28	; 0x1c
    1bbc:	88 2f       	mov	r24, r24
    1bbe:	90 e0       	ldi	r25, 0x00	; 0
    1bc0:	90 95       	com	r25
    1bc2:	81 95       	neg	r24
    1bc4:	9f 4f       	sbci	r25, 0xFF	; 255
    1bc6:	82 0f       	add	r24, r18
    1bc8:	93 1f       	adc	r25, r19
    1bca:	eb 81       	ldd	r30, Y+3	; 0x03
    1bcc:	fc 81       	ldd	r31, Y+4	; 0x04
    1bce:	97 83       	std	Z+7, r25	; 0x07
    1bd0:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    1bd2:	eb 81       	ldd	r30, Y+3	; 0x03
    1bd4:	fc 81       	ldd	r31, Y+4	; 0x04
    1bd6:	26 81       	ldd	r18, Z+6	; 0x06
    1bd8:	37 81       	ldd	r19, Z+7	; 0x07
    1bda:	eb 81       	ldd	r30, Y+3	; 0x03
    1bdc:	fc 81       	ldd	r31, Y+4	; 0x04
    1bde:	80 81       	ld	r24, Z
    1be0:	91 81       	ldd	r25, Z+1	; 0x01
    1be2:	28 17       	cp	r18, r24
    1be4:	39 07       	cpc	r19, r25
    1be6:	90 f4       	brcc	.+36     	; 0x1c0c <prvCopyDataToQueue+0x11c>
		{
			pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
    1be8:	eb 81       	ldd	r30, Y+3	; 0x03
    1bea:	fc 81       	ldd	r31, Y+4	; 0x04
    1bec:	24 81       	ldd	r18, Z+4	; 0x04
    1bee:	35 81       	ldd	r19, Z+5	; 0x05
    1bf0:	eb 81       	ldd	r30, Y+3	; 0x03
    1bf2:	fc 81       	ldd	r31, Y+4	; 0x04
    1bf4:	84 8d       	ldd	r24, Z+28	; 0x1c
    1bf6:	88 2f       	mov	r24, r24
    1bf8:	90 e0       	ldi	r25, 0x00	; 0
    1bfa:	90 95       	com	r25
    1bfc:	81 95       	neg	r24
    1bfe:	9f 4f       	sbci	r25, 0xFF	; 255
    1c00:	82 0f       	add	r24, r18
    1c02:	93 1f       	adc	r25, r19
    1c04:	eb 81       	ldd	r30, Y+3	; 0x03
    1c06:	fc 81       	ldd	r31, Y+4	; 0x04
    1c08:	97 83       	std	Z+7, r25	; 0x07
    1c0a:	86 83       	std	Z+6, r24	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
    1c0c:	8f 81       	ldd	r24, Y+7	; 0x07
    1c0e:	82 30       	cpi	r24, 0x02	; 2
    1c10:	31 f4       	brne	.+12     	; 0x1c1e <prvCopyDataToQueue+0x12e>
		{
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    1c12:	89 81       	ldd	r24, Y+1	; 0x01
    1c14:	88 23       	and	r24, r24
    1c16:	19 f0       	breq	.+6      	; 0x1c1e <prvCopyDataToQueue+0x12e>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--uxMessagesWaiting;
    1c18:	89 81       	ldd	r24, Y+1	; 0x01
    1c1a:	81 50       	subi	r24, 0x01	; 1
    1c1c:	89 83       	std	Y+1, r24	; 0x01
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    1c1e:	89 81       	ldd	r24, Y+1	; 0x01
    1c20:	8f 5f       	subi	r24, 0xFF	; 255
    1c22:	eb 81       	ldd	r30, Y+3	; 0x03
    1c24:	fc 81       	ldd	r31, Y+4	; 0x04
    1c26:	82 8f       	std	Z+26, r24	; 0x1a

	return xReturn;
    1c28:	8a 81       	ldd	r24, Y+2	; 0x02
}
    1c2a:	27 96       	adiw	r28, 0x07	; 7
    1c2c:	0f b6       	in	r0, 0x3f	; 63
    1c2e:	f8 94       	cli
    1c30:	de bf       	out	0x3e, r29	; 62
    1c32:	0f be       	out	0x3f, r0	; 63
    1c34:	cd bf       	out	0x3d, r28	; 61
    1c36:	cf 91       	pop	r28
    1c38:	df 91       	pop	r29
    1c3a:	08 95       	ret

00001c3c <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
    1c3c:	df 93       	push	r29
    1c3e:	cf 93       	push	r28
    1c40:	00 d0       	rcall	.+0      	; 0x1c42 <prvCopyDataFromQueue+0x6>
    1c42:	00 d0       	rcall	.+0      	; 0x1c44 <prvCopyDataFromQueue+0x8>
    1c44:	cd b7       	in	r28, 0x3d	; 61
    1c46:	de b7       	in	r29, 0x3e	; 62
    1c48:	9a 83       	std	Y+2, r25	; 0x02
    1c4a:	89 83       	std	Y+1, r24	; 0x01
    1c4c:	7c 83       	std	Y+4, r23	; 0x04
    1c4e:	6b 83       	std	Y+3, r22	; 0x03
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    1c50:	e9 81       	ldd	r30, Y+1	; 0x01
    1c52:	fa 81       	ldd	r31, Y+2	; 0x02
    1c54:	84 8d       	ldd	r24, Z+28	; 0x1c
    1c56:	88 23       	and	r24, r24
    1c58:	89 f1       	breq	.+98     	; 0x1cbc <prvCopyDataFromQueue+0x80>
	{
		pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    1c5a:	e9 81       	ldd	r30, Y+1	; 0x01
    1c5c:	fa 81       	ldd	r31, Y+2	; 0x02
    1c5e:	26 81       	ldd	r18, Z+6	; 0x06
    1c60:	37 81       	ldd	r19, Z+7	; 0x07
    1c62:	e9 81       	ldd	r30, Y+1	; 0x01
    1c64:	fa 81       	ldd	r31, Y+2	; 0x02
    1c66:	84 8d       	ldd	r24, Z+28	; 0x1c
    1c68:	88 2f       	mov	r24, r24
    1c6a:	90 e0       	ldi	r25, 0x00	; 0
    1c6c:	82 0f       	add	r24, r18
    1c6e:	93 1f       	adc	r25, r19
    1c70:	e9 81       	ldd	r30, Y+1	; 0x01
    1c72:	fa 81       	ldd	r31, Y+2	; 0x02
    1c74:	97 83       	std	Z+7, r25	; 0x07
    1c76:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    1c78:	e9 81       	ldd	r30, Y+1	; 0x01
    1c7a:	fa 81       	ldd	r31, Y+2	; 0x02
    1c7c:	26 81       	ldd	r18, Z+6	; 0x06
    1c7e:	37 81       	ldd	r19, Z+7	; 0x07
    1c80:	e9 81       	ldd	r30, Y+1	; 0x01
    1c82:	fa 81       	ldd	r31, Y+2	; 0x02
    1c84:	84 81       	ldd	r24, Z+4	; 0x04
    1c86:	95 81       	ldd	r25, Z+5	; 0x05
    1c88:	28 17       	cp	r18, r24
    1c8a:	39 07       	cpc	r19, r25
    1c8c:	40 f0       	brcs	.+16     	; 0x1c9e <prvCopyDataFromQueue+0x62>
		{
			pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    1c8e:	e9 81       	ldd	r30, Y+1	; 0x01
    1c90:	fa 81       	ldd	r31, Y+2	; 0x02
    1c92:	80 81       	ld	r24, Z
    1c94:	91 81       	ldd	r25, Z+1	; 0x01
    1c96:	e9 81       	ldd	r30, Y+1	; 0x01
    1c98:	fa 81       	ldd	r31, Y+2	; 0x02
    1c9a:	97 83       	std	Z+7, r25	; 0x07
    1c9c:	86 83       	std	Z+6, r24	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    1c9e:	e9 81       	ldd	r30, Y+1	; 0x01
    1ca0:	fa 81       	ldd	r31, Y+2	; 0x02
    1ca2:	46 81       	ldd	r20, Z+6	; 0x06
    1ca4:	57 81       	ldd	r21, Z+7	; 0x07
    1ca6:	e9 81       	ldd	r30, Y+1	; 0x01
    1ca8:	fa 81       	ldd	r31, Y+2	; 0x02
    1caa:	84 8d       	ldd	r24, Z+28	; 0x1c
    1cac:	28 2f       	mov	r18, r24
    1cae:	30 e0       	ldi	r19, 0x00	; 0
    1cb0:	8b 81       	ldd	r24, Y+3	; 0x03
    1cb2:	9c 81       	ldd	r25, Y+4	; 0x04
    1cb4:	ba 01       	movw	r22, r20
    1cb6:	a9 01       	movw	r20, r18
    1cb8:	0e 94 87 24 	call	0x490e	; 0x490e <memcpy>
	}
}
    1cbc:	0f 90       	pop	r0
    1cbe:	0f 90       	pop	r0
    1cc0:	0f 90       	pop	r0
    1cc2:	0f 90       	pop	r0
    1cc4:	cf 91       	pop	r28
    1cc6:	df 91       	pop	r29
    1cc8:	08 95       	ret

00001cca <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    1cca:	df 93       	push	r29
    1ccc:	cf 93       	push	r28
    1cce:	00 d0       	rcall	.+0      	; 0x1cd0 <prvUnlockQueue+0x6>
    1cd0:	00 d0       	rcall	.+0      	; 0x1cd2 <prvUnlockQueue+0x8>
    1cd2:	cd b7       	in	r28, 0x3d	; 61
    1cd4:	de b7       	in	r29, 0x3e	; 62
    1cd6:	9c 83       	std	Y+4, r25	; 0x04
    1cd8:	8b 83       	std	Y+3, r24	; 0x03

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    1cda:	0f b6       	in	r0, 0x3f	; 63
    1cdc:	f8 94       	cli
    1cde:	0f 92       	push	r0
	{
		int8_t cTxLock = pxQueue->cTxLock;
    1ce0:	eb 81       	ldd	r30, Y+3	; 0x03
    1ce2:	fc 81       	ldd	r31, Y+4	; 0x04
    1ce4:	86 8d       	ldd	r24, Z+30	; 0x1e
    1ce6:	8a 83       	std	Y+2, r24	; 0x02
    1ce8:	11 c0       	rjmp	.+34     	; 0x1d0c <prvUnlockQueue+0x42>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1cea:	eb 81       	ldd	r30, Y+3	; 0x03
    1cec:	fc 81       	ldd	r31, Y+4	; 0x04
    1cee:	81 89       	ldd	r24, Z+17	; 0x11
    1cf0:	88 23       	and	r24, r24
    1cf2:	79 f0       	breq	.+30     	; 0x1d12 <prvUnlockQueue+0x48>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1cf4:	8b 81       	ldd	r24, Y+3	; 0x03
    1cf6:	9c 81       	ldd	r25, Y+4	; 0x04
    1cf8:	41 96       	adiw	r24, 0x11	; 17
    1cfa:	0e 94 55 1d 	call	0x3aaa	; 0x3aaa <xTaskRemoveFromEventList>
    1cfe:	88 23       	and	r24, r24
    1d00:	11 f0       	breq	.+4      	; 0x1d06 <prvUnlockQueue+0x3c>
					{
						/* The task waiting has a higher priority so record that
						a context switch is required. */
						vTaskMissedYield();
    1d02:	0e 94 c1 1e 	call	0x3d82	; 0x3d82 <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
    1d06:	8a 81       	ldd	r24, Y+2	; 0x02
    1d08:	81 50       	subi	r24, 0x01	; 1
    1d0a:	8a 83       	std	Y+2, r24	; 0x02
	taskENTER_CRITICAL();
	{
		int8_t cTxLock = pxQueue->cTxLock;

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
    1d0c:	8a 81       	ldd	r24, Y+2	; 0x02
    1d0e:	18 16       	cp	r1, r24
    1d10:	64 f3       	brlt	.-40     	; 0x1cea <prvUnlockQueue+0x20>
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
		}

		pxQueue->cTxLock = queueUNLOCKED;
    1d12:	eb 81       	ldd	r30, Y+3	; 0x03
    1d14:	fc 81       	ldd	r31, Y+4	; 0x04
    1d16:	8f ef       	ldi	r24, 0xFF	; 255
    1d18:	86 8f       	std	Z+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    1d1a:	0f 90       	pop	r0
    1d1c:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    1d1e:	0f b6       	in	r0, 0x3f	; 63
    1d20:	f8 94       	cli
    1d22:	0f 92       	push	r0
	{
		int8_t cRxLock = pxQueue->cRxLock;
    1d24:	eb 81       	ldd	r30, Y+3	; 0x03
    1d26:	fc 81       	ldd	r31, Y+4	; 0x04
    1d28:	85 8d       	ldd	r24, Z+29	; 0x1d
    1d2a:	89 83       	std	Y+1, r24	; 0x01
    1d2c:	11 c0       	rjmp	.+34     	; 0x1d50 <prvUnlockQueue+0x86>

		while( cRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1d2e:	eb 81       	ldd	r30, Y+3	; 0x03
    1d30:	fc 81       	ldd	r31, Y+4	; 0x04
    1d32:	80 85       	ldd	r24, Z+8	; 0x08
    1d34:	88 23       	and	r24, r24
    1d36:	79 f0       	breq	.+30     	; 0x1d56 <prvUnlockQueue+0x8c>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1d38:	8b 81       	ldd	r24, Y+3	; 0x03
    1d3a:	9c 81       	ldd	r25, Y+4	; 0x04
    1d3c:	08 96       	adiw	r24, 0x08	; 8
    1d3e:	0e 94 55 1d 	call	0x3aaa	; 0x3aaa <xTaskRemoveFromEventList>
    1d42:	88 23       	and	r24, r24
    1d44:	11 f0       	breq	.+4      	; 0x1d4a <prvUnlockQueue+0x80>
				{
					vTaskMissedYield();
    1d46:	0e 94 c1 1e 	call	0x3d82	; 0x3d82 <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--cRxLock;
    1d4a:	89 81       	ldd	r24, Y+1	; 0x01
    1d4c:	81 50       	subi	r24, 0x01	; 1
    1d4e:	89 83       	std	Y+1, r24	; 0x01
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		int8_t cRxLock = pxQueue->cRxLock;

		while( cRxLock > queueLOCKED_UNMODIFIED )
    1d50:	89 81       	ldd	r24, Y+1	; 0x01
    1d52:	18 16       	cp	r1, r24
    1d54:	64 f3       	brlt	.-40     	; 0x1d2e <prvUnlockQueue+0x64>
			{
				break;
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
    1d56:	eb 81       	ldd	r30, Y+3	; 0x03
    1d58:	fc 81       	ldd	r31, Y+4	; 0x04
    1d5a:	8f ef       	ldi	r24, 0xFF	; 255
    1d5c:	85 8f       	std	Z+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    1d5e:	0f 90       	pop	r0
    1d60:	0f be       	out	0x3f, r0	; 63
}
    1d62:	0f 90       	pop	r0
    1d64:	0f 90       	pop	r0
    1d66:	0f 90       	pop	r0
    1d68:	0f 90       	pop	r0
    1d6a:	cf 91       	pop	r28
    1d6c:	df 91       	pop	r29
    1d6e:	08 95       	ret

00001d70 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
    1d70:	df 93       	push	r29
    1d72:	cf 93       	push	r28
    1d74:	00 d0       	rcall	.+0      	; 0x1d76 <prvIsQueueEmpty+0x6>
    1d76:	0f 92       	push	r0
    1d78:	cd b7       	in	r28, 0x3d	; 61
    1d7a:	de b7       	in	r29, 0x3e	; 62
    1d7c:	9b 83       	std	Y+3, r25	; 0x03
    1d7e:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	taskENTER_CRITICAL();
    1d80:	0f b6       	in	r0, 0x3f	; 63
    1d82:	f8 94       	cli
    1d84:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    1d86:	ea 81       	ldd	r30, Y+2	; 0x02
    1d88:	fb 81       	ldd	r31, Y+3	; 0x03
    1d8a:	82 8d       	ldd	r24, Z+26	; 0x1a
    1d8c:	88 23       	and	r24, r24
    1d8e:	19 f4       	brne	.+6      	; 0x1d96 <prvIsQueueEmpty+0x26>
		{
			xReturn = pdTRUE;
    1d90:	81 e0       	ldi	r24, 0x01	; 1
    1d92:	89 83       	std	Y+1, r24	; 0x01
    1d94:	01 c0       	rjmp	.+2      	; 0x1d98 <prvIsQueueEmpty+0x28>
		}
		else
		{
			xReturn = pdFALSE;
    1d96:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    1d98:	0f 90       	pop	r0
    1d9a:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    1d9c:	89 81       	ldd	r24, Y+1	; 0x01
}
    1d9e:	0f 90       	pop	r0
    1da0:	0f 90       	pop	r0
    1da2:	0f 90       	pop	r0
    1da4:	cf 91       	pop	r28
    1da6:	df 91       	pop	r29
    1da8:	08 95       	ret

00001daa <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
    1daa:	df 93       	push	r29
    1dac:	cf 93       	push	r28
    1dae:	00 d0       	rcall	.+0      	; 0x1db0 <xQueueIsQueueEmptyFromISR+0x6>
    1db0:	00 d0       	rcall	.+0      	; 0x1db2 <xQueueIsQueueEmptyFromISR+0x8>
    1db2:	0f 92       	push	r0
    1db4:	cd b7       	in	r28, 0x3d	; 61
    1db6:	de b7       	in	r29, 0x3e	; 62
    1db8:	9d 83       	std	Y+5, r25	; 0x05
    1dba:	8c 83       	std	Y+4, r24	; 0x04
BaseType_t xReturn;
Queue_t * const pxQueue = xQueue;
    1dbc:	8c 81       	ldd	r24, Y+4	; 0x04
    1dbe:	9d 81       	ldd	r25, Y+5	; 0x05
    1dc0:	9a 83       	std	Y+2, r25	; 0x02
    1dc2:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );
	if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    1dc4:	e9 81       	ldd	r30, Y+1	; 0x01
    1dc6:	fa 81       	ldd	r31, Y+2	; 0x02
    1dc8:	82 8d       	ldd	r24, Z+26	; 0x1a
    1dca:	88 23       	and	r24, r24
    1dcc:	19 f4       	brne	.+6      	; 0x1dd4 <xQueueIsQueueEmptyFromISR+0x2a>
	{
		xReturn = pdTRUE;
    1dce:	81 e0       	ldi	r24, 0x01	; 1
    1dd0:	8b 83       	std	Y+3, r24	; 0x03
    1dd2:	01 c0       	rjmp	.+2      	; 0x1dd6 <xQueueIsQueueEmptyFromISR+0x2c>
	}
	else
	{
		xReturn = pdFALSE;
    1dd4:	1b 82       	std	Y+3, r1	; 0x03
	}

	return xReturn;
    1dd6:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    1dd8:	0f 90       	pop	r0
    1dda:	0f 90       	pop	r0
    1ddc:	0f 90       	pop	r0
    1dde:	0f 90       	pop	r0
    1de0:	0f 90       	pop	r0
    1de2:	cf 91       	pop	r28
    1de4:	df 91       	pop	r29
    1de6:	08 95       	ret

00001de8 <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
    1de8:	df 93       	push	r29
    1dea:	cf 93       	push	r28
    1dec:	00 d0       	rcall	.+0      	; 0x1dee <prvIsQueueFull+0x6>
    1dee:	0f 92       	push	r0
    1df0:	cd b7       	in	r28, 0x3d	; 61
    1df2:	de b7       	in	r29, 0x3e	; 62
    1df4:	9b 83       	std	Y+3, r25	; 0x03
    1df6:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	taskENTER_CRITICAL();
    1df8:	0f b6       	in	r0, 0x3f	; 63
    1dfa:	f8 94       	cli
    1dfc:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    1dfe:	ea 81       	ldd	r30, Y+2	; 0x02
    1e00:	fb 81       	ldd	r31, Y+3	; 0x03
    1e02:	92 8d       	ldd	r25, Z+26	; 0x1a
    1e04:	ea 81       	ldd	r30, Y+2	; 0x02
    1e06:	fb 81       	ldd	r31, Y+3	; 0x03
    1e08:	83 8d       	ldd	r24, Z+27	; 0x1b
    1e0a:	98 17       	cp	r25, r24
    1e0c:	19 f4       	brne	.+6      	; 0x1e14 <prvIsQueueFull+0x2c>
		{
			xReturn = pdTRUE;
    1e0e:	81 e0       	ldi	r24, 0x01	; 1
    1e10:	89 83       	std	Y+1, r24	; 0x01
    1e12:	01 c0       	rjmp	.+2      	; 0x1e16 <prvIsQueueFull+0x2e>
		}
		else
		{
			xReturn = pdFALSE;
    1e14:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    1e16:	0f 90       	pop	r0
    1e18:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    1e1a:	89 81       	ldd	r24, Y+1	; 0x01
}
    1e1c:	0f 90       	pop	r0
    1e1e:	0f 90       	pop	r0
    1e20:	0f 90       	pop	r0
    1e22:	cf 91       	pop	r28
    1e24:	df 91       	pop	r29
    1e26:	08 95       	ret

00001e28 <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
    1e28:	df 93       	push	r29
    1e2a:	cf 93       	push	r28
    1e2c:	00 d0       	rcall	.+0      	; 0x1e2e <xQueueIsQueueFullFromISR+0x6>
    1e2e:	00 d0       	rcall	.+0      	; 0x1e30 <xQueueIsQueueFullFromISR+0x8>
    1e30:	0f 92       	push	r0
    1e32:	cd b7       	in	r28, 0x3d	; 61
    1e34:	de b7       	in	r29, 0x3e	; 62
    1e36:	9d 83       	std	Y+5, r25	; 0x05
    1e38:	8c 83       	std	Y+4, r24	; 0x04
BaseType_t xReturn;
Queue_t * const pxQueue = xQueue;
    1e3a:	8c 81       	ldd	r24, Y+4	; 0x04
    1e3c:	9d 81       	ldd	r25, Y+5	; 0x05
    1e3e:	9a 83       	std	Y+2, r25	; 0x02
    1e40:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );
	if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    1e42:	e9 81       	ldd	r30, Y+1	; 0x01
    1e44:	fa 81       	ldd	r31, Y+2	; 0x02
    1e46:	92 8d       	ldd	r25, Z+26	; 0x1a
    1e48:	e9 81       	ldd	r30, Y+1	; 0x01
    1e4a:	fa 81       	ldd	r31, Y+2	; 0x02
    1e4c:	83 8d       	ldd	r24, Z+27	; 0x1b
    1e4e:	98 17       	cp	r25, r24
    1e50:	19 f4       	brne	.+6      	; 0x1e58 <xQueueIsQueueFullFromISR+0x30>
	{
		xReturn = pdTRUE;
    1e52:	81 e0       	ldi	r24, 0x01	; 1
    1e54:	8b 83       	std	Y+3, r24	; 0x03
    1e56:	01 c0       	rjmp	.+2      	; 0x1e5a <xQueueIsQueueFullFromISR+0x32>
	}
	else
	{
		xReturn = pdFALSE;
    1e58:	1b 82       	std	Y+3, r1	; 0x03
	}

	return xReturn;
    1e5a:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    1e5c:	0f 90       	pop	r0
    1e5e:	0f 90       	pop	r0
    1e60:	0f 90       	pop	r0
    1e62:	0f 90       	pop	r0
    1e64:	0f 90       	pop	r0
    1e66:	cf 91       	pop	r28
    1e68:	df 91       	pop	r29
    1e6a:	08 95       	ret

00001e6c <xStreamBufferGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	StreamBufferHandle_t xStreamBufferGenericCreate( size_t xBufferSizeBytes, size_t xTriggerLevelBytes, BaseType_t xIsMessageBuffer )
	{
    1e6c:	0f 93       	push	r16
    1e6e:	df 93       	push	r29
    1e70:	cf 93       	push	r28
    1e72:	cd b7       	in	r28, 0x3d	; 61
    1e74:	de b7       	in	r29, 0x3e	; 62
    1e76:	28 97       	sbiw	r28, 0x08	; 8
    1e78:	0f b6       	in	r0, 0x3f	; 63
    1e7a:	f8 94       	cli
    1e7c:	de bf       	out	0x3e, r29	; 62
    1e7e:	0f be       	out	0x3f, r0	; 63
    1e80:	cd bf       	out	0x3d, r28	; 61
    1e82:	9d 83       	std	Y+5, r25	; 0x05
    1e84:	8c 83       	std	Y+4, r24	; 0x04
    1e86:	7f 83       	std	Y+7, r23	; 0x07
    1e88:	6e 83       	std	Y+6, r22	; 0x06
    1e8a:	48 87       	std	Y+8, r20	; 0x08

		/* In case the stream buffer is going to be used as a message buffer
		(that is, it will hold discrete messages with a little meta data that
		says how big the next message is) check the buffer will be large enough
		to hold at least one message. */
		if( xIsMessageBuffer == pdTRUE )
    1e8c:	88 85       	ldd	r24, Y+8	; 0x08
    1e8e:	81 30       	cpi	r24, 0x01	; 1
    1e90:	19 f4       	brne	.+6      	; 0x1e98 <xStreamBufferGenericCreate+0x2c>
		{
			/* Is a message buffer but not statically allocated. */
			ucFlags = sbFLAGS_IS_MESSAGE_BUFFER;
    1e92:	81 e0       	ldi	r24, 0x01	; 1
    1e94:	89 83       	std	Y+1, r24	; 0x01
    1e96:	01 c0       	rjmp	.+2      	; 0x1e9a <xStreamBufferGenericCreate+0x2e>
			configASSERT( xBufferSizeBytes > sbBYTES_TO_STORE_MESSAGE_LENGTH );
		}
		else
		{
			/* Not a message buffer and not statically allocated. */
			ucFlags = 0;
    1e98:	19 82       	std	Y+1, r1	; 0x01
		}
		configASSERT( xTriggerLevelBytes <= xBufferSizeBytes );

		/* A trigger level of 0 would cause a waiting task to unblock even when
		the buffer was empty. */
		if( xTriggerLevelBytes == ( size_t ) 0 )
    1e9a:	8e 81       	ldd	r24, Y+6	; 0x06
    1e9c:	9f 81       	ldd	r25, Y+7	; 0x07
    1e9e:	00 97       	sbiw	r24, 0x00	; 0
    1ea0:	21 f4       	brne	.+8      	; 0x1eaa <xStreamBufferGenericCreate+0x3e>
		{
			xTriggerLevelBytes = ( size_t ) 1;
    1ea2:	81 e0       	ldi	r24, 0x01	; 1
    1ea4:	90 e0       	ldi	r25, 0x00	; 0
    1ea6:	9f 83       	std	Y+7, r25	; 0x07
    1ea8:	8e 83       	std	Y+6, r24	; 0x06
		and the buffer follows immediately after.  The requested size is
		incremented so the free space is returned as the user would expect -
		this is a quirk of the implementation that means otherwise the free
		space would be reported as one byte smaller than would be logically
		expected. */
		xBufferSizeBytes++;
    1eaa:	8c 81       	ldd	r24, Y+4	; 0x04
    1eac:	9d 81       	ldd	r25, Y+5	; 0x05
    1eae:	01 96       	adiw	r24, 0x01	; 1
    1eb0:	9d 83       	std	Y+5, r25	; 0x05
    1eb2:	8c 83       	std	Y+4, r24	; 0x04
		pucAllocatedMemory = ( uint8_t * ) pvPortMalloc( xBufferSizeBytes + sizeof( StreamBuffer_t ) ); /*lint !e9079 malloc() only returns void*. */
    1eb4:	8c 81       	ldd	r24, Y+4	; 0x04
    1eb6:	9d 81       	ldd	r25, Y+5	; 0x05
    1eb8:	0f 96       	adiw	r24, 0x0f	; 15
    1eba:	0e 94 62 06 	call	0xcc4	; 0xcc4 <pvPortMalloc>
    1ebe:	9b 83       	std	Y+3, r25	; 0x03
    1ec0:	8a 83       	std	Y+2, r24	; 0x02

		if( pucAllocatedMemory != NULL )
    1ec2:	8a 81       	ldd	r24, Y+2	; 0x02
    1ec4:	9b 81       	ldd	r25, Y+3	; 0x03
    1ec6:	00 97       	sbiw	r24, 0x00	; 0
    1ec8:	89 f0       	breq	.+34     	; 0x1eec <xStreamBufferGenericCreate+0x80>
		{
			prvInitialiseNewStreamBuffer( ( StreamBuffer_t * ) pucAllocatedMemory, /* Structure at the start of the allocated memory. */ /*lint !e9087 Safe cast as allocated memory is aligned. */ /*lint !e826 Area is not too small and alignment is guaranteed provided malloc() behaves as expected and returns aligned buffer. */
    1eca:	6a 81       	ldd	r22, Y+2	; 0x02
    1ecc:	7b 81       	ldd	r23, Y+3	; 0x03
    1ece:	8a 81       	ldd	r24, Y+2	; 0x02
    1ed0:	9b 81       	ldd	r25, Y+3	; 0x03
    1ed2:	9c 01       	movw	r18, r24
    1ed4:	21 5f       	subi	r18, 0xF1	; 241
    1ed6:	3f 4f       	sbci	r19, 0xFF	; 255
    1ed8:	4c 81       	ldd	r20, Y+4	; 0x04
    1eda:	5d 81       	ldd	r21, Y+5	; 0x05
    1edc:	ee 81       	ldd	r30, Y+6	; 0x06
    1ede:	ff 81       	ldd	r31, Y+7	; 0x07
    1ee0:	cb 01       	movw	r24, r22
    1ee2:	b9 01       	movw	r22, r18
    1ee4:	9f 01       	movw	r18, r30
    1ee6:	09 81       	ldd	r16, Y+1	; 0x01
    1ee8:	0e 94 8e 16 	call	0x2d1c	; 0x2d1c <prvInitialiseNewStreamBuffer>
		else
		{
			traceSTREAM_BUFFER_CREATE_FAILED( xIsMessageBuffer );
		}

		return ( StreamBufferHandle_t ) pucAllocatedMemory; /*lint !e9087 !e826 Safe cast as allocated memory is aligned. */
    1eec:	8a 81       	ldd	r24, Y+2	; 0x02
    1eee:	9b 81       	ldd	r25, Y+3	; 0x03
	}
    1ef0:	28 96       	adiw	r28, 0x08	; 8
    1ef2:	0f b6       	in	r0, 0x3f	; 63
    1ef4:	f8 94       	cli
    1ef6:	de bf       	out	0x3e, r29	; 62
    1ef8:	0f be       	out	0x3f, r0	; 63
    1efa:	cd bf       	out	0x3d, r28	; 61
    1efc:	cf 91       	pop	r28
    1efe:	df 91       	pop	r29
    1f00:	0f 91       	pop	r16
    1f02:	08 95       	ret

00001f04 <vStreamBufferDelete>:

#endif /* ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
/*-----------------------------------------------------------*/

void vStreamBufferDelete( StreamBufferHandle_t xStreamBuffer )
{
    1f04:	df 93       	push	r29
    1f06:	cf 93       	push	r28
    1f08:	00 d0       	rcall	.+0      	; 0x1f0a <vStreamBufferDelete+0x6>
    1f0a:	00 d0       	rcall	.+0      	; 0x1f0c <vStreamBufferDelete+0x8>
    1f0c:	cd b7       	in	r28, 0x3d	; 61
    1f0e:	de b7       	in	r29, 0x3e	; 62
    1f10:	9c 83       	std	Y+4, r25	; 0x04
    1f12:	8b 83       	std	Y+3, r24	; 0x03
StreamBuffer_t * pxStreamBuffer = xStreamBuffer;
    1f14:	8b 81       	ldd	r24, Y+3	; 0x03
    1f16:	9c 81       	ldd	r25, Y+4	; 0x04
    1f18:	9a 83       	std	Y+2, r25	; 0x02
    1f1a:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxStreamBuffer );

	traceSTREAM_BUFFER_DELETE( xStreamBuffer );

	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) pdFALSE )
    1f1c:	e9 81       	ldd	r30, Y+1	; 0x01
    1f1e:	fa 81       	ldd	r31, Y+2	; 0x02
    1f20:	86 85       	ldd	r24, Z+14	; 0x0e
    1f22:	88 2f       	mov	r24, r24
    1f24:	90 e0       	ldi	r25, 0x00	; 0
    1f26:	82 70       	andi	r24, 0x02	; 2
    1f28:	90 70       	andi	r25, 0x00	; 0
    1f2a:	00 97       	sbiw	r24, 0x00	; 0
    1f2c:	29 f4       	brne	.+10     	; 0x1f38 <vStreamBufferDelete+0x34>
	{
		#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
		{
			/* Both the structure and the buffer were allocated using a single call
			to pvPortMalloc(), hence only one call to vPortFree() is required. */
			vPortFree( ( void * ) pxStreamBuffer ); /*lint !e9087 Standard free() semantics require void *, plus pxStreamBuffer was allocated by pvPortMalloc(). */
    1f2e:	89 81       	ldd	r24, Y+1	; 0x01
    1f30:	9a 81       	ldd	r25, Y+2	; 0x02
    1f32:	0e 94 b8 06 	call	0xd70	; 0xd70 <vPortFree>
    1f36:	08 c0       	rjmp	.+16     	; 0x1f48 <vStreamBufferDelete+0x44>
	}
	else
	{
		/* The structure and buffer were not allocated dynamically and cannot be
		freed - just scrub the structure so future use will assert. */
		( void ) memset( pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) );
    1f38:	89 81       	ldd	r24, Y+1	; 0x01
    1f3a:	9a 81       	ldd	r25, Y+2	; 0x02
    1f3c:	60 e0       	ldi	r22, 0x00	; 0
    1f3e:	70 e0       	ldi	r23, 0x00	; 0
    1f40:	4f e0       	ldi	r20, 0x0F	; 15
    1f42:	50 e0       	ldi	r21, 0x00	; 0
    1f44:	0e 94 90 24 	call	0x4920	; 0x4920 <memset>
	}
}
    1f48:	0f 90       	pop	r0
    1f4a:	0f 90       	pop	r0
    1f4c:	0f 90       	pop	r0
    1f4e:	0f 90       	pop	r0
    1f50:	cf 91       	pop	r28
    1f52:	df 91       	pop	r29
    1f54:	08 95       	ret

00001f56 <xStreamBufferReset>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferReset( StreamBufferHandle_t xStreamBuffer )
{
    1f56:	0f 93       	push	r16
    1f58:	df 93       	push	r29
    1f5a:	cf 93       	push	r28
    1f5c:	00 d0       	rcall	.+0      	; 0x1f5e <xStreamBufferReset+0x8>
    1f5e:	00 d0       	rcall	.+0      	; 0x1f60 <xStreamBufferReset+0xa>
    1f60:	0f 92       	push	r0
    1f62:	cd b7       	in	r28, 0x3d	; 61
    1f64:	de b7       	in	r29, 0x3e	; 62
    1f66:	9d 83       	std	Y+5, r25	; 0x05
    1f68:	8c 83       	std	Y+4, r24	; 0x04
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    1f6a:	8c 81       	ldd	r24, Y+4	; 0x04
    1f6c:	9d 81       	ldd	r25, Y+5	; 0x05
    1f6e:	9b 83       	std	Y+3, r25	; 0x03
    1f70:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn = pdFAIL;
    1f72:	19 82       	std	Y+1, r1	; 0x01
		uxStreamBufferNumber = pxStreamBuffer->uxStreamBufferNumber;
	}
	#endif

	/* Can only reset a message buffer if there are no tasks blocked on it. */
	taskENTER_CRITICAL();
    1f74:	0f b6       	in	r0, 0x3f	; 63
    1f76:	f8 94       	cli
    1f78:	0f 92       	push	r0
	{
		if( pxStreamBuffer->xTaskWaitingToReceive == NULL )
    1f7a:	ea 81       	ldd	r30, Y+2	; 0x02
    1f7c:	fb 81       	ldd	r31, Y+3	; 0x03
    1f7e:	80 85       	ldd	r24, Z+8	; 0x08
    1f80:	91 85       	ldd	r25, Z+9	; 0x09
    1f82:	00 97       	sbiw	r24, 0x00	; 0
    1f84:	f1 f4       	brne	.+60     	; 0x1fc2 <xStreamBufferReset+0x6c>
		{
			if( pxStreamBuffer->xTaskWaitingToSend == NULL )
    1f86:	ea 81       	ldd	r30, Y+2	; 0x02
    1f88:	fb 81       	ldd	r31, Y+3	; 0x03
    1f8a:	82 85       	ldd	r24, Z+10	; 0x0a
    1f8c:	93 85       	ldd	r25, Z+11	; 0x0b
    1f8e:	00 97       	sbiw	r24, 0x00	; 0
    1f90:	c1 f4       	brne	.+48     	; 0x1fc2 <xStreamBufferReset+0x6c>
			{
				prvInitialiseNewStreamBuffer( pxStreamBuffer,
    1f92:	ea 81       	ldd	r30, Y+2	; 0x02
    1f94:	fb 81       	ldd	r31, Y+3	; 0x03
    1f96:	24 85       	ldd	r18, Z+12	; 0x0c
    1f98:	35 85       	ldd	r19, Z+13	; 0x0d
    1f9a:	ea 81       	ldd	r30, Y+2	; 0x02
    1f9c:	fb 81       	ldd	r31, Y+3	; 0x03
    1f9e:	44 81       	ldd	r20, Z+4	; 0x04
    1fa0:	55 81       	ldd	r21, Z+5	; 0x05
    1fa2:	ea 81       	ldd	r30, Y+2	; 0x02
    1fa4:	fb 81       	ldd	r31, Y+3	; 0x03
    1fa6:	a6 81       	ldd	r26, Z+6	; 0x06
    1fa8:	b7 81       	ldd	r27, Z+7	; 0x07
    1faa:	ea 81       	ldd	r30, Y+2	; 0x02
    1fac:	fb 81       	ldd	r31, Y+3	; 0x03
    1fae:	e6 85       	ldd	r30, Z+14	; 0x0e
    1fb0:	8a 81       	ldd	r24, Y+2	; 0x02
    1fb2:	9b 81       	ldd	r25, Y+3	; 0x03
    1fb4:	b9 01       	movw	r22, r18
    1fb6:	9d 01       	movw	r18, r26
    1fb8:	0e 2f       	mov	r16, r30
    1fba:	0e 94 8e 16 	call	0x2d1c	; 0x2d1c <prvInitialiseNewStreamBuffer>
											  pxStreamBuffer->pucBuffer,
											  pxStreamBuffer->xLength,
											  pxStreamBuffer->xTriggerLevelBytes,
											  pxStreamBuffer->ucFlags );
				xReturn = pdPASS;
    1fbe:	81 e0       	ldi	r24, 0x01	; 1
    1fc0:	89 83       	std	Y+1, r24	; 0x01

				traceSTREAM_BUFFER_RESET( xStreamBuffer );
			}
		}
	}
	taskEXIT_CRITICAL();
    1fc2:	0f 90       	pop	r0
    1fc4:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    1fc6:	89 81       	ldd	r24, Y+1	; 0x01
}
    1fc8:	0f 90       	pop	r0
    1fca:	0f 90       	pop	r0
    1fcc:	0f 90       	pop	r0
    1fce:	0f 90       	pop	r0
    1fd0:	0f 90       	pop	r0
    1fd2:	cf 91       	pop	r28
    1fd4:	df 91       	pop	r29
    1fd6:	0f 91       	pop	r16
    1fd8:	08 95       	ret

00001fda <xStreamBufferSetTriggerLevel>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferSetTriggerLevel( StreamBufferHandle_t xStreamBuffer, size_t xTriggerLevel )
{
    1fda:	df 93       	push	r29
    1fdc:	cf 93       	push	r28
    1fde:	cd b7       	in	r28, 0x3d	; 61
    1fe0:	de b7       	in	r29, 0x3e	; 62
    1fe2:	27 97       	sbiw	r28, 0x07	; 7
    1fe4:	0f b6       	in	r0, 0x3f	; 63
    1fe6:	f8 94       	cli
    1fe8:	de bf       	out	0x3e, r29	; 62
    1fea:	0f be       	out	0x3f, r0	; 63
    1fec:	cd bf       	out	0x3d, r28	; 61
    1fee:	9d 83       	std	Y+5, r25	; 0x05
    1ff0:	8c 83       	std	Y+4, r24	; 0x04
    1ff2:	7f 83       	std	Y+7, r23	; 0x07
    1ff4:	6e 83       	std	Y+6, r22	; 0x06
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    1ff6:	8c 81       	ldd	r24, Y+4	; 0x04
    1ff8:	9d 81       	ldd	r25, Y+5	; 0x05
    1ffa:	9b 83       	std	Y+3, r25	; 0x03
    1ffc:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	configASSERT( pxStreamBuffer );

	/* It is not valid for the trigger level to be 0. */
	if( xTriggerLevel == ( size_t ) 0 )
    1ffe:	8e 81       	ldd	r24, Y+6	; 0x06
    2000:	9f 81       	ldd	r25, Y+7	; 0x07
    2002:	00 97       	sbiw	r24, 0x00	; 0
    2004:	21 f4       	brne	.+8      	; 0x200e <xStreamBufferSetTriggerLevel+0x34>
	{
		xTriggerLevel = ( size_t ) 1;
    2006:	81 e0       	ldi	r24, 0x01	; 1
    2008:	90 e0       	ldi	r25, 0x00	; 0
    200a:	9f 83       	std	Y+7, r25	; 0x07
    200c:	8e 83       	std	Y+6, r24	; 0x06
	}

	/* The trigger level is the number of bytes that must be in the stream
	buffer before a task that is waiting for data is unblocked. */
	if( xTriggerLevel <= pxStreamBuffer->xLength )
    200e:	ea 81       	ldd	r30, Y+2	; 0x02
    2010:	fb 81       	ldd	r31, Y+3	; 0x03
    2012:	24 81       	ldd	r18, Z+4	; 0x04
    2014:	35 81       	ldd	r19, Z+5	; 0x05
    2016:	8e 81       	ldd	r24, Y+6	; 0x06
    2018:	9f 81       	ldd	r25, Y+7	; 0x07
    201a:	28 17       	cp	r18, r24
    201c:	39 07       	cpc	r19, r25
    201e:	48 f0       	brcs	.+18     	; 0x2032 <xStreamBufferSetTriggerLevel+0x58>
	{
		pxStreamBuffer->xTriggerLevelBytes = xTriggerLevel;
    2020:	ea 81       	ldd	r30, Y+2	; 0x02
    2022:	fb 81       	ldd	r31, Y+3	; 0x03
    2024:	8e 81       	ldd	r24, Y+6	; 0x06
    2026:	9f 81       	ldd	r25, Y+7	; 0x07
    2028:	97 83       	std	Z+7, r25	; 0x07
    202a:	86 83       	std	Z+6, r24	; 0x06
		xReturn = pdPASS;
    202c:	81 e0       	ldi	r24, 0x01	; 1
    202e:	89 83       	std	Y+1, r24	; 0x01
    2030:	01 c0       	rjmp	.+2      	; 0x2034 <xStreamBufferSetTriggerLevel+0x5a>
	}
	else
	{
		xReturn = pdFALSE;
    2032:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    2034:	89 81       	ldd	r24, Y+1	; 0x01
}
    2036:	27 96       	adiw	r28, 0x07	; 7
    2038:	0f b6       	in	r0, 0x3f	; 63
    203a:	f8 94       	cli
    203c:	de bf       	out	0x3e, r29	; 62
    203e:	0f be       	out	0x3f, r0	; 63
    2040:	cd bf       	out	0x3d, r28	; 61
    2042:	cf 91       	pop	r28
    2044:	df 91       	pop	r29
    2046:	08 95       	ret

00002048 <xStreamBufferSpacesAvailable>:
/*-----------------------------------------------------------*/

size_t xStreamBufferSpacesAvailable( StreamBufferHandle_t xStreamBuffer )
{
    2048:	df 93       	push	r29
    204a:	cf 93       	push	r28
    204c:	00 d0       	rcall	.+0      	; 0x204e <xStreamBufferSpacesAvailable+0x6>
    204e:	00 d0       	rcall	.+0      	; 0x2050 <xStreamBufferSpacesAvailable+0x8>
    2050:	00 d0       	rcall	.+0      	; 0x2052 <xStreamBufferSpacesAvailable+0xa>
    2052:	cd b7       	in	r28, 0x3d	; 61
    2054:	de b7       	in	r29, 0x3e	; 62
    2056:	9e 83       	std	Y+6, r25	; 0x06
    2058:	8d 83       	std	Y+5, r24	; 0x05
const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    205a:	8d 81       	ldd	r24, Y+5	; 0x05
    205c:	9e 81       	ldd	r25, Y+6	; 0x06
    205e:	9c 83       	std	Y+4, r25	; 0x04
    2060:	8b 83       	std	Y+3, r24	; 0x03
size_t xSpace;

	configASSERT( pxStreamBuffer );

	xSpace = pxStreamBuffer->xLength + pxStreamBuffer->xTail;
    2062:	eb 81       	ldd	r30, Y+3	; 0x03
    2064:	fc 81       	ldd	r31, Y+4	; 0x04
    2066:	24 81       	ldd	r18, Z+4	; 0x04
    2068:	35 81       	ldd	r19, Z+5	; 0x05
    206a:	eb 81       	ldd	r30, Y+3	; 0x03
    206c:	fc 81       	ldd	r31, Y+4	; 0x04
    206e:	80 81       	ld	r24, Z
    2070:	91 81       	ldd	r25, Z+1	; 0x01
    2072:	82 0f       	add	r24, r18
    2074:	93 1f       	adc	r25, r19
    2076:	9a 83       	std	Y+2, r25	; 0x02
    2078:	89 83       	std	Y+1, r24	; 0x01
	xSpace -= pxStreamBuffer->xHead;
    207a:	eb 81       	ldd	r30, Y+3	; 0x03
    207c:	fc 81       	ldd	r31, Y+4	; 0x04
    207e:	22 81       	ldd	r18, Z+2	; 0x02
    2080:	33 81       	ldd	r19, Z+3	; 0x03
    2082:	89 81       	ldd	r24, Y+1	; 0x01
    2084:	9a 81       	ldd	r25, Y+2	; 0x02
    2086:	82 1b       	sub	r24, r18
    2088:	93 0b       	sbc	r25, r19
    208a:	9a 83       	std	Y+2, r25	; 0x02
    208c:	89 83       	std	Y+1, r24	; 0x01
	xSpace -= ( size_t ) 1;
    208e:	89 81       	ldd	r24, Y+1	; 0x01
    2090:	9a 81       	ldd	r25, Y+2	; 0x02
    2092:	01 97       	sbiw	r24, 0x01	; 1
    2094:	9a 83       	std	Y+2, r25	; 0x02
    2096:	89 83       	std	Y+1, r24	; 0x01

	if( xSpace >= pxStreamBuffer->xLength )
    2098:	eb 81       	ldd	r30, Y+3	; 0x03
    209a:	fc 81       	ldd	r31, Y+4	; 0x04
    209c:	24 81       	ldd	r18, Z+4	; 0x04
    209e:	35 81       	ldd	r19, Z+5	; 0x05
    20a0:	89 81       	ldd	r24, Y+1	; 0x01
    20a2:	9a 81       	ldd	r25, Y+2	; 0x02
    20a4:	82 17       	cp	r24, r18
    20a6:	93 07       	cpc	r25, r19
    20a8:	50 f0       	brcs	.+20     	; 0x20be <xStreamBufferSpacesAvailable+0x76>
	{
		xSpace -= pxStreamBuffer->xLength;
    20aa:	eb 81       	ldd	r30, Y+3	; 0x03
    20ac:	fc 81       	ldd	r31, Y+4	; 0x04
    20ae:	24 81       	ldd	r18, Z+4	; 0x04
    20b0:	35 81       	ldd	r19, Z+5	; 0x05
    20b2:	89 81       	ldd	r24, Y+1	; 0x01
    20b4:	9a 81       	ldd	r25, Y+2	; 0x02
    20b6:	82 1b       	sub	r24, r18
    20b8:	93 0b       	sbc	r25, r19
    20ba:	9a 83       	std	Y+2, r25	; 0x02
    20bc:	89 83       	std	Y+1, r24	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xSpace;
    20be:	89 81       	ldd	r24, Y+1	; 0x01
    20c0:	9a 81       	ldd	r25, Y+2	; 0x02
}
    20c2:	26 96       	adiw	r28, 0x06	; 6
    20c4:	0f b6       	in	r0, 0x3f	; 63
    20c6:	f8 94       	cli
    20c8:	de bf       	out	0x3e, r29	; 62
    20ca:	0f be       	out	0x3f, r0	; 63
    20cc:	cd bf       	out	0x3d, r28	; 61
    20ce:	cf 91       	pop	r28
    20d0:	df 91       	pop	r29
    20d2:	08 95       	ret

000020d4 <xStreamBufferBytesAvailable>:
/*-----------------------------------------------------------*/

size_t xStreamBufferBytesAvailable( StreamBufferHandle_t xStreamBuffer )
{
    20d4:	df 93       	push	r29
    20d6:	cf 93       	push	r28
    20d8:	00 d0       	rcall	.+0      	; 0x20da <xStreamBufferBytesAvailable+0x6>
    20da:	00 d0       	rcall	.+0      	; 0x20dc <xStreamBufferBytesAvailable+0x8>
    20dc:	00 d0       	rcall	.+0      	; 0x20de <xStreamBufferBytesAvailable+0xa>
    20de:	cd b7       	in	r28, 0x3d	; 61
    20e0:	de b7       	in	r29, 0x3e	; 62
    20e2:	9e 83       	std	Y+6, r25	; 0x06
    20e4:	8d 83       	std	Y+5, r24	; 0x05
const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    20e6:	8d 81       	ldd	r24, Y+5	; 0x05
    20e8:	9e 81       	ldd	r25, Y+6	; 0x06
    20ea:	9c 83       	std	Y+4, r25	; 0x04
    20ec:	8b 83       	std	Y+3, r24	; 0x03
size_t xReturn;

	configASSERT( pxStreamBuffer );

	xReturn = prvBytesInBuffer( pxStreamBuffer );
    20ee:	8b 81       	ldd	r24, Y+3	; 0x03
    20f0:	9c 81       	ldd	r25, Y+4	; 0x04
    20f2:	0e 94 54 16 	call	0x2ca8	; 0x2ca8 <prvBytesInBuffer>
    20f6:	9a 83       	std	Y+2, r25	; 0x02
    20f8:	89 83       	std	Y+1, r24	; 0x01
	return xReturn;
    20fa:	89 81       	ldd	r24, Y+1	; 0x01
    20fc:	9a 81       	ldd	r25, Y+2	; 0x02
}
    20fe:	26 96       	adiw	r28, 0x06	; 6
    2100:	0f b6       	in	r0, 0x3f	; 63
    2102:	f8 94       	cli
    2104:	de bf       	out	0x3e, r29	; 62
    2106:	0f be       	out	0x3f, r0	; 63
    2108:	cd bf       	out	0x3d, r28	; 61
    210a:	cf 91       	pop	r28
    210c:	df 91       	pop	r29
    210e:	08 95       	ret

00002110 <xStreamBufferSend>:

size_t xStreamBufferSend( StreamBufferHandle_t xStreamBuffer,
						  const void *pvTxData,
						  size_t xDataLengthBytes,
						  TickType_t xTicksToWait )
{
    2110:	ef 92       	push	r14
    2112:	ff 92       	push	r15
    2114:	0f 93       	push	r16
    2116:	1f 93       	push	r17
    2118:	df 93       	push	r29
    211a:	cf 93       	push	r28
    211c:	cd b7       	in	r28, 0x3d	; 61
    211e:	de b7       	in	r29, 0x3e	; 62
    2120:	63 97       	sbiw	r28, 0x13	; 19
    2122:	0f b6       	in	r0, 0x3f	; 63
    2124:	f8 94       	cli
    2126:	de bf       	out	0x3e, r29	; 62
    2128:	0f be       	out	0x3f, r0	; 63
    212a:	cd bf       	out	0x3d, r28	; 61
    212c:	9d 87       	std	Y+13, r25	; 0x0d
    212e:	8c 87       	std	Y+12, r24	; 0x0c
    2130:	7f 87       	std	Y+15, r23	; 0x0f
    2132:	6e 87       	std	Y+14, r22	; 0x0e
    2134:	59 8b       	std	Y+17, r21	; 0x11
    2136:	48 8b       	std	Y+16, r20	; 0x10
    2138:	3b 8b       	std	Y+19, r19	; 0x13
    213a:	2a 8b       	std	Y+18, r18	; 0x12
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    213c:	8c 85       	ldd	r24, Y+12	; 0x0c
    213e:	9d 85       	ldd	r25, Y+13	; 0x0d
    2140:	98 87       	std	Y+8, r25	; 0x08
    2142:	8f 83       	std	Y+7, r24	; 0x07
size_t xReturn, xSpace = 0;
    2144:	1c 82       	std	Y+4, r1	; 0x04
    2146:	1b 82       	std	Y+3, r1	; 0x03
size_t xRequiredSpace = xDataLengthBytes;
    2148:	88 89       	ldd	r24, Y+16	; 0x10
    214a:	99 89       	ldd	r25, Y+17	; 0x11
    214c:	9a 83       	std	Y+2, r25	; 0x02
    214e:	89 83       	std	Y+1, r24	; 0x01

	/* This send function is used to write to both message buffers and stream
	buffers.  If this is a message buffer then the space needed must be
	increased by the amount of bytes needed to store the length of the
	message. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    2150:	ef 81       	ldd	r30, Y+7	; 0x07
    2152:	f8 85       	ldd	r31, Y+8	; 0x08
    2154:	86 85       	ldd	r24, Z+14	; 0x0e
    2156:	88 2f       	mov	r24, r24
    2158:	90 e0       	ldi	r25, 0x00	; 0
    215a:	81 70       	andi	r24, 0x01	; 1
    215c:	90 70       	andi	r25, 0x00	; 0
    215e:	88 23       	and	r24, r24
    2160:	29 f0       	breq	.+10     	; 0x216c <xStreamBufferSend+0x5c>
	{
		xRequiredSpace += sbBYTES_TO_STORE_MESSAGE_LENGTH;
    2162:	89 81       	ldd	r24, Y+1	; 0x01
    2164:	9a 81       	ldd	r25, Y+2	; 0x02
    2166:	02 96       	adiw	r24, 0x02	; 2
    2168:	9a 83       	std	Y+2, r25	; 0x02
    216a:	89 83       	std	Y+1, r24	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	if( xTicksToWait != ( TickType_t ) 0 )
    216c:	8a 89       	ldd	r24, Y+18	; 0x12
    216e:	9b 89       	ldd	r25, Y+19	; 0x13
    2170:	00 97       	sbiw	r24, 0x00	; 0
    2172:	09 f4       	brne	.+2      	; 0x2176 <xStreamBufferSend+0x66>
    2174:	40 c0       	rjmp	.+128    	; 0x21f6 <xStreamBufferSend+0xe6>
	{
		vTaskSetTimeOutState( &xTimeOut );
    2176:	ce 01       	movw	r24, r28
    2178:	09 96       	adiw	r24, 0x09	; 9
    217a:	0e 94 1d 1e 	call	0x3c3a	; 0x3c3a <vTaskSetTimeOutState>

		do
		{
			/* Wait until the required number of bytes are free in the message
			buffer. */
			taskENTER_CRITICAL();
    217e:	0f b6       	in	r0, 0x3f	; 63
    2180:	f8 94       	cli
    2182:	0f 92       	push	r0
			{
				xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
    2184:	8f 81       	ldd	r24, Y+7	; 0x07
    2186:	98 85       	ldd	r25, Y+8	; 0x08
    2188:	0e 94 24 10 	call	0x2048	; 0x2048 <xStreamBufferSpacesAvailable>
    218c:	9c 83       	std	Y+4, r25	; 0x04
    218e:	8b 83       	std	Y+3, r24	; 0x03

				if( xSpace < xRequiredSpace )
    2190:	2b 81       	ldd	r18, Y+3	; 0x03
    2192:	3c 81       	ldd	r19, Y+4	; 0x04
    2194:	89 81       	ldd	r24, Y+1	; 0x01
    2196:	9a 81       	ldd	r25, Y+2	; 0x02
    2198:	28 17       	cp	r18, r24
    219a:	39 07       	cpc	r19, r25
    219c:	50 f5       	brcc	.+84     	; 0x21f2 <xStreamBufferSend+0xe2>
				{
					/* Clear notification state as going to wait for space. */
					( void ) xTaskNotifyStateClear( NULL );
    219e:	80 e0       	ldi	r24, 0x00	; 0
    21a0:	90 e0       	ldi	r25, 0x00	; 0
    21a2:	0e 94 2d 23 	call	0x465a	; 0x465a <xTaskNotifyStateClear>

					/* Should only be one writer. */
					configASSERT( pxStreamBuffer->xTaskWaitingToSend == NULL );
					pxStreamBuffer->xTaskWaitingToSend = xTaskGetCurrentTaskHandle();
    21a6:	0e 94 86 1f 	call	0x3f0c	; 0x3f0c <xTaskGetCurrentTaskHandle>
    21aa:	ef 81       	ldd	r30, Y+7	; 0x07
    21ac:	f8 85       	ldd	r31, Y+8	; 0x08
    21ae:	93 87       	std	Z+11, r25	; 0x0b
    21b0:	82 87       	std	Z+10, r24	; 0x0a
				{
					taskEXIT_CRITICAL();
					break;
				}
			}
			taskEXIT_CRITICAL();
    21b2:	0f 90       	pop	r0
    21b4:	0f be       	out	0x3f, r0	; 63

			traceBLOCKING_ON_STREAM_BUFFER_SEND( xStreamBuffer );
			( void ) xTaskNotifyWait( ( uint32_t ) 0, ( uint32_t ) 0, NULL, xTicksToWait );
    21b6:	ea 89       	ldd	r30, Y+18	; 0x12
    21b8:	fb 89       	ldd	r31, Y+19	; 0x13
    21ba:	60 e0       	ldi	r22, 0x00	; 0
    21bc:	70 e0       	ldi	r23, 0x00	; 0
    21be:	80 e0       	ldi	r24, 0x00	; 0
    21c0:	90 e0       	ldi	r25, 0x00	; 0
    21c2:	20 e0       	ldi	r18, 0x00	; 0
    21c4:	30 e0       	ldi	r19, 0x00	; 0
    21c6:	40 e0       	ldi	r20, 0x00	; 0
    21c8:	50 e0       	ldi	r21, 0x00	; 0
    21ca:	00 e0       	ldi	r16, 0x00	; 0
    21cc:	10 e0       	ldi	r17, 0x00	; 0
    21ce:	7f 01       	movw	r14, r30
    21d0:	0e 94 36 20 	call	0x406c	; 0x406c <xTaskNotifyWait>
			pxStreamBuffer->xTaskWaitingToSend = NULL;
    21d4:	ef 81       	ldd	r30, Y+7	; 0x07
    21d6:	f8 85       	ldd	r31, Y+8	; 0x08
    21d8:	13 86       	std	Z+11, r1	; 0x0b
    21da:	12 86       	std	Z+10, r1	; 0x0a

		} while( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE );
    21dc:	ce 01       	movw	r24, r28
    21de:	09 96       	adiw	r24, 0x09	; 9
    21e0:	9e 01       	movw	r18, r28
    21e2:	2e 5e       	subi	r18, 0xEE	; 238
    21e4:	3f 4f       	sbci	r19, 0xFF	; 255
    21e6:	b9 01       	movw	r22, r18
    21e8:	0e 94 54 1e 	call	0x3ca8	; 0x3ca8 <xTaskCheckForTimeOut>
    21ec:	88 23       	and	r24, r24
    21ee:	39 f2       	breq	.-114    	; 0x217e <xStreamBufferSend+0x6e>
    21f0:	02 c0       	rjmp	.+4      	; 0x21f6 <xStreamBufferSend+0xe6>
					configASSERT( pxStreamBuffer->xTaskWaitingToSend == NULL );
					pxStreamBuffer->xTaskWaitingToSend = xTaskGetCurrentTaskHandle();
				}
				else
				{
					taskEXIT_CRITICAL();
    21f2:	0f 90       	pop	r0
    21f4:	0f be       	out	0x3f, r0	; 63
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	if( xSpace == ( size_t ) 0 )
    21f6:	8b 81       	ldd	r24, Y+3	; 0x03
    21f8:	9c 81       	ldd	r25, Y+4	; 0x04
    21fa:	00 97       	sbiw	r24, 0x00	; 0
    21fc:	31 f4       	brne	.+12     	; 0x220a <xStreamBufferSend+0xfa>
	{
		xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
    21fe:	8f 81       	ldd	r24, Y+7	; 0x07
    2200:	98 85       	ldd	r25, Y+8	; 0x08
    2202:	0e 94 24 10 	call	0x2048	; 0x2048 <xStreamBufferSpacesAvailable>
    2206:	9c 83       	std	Y+4, r25	; 0x04
    2208:	8b 83       	std	Y+3, r24	; 0x03
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	xReturn = prvWriteMessageToBuffer( pxStreamBuffer, pvTxData, xDataLengthBytes, xSpace, xRequiredSpace );
    220a:	8f 81       	ldd	r24, Y+7	; 0x07
    220c:	98 85       	ldd	r25, Y+8	; 0x08
    220e:	2e 85       	ldd	r18, Y+14	; 0x0e
    2210:	3f 85       	ldd	r19, Y+15	; 0x0f
    2212:	48 89       	ldd	r20, Y+16	; 0x10
    2214:	59 89       	ldd	r21, Y+17	; 0x11
    2216:	eb 81       	ldd	r30, Y+3	; 0x03
    2218:	fc 81       	ldd	r31, Y+4	; 0x04
    221a:	a9 81       	ldd	r26, Y+1	; 0x01
    221c:	ba 81       	ldd	r27, Y+2	; 0x02
    221e:	b9 01       	movw	r22, r18
    2220:	9f 01       	movw	r18, r30
    2222:	8d 01       	movw	r16, r26
    2224:	0e 94 cd 11 	call	0x239a	; 0x239a <prvWriteMessageToBuffer>
    2228:	9e 83       	std	Y+6, r25	; 0x06
    222a:	8d 83       	std	Y+5, r24	; 0x05

	if( xReturn > ( size_t ) 0 )
    222c:	8d 81       	ldd	r24, Y+5	; 0x05
    222e:	9e 81       	ldd	r25, Y+6	; 0x06
    2230:	00 97       	sbiw	r24, 0x00	; 0
    2232:	39 f1       	breq	.+78     	; 0x2282 <xStreamBufferSend+0x172>
	{
		traceSTREAM_BUFFER_SEND( xStreamBuffer, xReturn );

		/* Was a task waiting for the data? */
		if( prvBytesInBuffer( pxStreamBuffer ) >= pxStreamBuffer->xTriggerLevelBytes )
    2234:	8f 81       	ldd	r24, Y+7	; 0x07
    2236:	98 85       	ldd	r25, Y+8	; 0x08
    2238:	0e 94 54 16 	call	0x2ca8	; 0x2ca8 <prvBytesInBuffer>
    223c:	9c 01       	movw	r18, r24
    223e:	ef 81       	ldd	r30, Y+7	; 0x07
    2240:	f8 85       	ldd	r31, Y+8	; 0x08
    2242:	86 81       	ldd	r24, Z+6	; 0x06
    2244:	97 81       	ldd	r25, Z+7	; 0x07
    2246:	28 17       	cp	r18, r24
    2248:	39 07       	cpc	r19, r25
    224a:	d8 f0       	brcs	.+54     	; 0x2282 <xStreamBufferSend+0x172>
		{
			sbSEND_COMPLETED( pxStreamBuffer );
    224c:	0e 94 b5 1a 	call	0x356a	; 0x356a <vTaskSuspendAll>
    2250:	ef 81       	ldd	r30, Y+7	; 0x07
    2252:	f8 85       	ldd	r31, Y+8	; 0x08
    2254:	80 85       	ldd	r24, Z+8	; 0x08
    2256:	91 85       	ldd	r25, Z+9	; 0x09
    2258:	00 97       	sbiw	r24, 0x00	; 0
    225a:	89 f0       	breq	.+34     	; 0x227e <xStreamBufferSend+0x16e>
    225c:	ef 81       	ldd	r30, Y+7	; 0x07
    225e:	f8 85       	ldd	r31, Y+8	; 0x08
    2260:	80 85       	ldd	r24, Z+8	; 0x08
    2262:	91 85       	ldd	r25, Z+9	; 0x09
    2264:	40 e0       	ldi	r20, 0x00	; 0
    2266:	50 e0       	ldi	r21, 0x00	; 0
    2268:	60 e0       	ldi	r22, 0x00	; 0
    226a:	70 e0       	ldi	r23, 0x00	; 0
    226c:	20 e0       	ldi	r18, 0x00	; 0
    226e:	00 e0       	ldi	r16, 0x00	; 0
    2270:	10 e0       	ldi	r17, 0x00	; 0
    2272:	0e 94 d2 20 	call	0x41a4	; 0x41a4 <xTaskGenericNotify>
    2276:	ef 81       	ldd	r30, Y+7	; 0x07
    2278:	f8 85       	ldd	r31, Y+8	; 0x08
    227a:	11 86       	std	Z+9, r1	; 0x09
    227c:	10 86       	std	Z+8, r1	; 0x08
    227e:	0e 94 c1 1a 	call	0x3582	; 0x3582 <xTaskResumeAll>
	{
		mtCOVERAGE_TEST_MARKER();
		traceSTREAM_BUFFER_SEND_FAILED( xStreamBuffer );
	}

	return xReturn;
    2282:	8d 81       	ldd	r24, Y+5	; 0x05
    2284:	9e 81       	ldd	r25, Y+6	; 0x06
}
    2286:	63 96       	adiw	r28, 0x13	; 19
    2288:	0f b6       	in	r0, 0x3f	; 63
    228a:	f8 94       	cli
    228c:	de bf       	out	0x3e, r29	; 62
    228e:	0f be       	out	0x3f, r0	; 63
    2290:	cd bf       	out	0x3d, r28	; 61
    2292:	cf 91       	pop	r28
    2294:	df 91       	pop	r29
    2296:	1f 91       	pop	r17
    2298:	0f 91       	pop	r16
    229a:	ff 90       	pop	r15
    229c:	ef 90       	pop	r14
    229e:	08 95       	ret

000022a0 <xStreamBufferSendFromISR>:

size_t xStreamBufferSendFromISR( StreamBufferHandle_t xStreamBuffer,
								 const void *pvTxData,
								 size_t xDataLengthBytes,
								 BaseType_t * const pxHigherPriorityTaskWoken )
{
    22a0:	ef 92       	push	r14
    22a2:	ff 92       	push	r15
    22a4:	0f 93       	push	r16
    22a6:	1f 93       	push	r17
    22a8:	df 93       	push	r29
    22aa:	cf 93       	push	r28
    22ac:	cd b7       	in	r28, 0x3d	; 61
    22ae:	de b7       	in	r29, 0x3e	; 62
    22b0:	61 97       	sbiw	r28, 0x11	; 17
    22b2:	0f b6       	in	r0, 0x3f	; 63
    22b4:	f8 94       	cli
    22b6:	de bf       	out	0x3e, r29	; 62
    22b8:	0f be       	out	0x3f, r0	; 63
    22ba:	cd bf       	out	0x3d, r28	; 61
    22bc:	9b 87       	std	Y+11, r25	; 0x0b
    22be:	8a 87       	std	Y+10, r24	; 0x0a
    22c0:	7d 87       	std	Y+13, r23	; 0x0d
    22c2:	6c 87       	std	Y+12, r22	; 0x0c
    22c4:	5f 87       	std	Y+15, r21	; 0x0f
    22c6:	4e 87       	std	Y+14, r20	; 0x0e
    22c8:	39 8b       	std	Y+17, r19	; 0x11
    22ca:	28 8b       	std	Y+16, r18	; 0x10
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    22cc:	8a 85       	ldd	r24, Y+10	; 0x0a
    22ce:	9b 85       	ldd	r25, Y+11	; 0x0b
    22d0:	99 87       	std	Y+9, r25	; 0x09
    22d2:	88 87       	std	Y+8, r24	; 0x08
size_t xReturn, xSpace;
size_t xRequiredSpace = xDataLengthBytes;
    22d4:	8e 85       	ldd	r24, Y+14	; 0x0e
    22d6:	9f 85       	ldd	r25, Y+15	; 0x0f
    22d8:	9b 83       	std	Y+3, r25	; 0x03
    22da:	8a 83       	std	Y+2, r24	; 0x02

	/* This send function is used to write to both message buffers and stream
	buffers.  If this is a message buffer then the space needed must be
	increased by the amount of bytes needed to store the length of the
	message. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    22dc:	e8 85       	ldd	r30, Y+8	; 0x08
    22de:	f9 85       	ldd	r31, Y+9	; 0x09
    22e0:	86 85       	ldd	r24, Z+14	; 0x0e
    22e2:	88 2f       	mov	r24, r24
    22e4:	90 e0       	ldi	r25, 0x00	; 0
    22e6:	81 70       	andi	r24, 0x01	; 1
    22e8:	90 70       	andi	r25, 0x00	; 0
    22ea:	88 23       	and	r24, r24
    22ec:	29 f0       	breq	.+10     	; 0x22f8 <xStreamBufferSendFromISR+0x58>
	{
		xRequiredSpace += sbBYTES_TO_STORE_MESSAGE_LENGTH;
    22ee:	8a 81       	ldd	r24, Y+2	; 0x02
    22f0:	9b 81       	ldd	r25, Y+3	; 0x03
    22f2:	02 96       	adiw	r24, 0x02	; 2
    22f4:	9b 83       	std	Y+3, r25	; 0x03
    22f6:	8a 83       	std	Y+2, r24	; 0x02
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
    22f8:	88 85       	ldd	r24, Y+8	; 0x08
    22fa:	99 85       	ldd	r25, Y+9	; 0x09
    22fc:	0e 94 24 10 	call	0x2048	; 0x2048 <xStreamBufferSpacesAvailable>
    2300:	9d 83       	std	Y+5, r25	; 0x05
    2302:	8c 83       	std	Y+4, r24	; 0x04
	xReturn = prvWriteMessageToBuffer( pxStreamBuffer, pvTxData, xDataLengthBytes, xSpace, xRequiredSpace );
    2304:	88 85       	ldd	r24, Y+8	; 0x08
    2306:	99 85       	ldd	r25, Y+9	; 0x09
    2308:	2c 85       	ldd	r18, Y+12	; 0x0c
    230a:	3d 85       	ldd	r19, Y+13	; 0x0d
    230c:	4e 85       	ldd	r20, Y+14	; 0x0e
    230e:	5f 85       	ldd	r21, Y+15	; 0x0f
    2310:	ec 81       	ldd	r30, Y+4	; 0x04
    2312:	fd 81       	ldd	r31, Y+5	; 0x05
    2314:	aa 81       	ldd	r26, Y+2	; 0x02
    2316:	bb 81       	ldd	r27, Y+3	; 0x03
    2318:	b9 01       	movw	r22, r18
    231a:	9f 01       	movw	r18, r30
    231c:	8d 01       	movw	r16, r26
    231e:	0e 94 cd 11 	call	0x239a	; 0x239a <prvWriteMessageToBuffer>
    2322:	9f 83       	std	Y+7, r25	; 0x07
    2324:	8e 83       	std	Y+6, r24	; 0x06

	if( xReturn > ( size_t ) 0 )
    2326:	8e 81       	ldd	r24, Y+6	; 0x06
    2328:	9f 81       	ldd	r25, Y+7	; 0x07
    232a:	00 97       	sbiw	r24, 0x00	; 0
    232c:	39 f1       	breq	.+78     	; 0x237c <xStreamBufferSendFromISR+0xdc>
	{
		/* Was a task waiting for the data? */
		if( prvBytesInBuffer( pxStreamBuffer ) >= pxStreamBuffer->xTriggerLevelBytes )
    232e:	88 85       	ldd	r24, Y+8	; 0x08
    2330:	99 85       	ldd	r25, Y+9	; 0x09
    2332:	0e 94 54 16 	call	0x2ca8	; 0x2ca8 <prvBytesInBuffer>
    2336:	9c 01       	movw	r18, r24
    2338:	e8 85       	ldd	r30, Y+8	; 0x08
    233a:	f9 85       	ldd	r31, Y+9	; 0x09
    233c:	86 81       	ldd	r24, Z+6	; 0x06
    233e:	97 81       	ldd	r25, Z+7	; 0x07
    2340:	28 17       	cp	r18, r24
    2342:	39 07       	cpc	r19, r25
    2344:	d8 f0       	brcs	.+54     	; 0x237c <xStreamBufferSendFromISR+0xdc>
		{
			sbSEND_COMPLETE_FROM_ISR( pxStreamBuffer, pxHigherPriorityTaskWoken );
    2346:	19 82       	std	Y+1, r1	; 0x01
    2348:	e8 85       	ldd	r30, Y+8	; 0x08
    234a:	f9 85       	ldd	r31, Y+9	; 0x09
    234c:	80 85       	ldd	r24, Z+8	; 0x08
    234e:	91 85       	ldd	r25, Z+9	; 0x09
    2350:	00 97       	sbiw	r24, 0x00	; 0
    2352:	a1 f0       	breq	.+40     	; 0x237c <xStreamBufferSendFromISR+0xdc>
    2354:	e8 85       	ldd	r30, Y+8	; 0x08
    2356:	f9 85       	ldd	r31, Y+9	; 0x09
    2358:	80 85       	ldd	r24, Z+8	; 0x08
    235a:	91 85       	ldd	r25, Z+9	; 0x09
    235c:	e8 89       	ldd	r30, Y+16	; 0x10
    235e:	f9 89       	ldd	r31, Y+17	; 0x11
    2360:	40 e0       	ldi	r20, 0x00	; 0
    2362:	50 e0       	ldi	r21, 0x00	; 0
    2364:	60 e0       	ldi	r22, 0x00	; 0
    2366:	70 e0       	ldi	r23, 0x00	; 0
    2368:	20 e0       	ldi	r18, 0x00	; 0
    236a:	00 e0       	ldi	r16, 0x00	; 0
    236c:	10 e0       	ldi	r17, 0x00	; 0
    236e:	7f 01       	movw	r14, r30
    2370:	0e 94 af 21 	call	0x435e	; 0x435e <xTaskGenericNotifyFromISR>
    2374:	e8 85       	ldd	r30, Y+8	; 0x08
    2376:	f9 85       	ldd	r31, Y+9	; 0x09
    2378:	11 86       	std	Z+9, r1	; 0x09
    237a:	10 86       	std	Z+8, r1	; 0x08
		mtCOVERAGE_TEST_MARKER();
	}

	traceSTREAM_BUFFER_SEND_FROM_ISR( xStreamBuffer, xReturn );

	return xReturn;
    237c:	8e 81       	ldd	r24, Y+6	; 0x06
    237e:	9f 81       	ldd	r25, Y+7	; 0x07
}
    2380:	61 96       	adiw	r28, 0x11	; 17
    2382:	0f b6       	in	r0, 0x3f	; 63
    2384:	f8 94       	cli
    2386:	de bf       	out	0x3e, r29	; 62
    2388:	0f be       	out	0x3f, r0	; 63
    238a:	cd bf       	out	0x3d, r28	; 61
    238c:	cf 91       	pop	r28
    238e:	df 91       	pop	r29
    2390:	1f 91       	pop	r17
    2392:	0f 91       	pop	r16
    2394:	ff 90       	pop	r15
    2396:	ef 90       	pop	r14
    2398:	08 95       	ret

0000239a <prvWriteMessageToBuffer>:
static size_t prvWriteMessageToBuffer( StreamBuffer_t * const pxStreamBuffer,
									   const void * pvTxData,
									   size_t xDataLengthBytes,
									   size_t xSpace,
									   size_t xRequiredSpace )
{
    239a:	0f 93       	push	r16
    239c:	1f 93       	push	r17
    239e:	df 93       	push	r29
    23a0:	cf 93       	push	r28
    23a2:	cd b7       	in	r28, 0x3d	; 61
    23a4:	de b7       	in	r29, 0x3e	; 62
    23a6:	61 97       	sbiw	r28, 0x11	; 17
    23a8:	0f b6       	in	r0, 0x3f	; 63
    23aa:	f8 94       	cli
    23ac:	de bf       	out	0x3e, r29	; 62
    23ae:	0f be       	out	0x3f, r0	; 63
    23b0:	cd bf       	out	0x3d, r28	; 61
    23b2:	9d 83       	std	Y+5, r25	; 0x05
    23b4:	8c 83       	std	Y+4, r24	; 0x04
    23b6:	7f 83       	std	Y+7, r23	; 0x07
    23b8:	6e 83       	std	Y+6, r22	; 0x06
    23ba:	59 87       	std	Y+9, r21	; 0x09
    23bc:	48 87       	std	Y+8, r20	; 0x08
    23be:	3b 87       	std	Y+11, r19	; 0x0b
    23c0:	2a 87       	std	Y+10, r18	; 0x0a
    23c2:	1d 87       	std	Y+13, r17	; 0x0d
    23c4:	0c 87       	std	Y+12, r16	; 0x0c
	BaseType_t xShouldWrite;
	size_t xReturn;

	if( xSpace == ( size_t ) 0 )
    23c6:	8a 85       	ldd	r24, Y+10	; 0x0a
    23c8:	9b 85       	ldd	r25, Y+11	; 0x0b
    23ca:	00 97       	sbiw	r24, 0x00	; 0
    23cc:	11 f4       	brne	.+4      	; 0x23d2 <prvWriteMessageToBuffer+0x38>
	{
		/* Doesn't matter if this is a stream buffer or a message buffer, there
		is no space to write. */
		xShouldWrite = pdFALSE;
    23ce:	1b 82       	std	Y+3, r1	; 0x03
    23d0:	38 c0       	rjmp	.+112    	; 0x2442 <prvWriteMessageToBuffer+0xa8>
	}
	else if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) == ( uint8_t ) 0 )
    23d2:	ec 81       	ldd	r30, Y+4	; 0x04
    23d4:	fd 81       	ldd	r31, Y+5	; 0x05
    23d6:	86 85       	ldd	r24, Z+14	; 0x0e
    23d8:	88 2f       	mov	r24, r24
    23da:	90 e0       	ldi	r25, 0x00	; 0
    23dc:	81 70       	andi	r24, 0x01	; 1
    23de:	90 70       	andi	r25, 0x00	; 0
    23e0:	00 97       	sbiw	r24, 0x00	; 0
    23e2:	d1 f4       	brne	.+52     	; 0x2418 <prvWriteMessageToBuffer+0x7e>
	{
		/* This is a stream buffer, as opposed to a message buffer, so writing a
		stream of bytes rather than discrete messages.  Write as many bytes as
		possible. */
		xShouldWrite = pdTRUE;
    23e4:	81 e0       	ldi	r24, 0x01	; 1
    23e6:	8b 83       	std	Y+3, r24	; 0x03
		xDataLengthBytes = configMIN( xDataLengthBytes, xSpace );
    23e8:	28 85       	ldd	r18, Y+8	; 0x08
    23ea:	39 85       	ldd	r19, Y+9	; 0x09
    23ec:	39 8b       	std	Y+17, r19	; 0x11
    23ee:	28 8b       	std	Y+16, r18	; 0x10
    23f0:	8a 85       	ldd	r24, Y+10	; 0x0a
    23f2:	9b 85       	ldd	r25, Y+11	; 0x0b
    23f4:	9f 87       	std	Y+15, r25	; 0x0f
    23f6:	8e 87       	std	Y+14, r24	; 0x0e
    23f8:	2e 85       	ldd	r18, Y+14	; 0x0e
    23fa:	3f 85       	ldd	r19, Y+15	; 0x0f
    23fc:	88 89       	ldd	r24, Y+16	; 0x10
    23fe:	99 89       	ldd	r25, Y+17	; 0x11
    2400:	82 17       	cp	r24, r18
    2402:	93 07       	cpc	r25, r19
    2404:	20 f4       	brcc	.+8      	; 0x240e <prvWriteMessageToBuffer+0x74>
    2406:	28 89       	ldd	r18, Y+16	; 0x10
    2408:	39 89       	ldd	r19, Y+17	; 0x11
    240a:	3f 87       	std	Y+15, r19	; 0x0f
    240c:	2e 87       	std	Y+14, r18	; 0x0e
    240e:	8e 85       	ldd	r24, Y+14	; 0x0e
    2410:	9f 85       	ldd	r25, Y+15	; 0x0f
    2412:	99 87       	std	Y+9, r25	; 0x09
    2414:	88 87       	std	Y+8, r24	; 0x08
    2416:	15 c0       	rjmp	.+42     	; 0x2442 <prvWriteMessageToBuffer+0xa8>
	}
	else if( xSpace >= xRequiredSpace )
    2418:	2a 85       	ldd	r18, Y+10	; 0x0a
    241a:	3b 85       	ldd	r19, Y+11	; 0x0b
    241c:	8c 85       	ldd	r24, Y+12	; 0x0c
    241e:	9d 85       	ldd	r25, Y+13	; 0x0d
    2420:	28 17       	cp	r18, r24
    2422:	39 07       	cpc	r19, r25
    2424:	68 f0       	brcs	.+26     	; 0x2440 <prvWriteMessageToBuffer+0xa6>
	{
		/* This is a message buffer, as opposed to a stream buffer, and there
		is enough space to write both the message length and the message itself
		into the buffer.  Start by writing the length of the data, the data
		itself will be written later in this function. */
		xShouldWrite = pdTRUE;
    2426:	81 e0       	ldi	r24, 0x01	; 1
    2428:	8b 83       	std	Y+3, r24	; 0x03
		( void ) prvWriteBytesToBuffer( pxStreamBuffer, ( const uint8_t * ) &( xDataLengthBytes ), sbBYTES_TO_STORE_MESSAGE_LENGTH );
    242a:	9e 01       	movw	r18, r28
    242c:	28 5f       	subi	r18, 0xF8	; 248
    242e:	3f 4f       	sbci	r19, 0xFF	; 255
    2430:	8c 81       	ldd	r24, Y+4	; 0x04
    2432:	9d 81       	ldd	r25, Y+5	; 0x05
    2434:	b9 01       	movw	r22, r18
    2436:	42 e0       	ldi	r20, 0x02	; 2
    2438:	50 e0       	ldi	r21, 0x00	; 0
    243a:	0e 94 1a 15 	call	0x2a34	; 0x2a34 <prvWriteBytesToBuffer>
    243e:	01 c0       	rjmp	.+2      	; 0x2442 <prvWriteMessageToBuffer+0xa8>
	}
	else
	{
		/* There is space available, but not enough space. */
		xShouldWrite = pdFALSE;
    2440:	1b 82       	std	Y+3, r1	; 0x03
	}

	if( xShouldWrite != pdFALSE )
    2442:	8b 81       	ldd	r24, Y+3	; 0x03
    2444:	88 23       	and	r24, r24
    2446:	61 f0       	breq	.+24     	; 0x2460 <prvWriteMessageToBuffer+0xc6>
	{
		/* Writes the data itself. */
		xReturn = prvWriteBytesToBuffer( pxStreamBuffer, ( const uint8_t * ) pvTxData, xDataLengthBytes ); /*lint !e9079 Storage buffer is implemented as uint8_t for ease of sizing, alighment and access. */
    2448:	2e 81       	ldd	r18, Y+6	; 0x06
    244a:	3f 81       	ldd	r19, Y+7	; 0x07
    244c:	48 85       	ldd	r20, Y+8	; 0x08
    244e:	59 85       	ldd	r21, Y+9	; 0x09
    2450:	8c 81       	ldd	r24, Y+4	; 0x04
    2452:	9d 81       	ldd	r25, Y+5	; 0x05
    2454:	b9 01       	movw	r22, r18
    2456:	0e 94 1a 15 	call	0x2a34	; 0x2a34 <prvWriteBytesToBuffer>
    245a:	9a 83       	std	Y+2, r25	; 0x02
    245c:	89 83       	std	Y+1, r24	; 0x01
    245e:	02 c0       	rjmp	.+4      	; 0x2464 <prvWriteMessageToBuffer+0xca>
	}
	else
	{
		xReturn = 0;
    2460:	1a 82       	std	Y+2, r1	; 0x02
    2462:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    2464:	89 81       	ldd	r24, Y+1	; 0x01
    2466:	9a 81       	ldd	r25, Y+2	; 0x02
}
    2468:	61 96       	adiw	r28, 0x11	; 17
    246a:	0f b6       	in	r0, 0x3f	; 63
    246c:	f8 94       	cli
    246e:	de bf       	out	0x3e, r29	; 62
    2470:	0f be       	out	0x3f, r0	; 63
    2472:	cd bf       	out	0x3d, r28	; 61
    2474:	cf 91       	pop	r28
    2476:	df 91       	pop	r29
    2478:	1f 91       	pop	r17
    247a:	0f 91       	pop	r16
    247c:	08 95       	ret

0000247e <xStreamBufferReceive>:

size_t xStreamBufferReceive( StreamBufferHandle_t xStreamBuffer,
							 void *pvRxData,
							 size_t xBufferLengthBytes,
							 TickType_t xTicksToWait )
{
    247e:	ef 92       	push	r14
    2480:	ff 92       	push	r15
    2482:	0f 93       	push	r16
    2484:	1f 93       	push	r17
    2486:	df 93       	push	r29
    2488:	cf 93       	push	r28
    248a:	cd b7       	in	r28, 0x3d	; 61
    248c:	de b7       	in	r29, 0x3e	; 62
    248e:	60 97       	sbiw	r28, 0x10	; 16
    2490:	0f b6       	in	r0, 0x3f	; 63
    2492:	f8 94       	cli
    2494:	de bf       	out	0x3e, r29	; 62
    2496:	0f be       	out	0x3f, r0	; 63
    2498:	cd bf       	out	0x3d, r28	; 61
    249a:	9a 87       	std	Y+10, r25	; 0x0a
    249c:	89 87       	std	Y+9, r24	; 0x09
    249e:	7c 87       	std	Y+12, r23	; 0x0c
    24a0:	6b 87       	std	Y+11, r22	; 0x0b
    24a2:	5e 87       	std	Y+14, r21	; 0x0e
    24a4:	4d 87       	std	Y+13, r20	; 0x0d
    24a6:	38 8b       	std	Y+16, r19	; 0x10
    24a8:	2f 87       	std	Y+15, r18	; 0x0f
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    24aa:	89 85       	ldd	r24, Y+9	; 0x09
    24ac:	9a 85       	ldd	r25, Y+10	; 0x0a
    24ae:	98 87       	std	Y+8, r25	; 0x08
    24b0:	8f 83       	std	Y+7, r24	; 0x07
size_t xReceivedLength = 0, xBytesAvailable, xBytesToStoreMessageLength;
    24b2:	1e 82       	std	Y+6, r1	; 0x06
    24b4:	1d 82       	std	Y+5, r1	; 0x05
	/* This receive function is used by both message buffers, which store
	discrete messages, and stream buffers, which store a continuous stream of
	bytes.  Discrete messages include an additional
	sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the
	message. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    24b6:	ef 81       	ldd	r30, Y+7	; 0x07
    24b8:	f8 85       	ldd	r31, Y+8	; 0x08
    24ba:	86 85       	ldd	r24, Z+14	; 0x0e
    24bc:	88 2f       	mov	r24, r24
    24be:	90 e0       	ldi	r25, 0x00	; 0
    24c0:	81 70       	andi	r24, 0x01	; 1
    24c2:	90 70       	andi	r25, 0x00	; 0
    24c4:	88 23       	and	r24, r24
    24c6:	29 f0       	breq	.+10     	; 0x24d2 <xStreamBufferReceive+0x54>
	{
		xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
    24c8:	82 e0       	ldi	r24, 0x02	; 2
    24ca:	90 e0       	ldi	r25, 0x00	; 0
    24cc:	9a 83       	std	Y+2, r25	; 0x02
    24ce:	89 83       	std	Y+1, r24	; 0x01
    24d0:	02 c0       	rjmp	.+4      	; 0x24d6 <xStreamBufferReceive+0x58>
	}
	else
	{
		xBytesToStoreMessageLength = 0;
    24d2:	1a 82       	std	Y+2, r1	; 0x02
    24d4:	19 82       	std	Y+1, r1	; 0x01
	}

	if( xTicksToWait != ( TickType_t ) 0 )
    24d6:	8f 85       	ldd	r24, Y+15	; 0x0f
    24d8:	98 89       	ldd	r25, Y+16	; 0x10
    24da:	00 97       	sbiw	r24, 0x00	; 0
    24dc:	09 f4       	brne	.+2      	; 0x24e0 <xStreamBufferReceive+0x62>
    24de:	3d c0       	rjmp	.+122    	; 0x255a <xStreamBufferReceive+0xdc>
	{
		/* Checking if there is data and clearing the notification state must be
		performed atomically. */
		taskENTER_CRITICAL();
    24e0:	0f b6       	in	r0, 0x3f	; 63
    24e2:	f8 94       	cli
    24e4:	0f 92       	push	r0
		{
			xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    24e6:	8f 81       	ldd	r24, Y+7	; 0x07
    24e8:	98 85       	ldd	r25, Y+8	; 0x08
    24ea:	0e 94 54 16 	call	0x2ca8	; 0x2ca8 <prvBytesInBuffer>
    24ee:	9c 83       	std	Y+4, r25	; 0x04
    24f0:	8b 83       	std	Y+3, r24	; 0x03
			/* If this function was invoked by a message buffer read then
			xBytesToStoreMessageLength holds the number of bytes used to hold
			the length of the next discrete message.  If this function was
			invoked by a stream buffer read then xBytesToStoreMessageLength will
			be 0. */
			if( xBytesAvailable <= xBytesToStoreMessageLength )
    24f2:	2b 81       	ldd	r18, Y+3	; 0x03
    24f4:	3c 81       	ldd	r19, Y+4	; 0x04
    24f6:	89 81       	ldd	r24, Y+1	; 0x01
    24f8:	9a 81       	ldd	r25, Y+2	; 0x02
    24fa:	82 17       	cp	r24, r18
    24fc:	93 07       	cpc	r25, r19
    24fe:	50 f0       	brcs	.+20     	; 0x2514 <xStreamBufferReceive+0x96>
			{
				/* Clear notification state as going to wait for data. */
				( void ) xTaskNotifyStateClear( NULL );
    2500:	80 e0       	ldi	r24, 0x00	; 0
    2502:	90 e0       	ldi	r25, 0x00	; 0
    2504:	0e 94 2d 23 	call	0x465a	; 0x465a <xTaskNotifyStateClear>

				/* Should only be one reader. */
				configASSERT( pxStreamBuffer->xTaskWaitingToReceive == NULL );
				pxStreamBuffer->xTaskWaitingToReceive = xTaskGetCurrentTaskHandle();
    2508:	0e 94 86 1f 	call	0x3f0c	; 0x3f0c <xTaskGetCurrentTaskHandle>
    250c:	ef 81       	ldd	r30, Y+7	; 0x07
    250e:	f8 85       	ldd	r31, Y+8	; 0x08
    2510:	91 87       	std	Z+9, r25	; 0x09
    2512:	80 87       	std	Z+8, r24	; 0x08
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    2514:	0f 90       	pop	r0
    2516:	0f be       	out	0x3f, r0	; 63

		if( xBytesAvailable <= xBytesToStoreMessageLength )
    2518:	2b 81       	ldd	r18, Y+3	; 0x03
    251a:	3c 81       	ldd	r19, Y+4	; 0x04
    251c:	89 81       	ldd	r24, Y+1	; 0x01
    251e:	9a 81       	ldd	r25, Y+2	; 0x02
    2520:	82 17       	cp	r24, r18
    2522:	93 07       	cpc	r25, r19
    2524:	00 f1       	brcs	.+64     	; 0x2566 <xStreamBufferReceive+0xe8>
		{
			/* Wait for data to be available. */
			traceBLOCKING_ON_STREAM_BUFFER_RECEIVE( xStreamBuffer );
			( void ) xTaskNotifyWait( ( uint32_t ) 0, ( uint32_t ) 0, NULL, xTicksToWait );
    2526:	ef 85       	ldd	r30, Y+15	; 0x0f
    2528:	f8 89       	ldd	r31, Y+16	; 0x10
    252a:	60 e0       	ldi	r22, 0x00	; 0
    252c:	70 e0       	ldi	r23, 0x00	; 0
    252e:	80 e0       	ldi	r24, 0x00	; 0
    2530:	90 e0       	ldi	r25, 0x00	; 0
    2532:	20 e0       	ldi	r18, 0x00	; 0
    2534:	30 e0       	ldi	r19, 0x00	; 0
    2536:	40 e0       	ldi	r20, 0x00	; 0
    2538:	50 e0       	ldi	r21, 0x00	; 0
    253a:	00 e0       	ldi	r16, 0x00	; 0
    253c:	10 e0       	ldi	r17, 0x00	; 0
    253e:	7f 01       	movw	r14, r30
    2540:	0e 94 36 20 	call	0x406c	; 0x406c <xTaskNotifyWait>
			pxStreamBuffer->xTaskWaitingToReceive = NULL;
    2544:	ef 81       	ldd	r30, Y+7	; 0x07
    2546:	f8 85       	ldd	r31, Y+8	; 0x08
    2548:	11 86       	std	Z+9, r1	; 0x09
    254a:	10 86       	std	Z+8, r1	; 0x08

			/* Recheck the data available after blocking. */
			xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    254c:	8f 81       	ldd	r24, Y+7	; 0x07
    254e:	98 85       	ldd	r25, Y+8	; 0x08
    2550:	0e 94 54 16 	call	0x2ca8	; 0x2ca8 <prvBytesInBuffer>
    2554:	9c 83       	std	Y+4, r25	; 0x04
    2556:	8b 83       	std	Y+3, r24	; 0x03
    2558:	06 c0       	rjmp	.+12     	; 0x2566 <xStreamBufferReceive+0xe8>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    255a:	8f 81       	ldd	r24, Y+7	; 0x07
    255c:	98 85       	ldd	r25, Y+8	; 0x08
    255e:	0e 94 54 16 	call	0x2ca8	; 0x2ca8 <prvBytesInBuffer>
    2562:	9c 83       	std	Y+4, r25	; 0x04
    2564:	8b 83       	std	Y+3, r24	; 0x03
	/* Whether receiving a discrete message (where xBytesToStoreMessageLength
	holds the number of bytes used to store the message length) or a stream of
	bytes (where xBytesToStoreMessageLength is zero), the number of bytes
	available must be greater than xBytesToStoreMessageLength to be able to
	read bytes from the buffer. */
	if( xBytesAvailable > xBytesToStoreMessageLength )
    2566:	2b 81       	ldd	r18, Y+3	; 0x03
    2568:	3c 81       	ldd	r19, Y+4	; 0x04
    256a:	89 81       	ldd	r24, Y+1	; 0x01
    256c:	9a 81       	ldd	r25, Y+2	; 0x02
    256e:	82 17       	cp	r24, r18
    2570:	93 07       	cpc	r25, r19
    2572:	80 f5       	brcc	.+96     	; 0x25d4 <xStreamBufferReceive+0x156>
	{
		xReceivedLength = prvReadMessageFromBuffer( pxStreamBuffer, pvRxData, xBufferLengthBytes, xBytesAvailable, xBytesToStoreMessageLength );
    2574:	8f 81       	ldd	r24, Y+7	; 0x07
    2576:	98 85       	ldd	r25, Y+8	; 0x08
    2578:	2b 85       	ldd	r18, Y+11	; 0x0b
    257a:	3c 85       	ldd	r19, Y+12	; 0x0c
    257c:	4d 85       	ldd	r20, Y+13	; 0x0d
    257e:	5e 85       	ldd	r21, Y+14	; 0x0e
    2580:	eb 81       	ldd	r30, Y+3	; 0x03
    2582:	fc 81       	ldd	r31, Y+4	; 0x04
    2584:	a9 81       	ldd	r26, Y+1	; 0x01
    2586:	ba 81       	ldd	r27, Y+2	; 0x02
    2588:	b9 01       	movw	r22, r18
    258a:	9f 01       	movw	r18, r30
    258c:	8d 01       	movw	r16, r26
    258e:	0e 94 c3 13 	call	0x2786	; 0x2786 <prvReadMessageFromBuffer>
    2592:	9e 83       	std	Y+6, r25	; 0x06
    2594:	8d 83       	std	Y+5, r24	; 0x05

		/* Was a task waiting for space in the buffer? */
		if( xReceivedLength != ( size_t ) 0 )
    2596:	8d 81       	ldd	r24, Y+5	; 0x05
    2598:	9e 81       	ldd	r25, Y+6	; 0x06
    259a:	00 97       	sbiw	r24, 0x00	; 0
    259c:	d9 f0       	breq	.+54     	; 0x25d4 <xStreamBufferReceive+0x156>
		{
			traceSTREAM_BUFFER_RECEIVE( xStreamBuffer, xReceivedLength );
			sbRECEIVE_COMPLETED( pxStreamBuffer );
    259e:	0e 94 b5 1a 	call	0x356a	; 0x356a <vTaskSuspendAll>
    25a2:	ef 81       	ldd	r30, Y+7	; 0x07
    25a4:	f8 85       	ldd	r31, Y+8	; 0x08
    25a6:	82 85       	ldd	r24, Z+10	; 0x0a
    25a8:	93 85       	ldd	r25, Z+11	; 0x0b
    25aa:	00 97       	sbiw	r24, 0x00	; 0
    25ac:	89 f0       	breq	.+34     	; 0x25d0 <xStreamBufferReceive+0x152>
    25ae:	ef 81       	ldd	r30, Y+7	; 0x07
    25b0:	f8 85       	ldd	r31, Y+8	; 0x08
    25b2:	82 85       	ldd	r24, Z+10	; 0x0a
    25b4:	93 85       	ldd	r25, Z+11	; 0x0b
    25b6:	40 e0       	ldi	r20, 0x00	; 0
    25b8:	50 e0       	ldi	r21, 0x00	; 0
    25ba:	60 e0       	ldi	r22, 0x00	; 0
    25bc:	70 e0       	ldi	r23, 0x00	; 0
    25be:	20 e0       	ldi	r18, 0x00	; 0
    25c0:	00 e0       	ldi	r16, 0x00	; 0
    25c2:	10 e0       	ldi	r17, 0x00	; 0
    25c4:	0e 94 d2 20 	call	0x41a4	; 0x41a4 <xTaskGenericNotify>
    25c8:	ef 81       	ldd	r30, Y+7	; 0x07
    25ca:	f8 85       	ldd	r31, Y+8	; 0x08
    25cc:	13 86       	std	Z+11, r1	; 0x0b
    25ce:	12 86       	std	Z+10, r1	; 0x0a
    25d0:	0e 94 c1 1a 	call	0x3582	; 0x3582 <xTaskResumeAll>
	{
		traceSTREAM_BUFFER_RECEIVE_FAILED( xStreamBuffer );
		mtCOVERAGE_TEST_MARKER();
	}

	return xReceivedLength;
    25d4:	8d 81       	ldd	r24, Y+5	; 0x05
    25d6:	9e 81       	ldd	r25, Y+6	; 0x06
}
    25d8:	60 96       	adiw	r28, 0x10	; 16
    25da:	0f b6       	in	r0, 0x3f	; 63
    25dc:	f8 94       	cli
    25de:	de bf       	out	0x3e, r29	; 62
    25e0:	0f be       	out	0x3f, r0	; 63
    25e2:	cd bf       	out	0x3d, r28	; 61
    25e4:	cf 91       	pop	r28
    25e6:	df 91       	pop	r29
    25e8:	1f 91       	pop	r17
    25ea:	0f 91       	pop	r16
    25ec:	ff 90       	pop	r15
    25ee:	ef 90       	pop	r14
    25f0:	08 95       	ret

000025f2 <xStreamBufferNextMessageLengthBytes>:
/*-----------------------------------------------------------*/

size_t xStreamBufferNextMessageLengthBytes( StreamBufferHandle_t xStreamBuffer )
{
    25f2:	df 93       	push	r29
    25f4:	cf 93       	push	r28
    25f6:	cd b7       	in	r28, 0x3d	; 61
    25f8:	de b7       	in	r29, 0x3e	; 62
    25fa:	2c 97       	sbiw	r28, 0x0c	; 12
    25fc:	0f b6       	in	r0, 0x3f	; 63
    25fe:	f8 94       	cli
    2600:	de bf       	out	0x3e, r29	; 62
    2602:	0f be       	out	0x3f, r0	; 63
    2604:	cd bf       	out	0x3d, r28	; 61
    2606:	9c 87       	std	Y+12, r25	; 0x0c
    2608:	8b 87       	std	Y+11, r24	; 0x0b
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    260a:	8b 85       	ldd	r24, Y+11	; 0x0b
    260c:	9c 85       	ldd	r25, Y+12	; 0x0c
    260e:	98 87       	std	Y+8, r25	; 0x08
    2610:	8f 83       	std	Y+7, r24	; 0x07
configMESSAGE_BUFFER_LENGTH_TYPE xTempReturn;

	configASSERT( pxStreamBuffer );

	/* Ensure the stream buffer is being used as a message buffer. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    2612:	ef 81       	ldd	r30, Y+7	; 0x07
    2614:	f8 85       	ldd	r31, Y+8	; 0x08
    2616:	86 85       	ldd	r24, Z+14	; 0x0e
    2618:	88 2f       	mov	r24, r24
    261a:	90 e0       	ldi	r25, 0x00	; 0
    261c:	81 70       	andi	r24, 0x01	; 1
    261e:	90 70       	andi	r25, 0x00	; 0
    2620:	88 23       	and	r24, r24
    2622:	61 f1       	breq	.+88     	; 0x267c <xStreamBufferNextMessageLengthBytes+0x8a>
	{
		xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    2624:	8f 81       	ldd	r24, Y+7	; 0x07
    2626:	98 85       	ldd	r25, Y+8	; 0x08
    2628:	0e 94 54 16 	call	0x2ca8	; 0x2ca8 <prvBytesInBuffer>
    262c:	9c 83       	std	Y+4, r25	; 0x04
    262e:	8b 83       	std	Y+3, r24	; 0x03
		if( xBytesAvailable > sbBYTES_TO_STORE_MESSAGE_LENGTH )
    2630:	8b 81       	ldd	r24, Y+3	; 0x03
    2632:	9c 81       	ldd	r25, Y+4	; 0x04
    2634:	83 30       	cpi	r24, 0x03	; 3
    2636:	91 05       	cpc	r25, r1
    2638:	f0 f0       	brcs	.+60     	; 0x2676 <xStreamBufferNextMessageLengthBytes+0x84>
			required to hold the length of the next message, so another message
			is available.  Return its length without removing the length bytes
			from the buffer.  A copy of the tail is stored so the buffer can be
			returned to its prior state as the message is not actually being
			removed from the buffer. */
			xOriginalTail = pxStreamBuffer->xTail;
    263a:	ef 81       	ldd	r30, Y+7	; 0x07
    263c:	f8 85       	ldd	r31, Y+8	; 0x08
    263e:	80 81       	ld	r24, Z
    2640:	91 81       	ldd	r25, Z+1	; 0x01
    2642:	9a 83       	std	Y+2, r25	; 0x02
    2644:	89 83       	std	Y+1, r24	; 0x01
			( void ) prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) &xTempReturn, sbBYTES_TO_STORE_MESSAGE_LENGTH, xBytesAvailable );
    2646:	9e 01       	movw	r18, r28
    2648:	27 5f       	subi	r18, 0xF7	; 247
    264a:	3f 4f       	sbci	r19, 0xFF	; 255
    264c:	8f 81       	ldd	r24, Y+7	; 0x07
    264e:	98 85       	ldd	r25, Y+8	; 0x08
    2650:	eb 81       	ldd	r30, Y+3	; 0x03
    2652:	fc 81       	ldd	r31, Y+4	; 0x04
    2654:	b9 01       	movw	r22, r18
    2656:	42 e0       	ldi	r20, 0x02	; 2
    2658:	50 e0       	ldi	r21, 0x00	; 0
    265a:	9f 01       	movw	r18, r30
    265c:	0e 94 a7 15 	call	0x2b4e	; 0x2b4e <prvReadBytesFromBuffer>
			xReturn = ( size_t ) xTempReturn;
    2660:	89 85       	ldd	r24, Y+9	; 0x09
    2662:	9a 85       	ldd	r25, Y+10	; 0x0a
    2664:	9e 83       	std	Y+6, r25	; 0x06
    2666:	8d 83       	std	Y+5, r24	; 0x05
			pxStreamBuffer->xTail = xOriginalTail;
    2668:	ef 81       	ldd	r30, Y+7	; 0x07
    266a:	f8 85       	ldd	r31, Y+8	; 0x08
    266c:	89 81       	ldd	r24, Y+1	; 0x01
    266e:	9a 81       	ldd	r25, Y+2	; 0x02
    2670:	91 83       	std	Z+1, r25	; 0x01
    2672:	80 83       	st	Z, r24
    2674:	05 c0       	rjmp	.+10     	; 0x2680 <xStreamBufferNextMessageLengthBytes+0x8e>
			/* The minimum amount of bytes in a message buffer is
			( sbBYTES_TO_STORE_MESSAGE_LENGTH + 1 ), so if xBytesAvailable is
			less than sbBYTES_TO_STORE_MESSAGE_LENGTH the only other valid
			value is 0. */
			configASSERT( xBytesAvailable == 0 );
			xReturn = 0;
    2676:	1e 82       	std	Y+6, r1	; 0x06
    2678:	1d 82       	std	Y+5, r1	; 0x05
    267a:	02 c0       	rjmp	.+4      	; 0x2680 <xStreamBufferNextMessageLengthBytes+0x8e>
		}
	}
	else
	{
		xReturn = 0;
    267c:	1e 82       	std	Y+6, r1	; 0x06
    267e:	1d 82       	std	Y+5, r1	; 0x05
	}

	return xReturn;
    2680:	8d 81       	ldd	r24, Y+5	; 0x05
    2682:	9e 81       	ldd	r25, Y+6	; 0x06
}
    2684:	2c 96       	adiw	r28, 0x0c	; 12
    2686:	0f b6       	in	r0, 0x3f	; 63
    2688:	f8 94       	cli
    268a:	de bf       	out	0x3e, r29	; 62
    268c:	0f be       	out	0x3f, r0	; 63
    268e:	cd bf       	out	0x3d, r28	; 61
    2690:	cf 91       	pop	r28
    2692:	df 91       	pop	r29
    2694:	08 95       	ret

00002696 <xStreamBufferReceiveFromISR>:

size_t xStreamBufferReceiveFromISR( StreamBufferHandle_t xStreamBuffer,
									void *pvRxData,
									size_t xBufferLengthBytes,
									BaseType_t * const pxHigherPriorityTaskWoken )
{
    2696:	ef 92       	push	r14
    2698:	ff 92       	push	r15
    269a:	0f 93       	push	r16
    269c:	1f 93       	push	r17
    269e:	df 93       	push	r29
    26a0:	cf 93       	push	r28
    26a2:	cd b7       	in	r28, 0x3d	; 61
    26a4:	de b7       	in	r29, 0x3e	; 62
    26a6:	61 97       	sbiw	r28, 0x11	; 17
    26a8:	0f b6       	in	r0, 0x3f	; 63
    26aa:	f8 94       	cli
    26ac:	de bf       	out	0x3e, r29	; 62
    26ae:	0f be       	out	0x3f, r0	; 63
    26b0:	cd bf       	out	0x3d, r28	; 61
    26b2:	9b 87       	std	Y+11, r25	; 0x0b
    26b4:	8a 87       	std	Y+10, r24	; 0x0a
    26b6:	7d 87       	std	Y+13, r23	; 0x0d
    26b8:	6c 87       	std	Y+12, r22	; 0x0c
    26ba:	5f 87       	std	Y+15, r21	; 0x0f
    26bc:	4e 87       	std	Y+14, r20	; 0x0e
    26be:	39 8b       	std	Y+17, r19	; 0x11
    26c0:	28 8b       	std	Y+16, r18	; 0x10
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    26c2:	8a 85       	ldd	r24, Y+10	; 0x0a
    26c4:	9b 85       	ldd	r25, Y+11	; 0x0b
    26c6:	99 87       	std	Y+9, r25	; 0x09
    26c8:	88 87       	std	Y+8, r24	; 0x08
size_t xReceivedLength = 0, xBytesAvailable, xBytesToStoreMessageLength;
    26ca:	1f 82       	std	Y+7, r1	; 0x07
    26cc:	1e 82       	std	Y+6, r1	; 0x06
	/* This receive function is used by both message buffers, which store
	discrete messages, and stream buffers, which store a continuous stream of
	bytes.  Discrete messages include an additional
	sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the
	message. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    26ce:	e8 85       	ldd	r30, Y+8	; 0x08
    26d0:	f9 85       	ldd	r31, Y+9	; 0x09
    26d2:	86 85       	ldd	r24, Z+14	; 0x0e
    26d4:	88 2f       	mov	r24, r24
    26d6:	90 e0       	ldi	r25, 0x00	; 0
    26d8:	81 70       	andi	r24, 0x01	; 1
    26da:	90 70       	andi	r25, 0x00	; 0
    26dc:	88 23       	and	r24, r24
    26de:	29 f0       	breq	.+10     	; 0x26ea <xStreamBufferReceiveFromISR+0x54>
	{
		xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
    26e0:	82 e0       	ldi	r24, 0x02	; 2
    26e2:	90 e0       	ldi	r25, 0x00	; 0
    26e4:	9b 83       	std	Y+3, r25	; 0x03
    26e6:	8a 83       	std	Y+2, r24	; 0x02
    26e8:	02 c0       	rjmp	.+4      	; 0x26ee <xStreamBufferReceiveFromISR+0x58>
	}
	else
	{
		xBytesToStoreMessageLength = 0;
    26ea:	1b 82       	std	Y+3, r1	; 0x03
    26ec:	1a 82       	std	Y+2, r1	; 0x02
	}

	xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    26ee:	88 85       	ldd	r24, Y+8	; 0x08
    26f0:	99 85       	ldd	r25, Y+9	; 0x09
    26f2:	0e 94 54 16 	call	0x2ca8	; 0x2ca8 <prvBytesInBuffer>
    26f6:	9d 83       	std	Y+5, r25	; 0x05
    26f8:	8c 83       	std	Y+4, r24	; 0x04
	/* Whether receiving a discrete message (where xBytesToStoreMessageLength
	holds the number of bytes used to store the message length) or a stream of
	bytes (where xBytesToStoreMessageLength is zero), the number of bytes
	available must be greater than xBytesToStoreMessageLength to be able to
	read bytes from the buffer. */
	if( xBytesAvailable > xBytesToStoreMessageLength )
    26fa:	2c 81       	ldd	r18, Y+4	; 0x04
    26fc:	3d 81       	ldd	r19, Y+5	; 0x05
    26fe:	8a 81       	ldd	r24, Y+2	; 0x02
    2700:	9b 81       	ldd	r25, Y+3	; 0x03
    2702:	82 17       	cp	r24, r18
    2704:	93 07       	cpc	r25, r19
    2706:	80 f5       	brcc	.+96     	; 0x2768 <xStreamBufferReceiveFromISR+0xd2>
	{
		xReceivedLength = prvReadMessageFromBuffer( pxStreamBuffer, pvRxData, xBufferLengthBytes, xBytesAvailable, xBytesToStoreMessageLength );
    2708:	88 85       	ldd	r24, Y+8	; 0x08
    270a:	99 85       	ldd	r25, Y+9	; 0x09
    270c:	2c 85       	ldd	r18, Y+12	; 0x0c
    270e:	3d 85       	ldd	r19, Y+13	; 0x0d
    2710:	4e 85       	ldd	r20, Y+14	; 0x0e
    2712:	5f 85       	ldd	r21, Y+15	; 0x0f
    2714:	ec 81       	ldd	r30, Y+4	; 0x04
    2716:	fd 81       	ldd	r31, Y+5	; 0x05
    2718:	aa 81       	ldd	r26, Y+2	; 0x02
    271a:	bb 81       	ldd	r27, Y+3	; 0x03
    271c:	b9 01       	movw	r22, r18
    271e:	9f 01       	movw	r18, r30
    2720:	8d 01       	movw	r16, r26
    2722:	0e 94 c3 13 	call	0x2786	; 0x2786 <prvReadMessageFromBuffer>
    2726:	9f 83       	std	Y+7, r25	; 0x07
    2728:	8e 83       	std	Y+6, r24	; 0x06

		/* Was a task waiting for space in the buffer? */
		if( xReceivedLength != ( size_t ) 0 )
    272a:	8e 81       	ldd	r24, Y+6	; 0x06
    272c:	9f 81       	ldd	r25, Y+7	; 0x07
    272e:	00 97       	sbiw	r24, 0x00	; 0
    2730:	d9 f0       	breq	.+54     	; 0x2768 <xStreamBufferReceiveFromISR+0xd2>
		{
			sbRECEIVE_COMPLETED_FROM_ISR( pxStreamBuffer, pxHigherPriorityTaskWoken );
    2732:	19 82       	std	Y+1, r1	; 0x01
    2734:	e8 85       	ldd	r30, Y+8	; 0x08
    2736:	f9 85       	ldd	r31, Y+9	; 0x09
    2738:	82 85       	ldd	r24, Z+10	; 0x0a
    273a:	93 85       	ldd	r25, Z+11	; 0x0b
    273c:	00 97       	sbiw	r24, 0x00	; 0
    273e:	a1 f0       	breq	.+40     	; 0x2768 <xStreamBufferReceiveFromISR+0xd2>
    2740:	e8 85       	ldd	r30, Y+8	; 0x08
    2742:	f9 85       	ldd	r31, Y+9	; 0x09
    2744:	82 85       	ldd	r24, Z+10	; 0x0a
    2746:	93 85       	ldd	r25, Z+11	; 0x0b
    2748:	e8 89       	ldd	r30, Y+16	; 0x10
    274a:	f9 89       	ldd	r31, Y+17	; 0x11
    274c:	40 e0       	ldi	r20, 0x00	; 0
    274e:	50 e0       	ldi	r21, 0x00	; 0
    2750:	60 e0       	ldi	r22, 0x00	; 0
    2752:	70 e0       	ldi	r23, 0x00	; 0
    2754:	20 e0       	ldi	r18, 0x00	; 0
    2756:	00 e0       	ldi	r16, 0x00	; 0
    2758:	10 e0       	ldi	r17, 0x00	; 0
    275a:	7f 01       	movw	r14, r30
    275c:	0e 94 af 21 	call	0x435e	; 0x435e <xTaskGenericNotifyFromISR>
    2760:	e8 85       	ldd	r30, Y+8	; 0x08
    2762:	f9 85       	ldd	r31, Y+9	; 0x09
    2764:	13 86       	std	Z+11, r1	; 0x0b
    2766:	12 86       	std	Z+10, r1	; 0x0a
		mtCOVERAGE_TEST_MARKER();
	}

	traceSTREAM_BUFFER_RECEIVE_FROM_ISR( xStreamBuffer, xReceivedLength );

	return xReceivedLength;
    2768:	8e 81       	ldd	r24, Y+6	; 0x06
    276a:	9f 81       	ldd	r25, Y+7	; 0x07
}
    276c:	61 96       	adiw	r28, 0x11	; 17
    276e:	0f b6       	in	r0, 0x3f	; 63
    2770:	f8 94       	cli
    2772:	de bf       	out	0x3e, r29	; 62
    2774:	0f be       	out	0x3f, r0	; 63
    2776:	cd bf       	out	0x3d, r28	; 61
    2778:	cf 91       	pop	r28
    277a:	df 91       	pop	r29
    277c:	1f 91       	pop	r17
    277e:	0f 91       	pop	r16
    2780:	ff 90       	pop	r15
    2782:	ef 90       	pop	r14
    2784:	08 95       	ret

00002786 <prvReadMessageFromBuffer>:
static size_t prvReadMessageFromBuffer( StreamBuffer_t *pxStreamBuffer,
										void *pvRxData,
										size_t xBufferLengthBytes,
										size_t xBytesAvailable,
										size_t xBytesToStoreMessageLength )
{
    2786:	0f 93       	push	r16
    2788:	1f 93       	push	r17
    278a:	df 93       	push	r29
    278c:	cf 93       	push	r28
    278e:	cd b7       	in	r28, 0x3d	; 61
    2790:	de b7       	in	r29, 0x3e	; 62
    2792:	62 97       	sbiw	r28, 0x12	; 18
    2794:	0f b6       	in	r0, 0x3f	; 63
    2796:	f8 94       	cli
    2798:	de bf       	out	0x3e, r29	; 62
    279a:	0f be       	out	0x3f, r0	; 63
    279c:	cd bf       	out	0x3d, r28	; 61
    279e:	9a 87       	std	Y+10, r25	; 0x0a
    27a0:	89 87       	std	Y+9, r24	; 0x09
    27a2:	7c 87       	std	Y+12, r23	; 0x0c
    27a4:	6b 87       	std	Y+11, r22	; 0x0b
    27a6:	5e 87       	std	Y+14, r21	; 0x0e
    27a8:	4d 87       	std	Y+13, r20	; 0x0d
    27aa:	38 8b       	std	Y+16, r19	; 0x10
    27ac:	2f 87       	std	Y+15, r18	; 0x0f
    27ae:	1a 8b       	std	Y+18, r17	; 0x12
    27b0:	09 8b       	std	Y+17, r16	; 0x11
size_t xOriginalTail, xReceivedLength, xNextMessageLength;
configMESSAGE_BUFFER_LENGTH_TYPE xTempNextMessageLength;

	if( xBytesToStoreMessageLength != ( size_t ) 0 )
    27b2:	89 89       	ldd	r24, Y+17	; 0x11
    27b4:	9a 89       	ldd	r25, Y+18	; 0x12
    27b6:	00 97       	sbiw	r24, 0x00	; 0
    27b8:	91 f1       	breq	.+100    	; 0x281e <prvReadMessageFromBuffer+0x98>
	{
		/* A discrete message is being received.  First receive the length
		of the message.  A copy of the tail is stored so the buffer can be
		returned to its prior state if the length of the message is too
		large for the provided buffer. */
		xOriginalTail = pxStreamBuffer->xTail;
    27ba:	e9 85       	ldd	r30, Y+9	; 0x09
    27bc:	fa 85       	ldd	r31, Y+10	; 0x0a
    27be:	80 81       	ld	r24, Z
    27c0:	91 81       	ldd	r25, Z+1	; 0x01
    27c2:	9e 83       	std	Y+6, r25	; 0x06
    27c4:	8d 83       	std	Y+5, r24	; 0x05
		( void ) prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) &xTempNextMessageLength, xBytesToStoreMessageLength, xBytesAvailable );
    27c6:	ae 01       	movw	r20, r28
    27c8:	49 5f       	subi	r20, 0xF9	; 249
    27ca:	5f 4f       	sbci	r21, 0xFF	; 255
    27cc:	89 85       	ldd	r24, Y+9	; 0x09
    27ce:	9a 85       	ldd	r25, Y+10	; 0x0a
    27d0:	29 89       	ldd	r18, Y+17	; 0x11
    27d2:	3a 89       	ldd	r19, Y+18	; 0x12
    27d4:	ef 85       	ldd	r30, Y+15	; 0x0f
    27d6:	f8 89       	ldd	r31, Y+16	; 0x10
    27d8:	ba 01       	movw	r22, r20
    27da:	a9 01       	movw	r20, r18
    27dc:	9f 01       	movw	r18, r30
    27de:	0e 94 a7 15 	call	0x2b4e	; 0x2b4e <prvReadBytesFromBuffer>
		xNextMessageLength = ( size_t ) xTempNextMessageLength;
    27e2:	8f 81       	ldd	r24, Y+7	; 0x07
    27e4:	98 85       	ldd	r25, Y+8	; 0x08
    27e6:	9a 83       	std	Y+2, r25	; 0x02
    27e8:	89 83       	std	Y+1, r24	; 0x01

		/* Reduce the number of bytes available by the number of bytes just
		read out. */
		xBytesAvailable -= xBytesToStoreMessageLength;
    27ea:	2f 85       	ldd	r18, Y+15	; 0x0f
    27ec:	38 89       	ldd	r19, Y+16	; 0x10
    27ee:	89 89       	ldd	r24, Y+17	; 0x11
    27f0:	9a 89       	ldd	r25, Y+18	; 0x12
    27f2:	a9 01       	movw	r20, r18
    27f4:	48 1b       	sub	r20, r24
    27f6:	59 0b       	sbc	r21, r25
    27f8:	ca 01       	movw	r24, r20
    27fa:	98 8b       	std	Y+16, r25	; 0x10
    27fc:	8f 87       	std	Y+15, r24	; 0x0f

		/* Check there is enough space in the buffer provided by the
		user. */
		if( xNextMessageLength > xBufferLengthBytes )
    27fe:	29 81       	ldd	r18, Y+1	; 0x01
    2800:	3a 81       	ldd	r19, Y+2	; 0x02
    2802:	8d 85       	ldd	r24, Y+13	; 0x0d
    2804:	9e 85       	ldd	r25, Y+14	; 0x0e
    2806:	82 17       	cp	r24, r18
    2808:	93 07       	cpc	r25, r19
    280a:	68 f4       	brcc	.+26     	; 0x2826 <prvReadMessageFromBuffer+0xa0>
		{
			/* The user has provided insufficient space to read the message
			so return the buffer to its previous state (so the length of
			the message is in the buffer again). */
			pxStreamBuffer->xTail = xOriginalTail;
    280c:	e9 85       	ldd	r30, Y+9	; 0x09
    280e:	fa 85       	ldd	r31, Y+10	; 0x0a
    2810:	8d 81       	ldd	r24, Y+5	; 0x05
    2812:	9e 81       	ldd	r25, Y+6	; 0x06
    2814:	91 83       	std	Z+1, r25	; 0x01
    2816:	80 83       	st	Z, r24
			xNextMessageLength = 0;
    2818:	1a 82       	std	Y+2, r1	; 0x02
    281a:	19 82       	std	Y+1, r1	; 0x01
    281c:	04 c0       	rjmp	.+8      	; 0x2826 <prvReadMessageFromBuffer+0xa0>
	}
	else
	{
		/* A stream of bytes is being received (as opposed to a discrete
		message), so read as many bytes as possible. */
		xNextMessageLength = xBufferLengthBytes;
    281e:	8d 85       	ldd	r24, Y+13	; 0x0d
    2820:	9e 85       	ldd	r25, Y+14	; 0x0e
    2822:	9a 83       	std	Y+2, r25	; 0x02
    2824:	89 83       	std	Y+1, r24	; 0x01
	}

	/* Read the actual data. */
	xReceivedLength = prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) pvRxData, xNextMessageLength, xBytesAvailable ); /*lint !e9079 Data storage area is implemented as uint8_t array for ease of sizing, indexing and alignment. */
    2826:	4b 85       	ldd	r20, Y+11	; 0x0b
    2828:	5c 85       	ldd	r21, Y+12	; 0x0c
    282a:	89 85       	ldd	r24, Y+9	; 0x09
    282c:	9a 85       	ldd	r25, Y+10	; 0x0a
    282e:	29 81       	ldd	r18, Y+1	; 0x01
    2830:	3a 81       	ldd	r19, Y+2	; 0x02
    2832:	ef 85       	ldd	r30, Y+15	; 0x0f
    2834:	f8 89       	ldd	r31, Y+16	; 0x10
    2836:	ba 01       	movw	r22, r20
    2838:	a9 01       	movw	r20, r18
    283a:	9f 01       	movw	r18, r30
    283c:	0e 94 a7 15 	call	0x2b4e	; 0x2b4e <prvReadBytesFromBuffer>
    2840:	9c 83       	std	Y+4, r25	; 0x04
    2842:	8b 83       	std	Y+3, r24	; 0x03

	return xReceivedLength;
    2844:	8b 81       	ldd	r24, Y+3	; 0x03
    2846:	9c 81       	ldd	r25, Y+4	; 0x04
}
    2848:	62 96       	adiw	r28, 0x12	; 18
    284a:	0f b6       	in	r0, 0x3f	; 63
    284c:	f8 94       	cli
    284e:	de bf       	out	0x3e, r29	; 62
    2850:	0f be       	out	0x3f, r0	; 63
    2852:	cd bf       	out	0x3d, r28	; 61
    2854:	cf 91       	pop	r28
    2856:	df 91       	pop	r29
    2858:	1f 91       	pop	r17
    285a:	0f 91       	pop	r16
    285c:	08 95       	ret

0000285e <xStreamBufferIsEmpty>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferIsEmpty( StreamBufferHandle_t xStreamBuffer )
{
    285e:	df 93       	push	r29
    2860:	cf 93       	push	r28
    2862:	cd b7       	in	r28, 0x3d	; 61
    2864:	de b7       	in	r29, 0x3e	; 62
    2866:	27 97       	sbiw	r28, 0x07	; 7
    2868:	0f b6       	in	r0, 0x3f	; 63
    286a:	f8 94       	cli
    286c:	de bf       	out	0x3e, r29	; 62
    286e:	0f be       	out	0x3f, r0	; 63
    2870:	cd bf       	out	0x3d, r28	; 61
    2872:	9f 83       	std	Y+7, r25	; 0x07
    2874:	8e 83       	std	Y+6, r24	; 0x06
const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    2876:	8e 81       	ldd	r24, Y+6	; 0x06
    2878:	9f 81       	ldd	r25, Y+7	; 0x07
    287a:	9d 83       	std	Y+5, r25	; 0x05
    287c:	8c 83       	std	Y+4, r24	; 0x04
size_t xTail;

	configASSERT( pxStreamBuffer );

	/* True if no bytes are available. */
	xTail = pxStreamBuffer->xTail;
    287e:	ec 81       	ldd	r30, Y+4	; 0x04
    2880:	fd 81       	ldd	r31, Y+5	; 0x05
    2882:	80 81       	ld	r24, Z
    2884:	91 81       	ldd	r25, Z+1	; 0x01
    2886:	9a 83       	std	Y+2, r25	; 0x02
    2888:	89 83       	std	Y+1, r24	; 0x01
	if( pxStreamBuffer->xHead == xTail )
    288a:	ec 81       	ldd	r30, Y+4	; 0x04
    288c:	fd 81       	ldd	r31, Y+5	; 0x05
    288e:	22 81       	ldd	r18, Z+2	; 0x02
    2890:	33 81       	ldd	r19, Z+3	; 0x03
    2892:	89 81       	ldd	r24, Y+1	; 0x01
    2894:	9a 81       	ldd	r25, Y+2	; 0x02
    2896:	28 17       	cp	r18, r24
    2898:	39 07       	cpc	r19, r25
    289a:	19 f4       	brne	.+6      	; 0x28a2 <xStreamBufferIsEmpty+0x44>
	{
		xReturn = pdTRUE;
    289c:	81 e0       	ldi	r24, 0x01	; 1
    289e:	8b 83       	std	Y+3, r24	; 0x03
    28a0:	01 c0       	rjmp	.+2      	; 0x28a4 <xStreamBufferIsEmpty+0x46>
	}
	else
	{
		xReturn = pdFALSE;
    28a2:	1b 82       	std	Y+3, r1	; 0x03
	}

	return xReturn;
    28a4:	8b 81       	ldd	r24, Y+3	; 0x03
}
    28a6:	27 96       	adiw	r28, 0x07	; 7
    28a8:	0f b6       	in	r0, 0x3f	; 63
    28aa:	f8 94       	cli
    28ac:	de bf       	out	0x3e, r29	; 62
    28ae:	0f be       	out	0x3f, r0	; 63
    28b0:	cd bf       	out	0x3d, r28	; 61
    28b2:	cf 91       	pop	r28
    28b4:	df 91       	pop	r29
    28b6:	08 95       	ret

000028b8 <xStreamBufferIsFull>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferIsFull( StreamBufferHandle_t xStreamBuffer )
{
    28b8:	df 93       	push	r29
    28ba:	cf 93       	push	r28
    28bc:	cd b7       	in	r28, 0x3d	; 61
    28be:	de b7       	in	r29, 0x3e	; 62
    28c0:	27 97       	sbiw	r28, 0x07	; 7
    28c2:	0f b6       	in	r0, 0x3f	; 63
    28c4:	f8 94       	cli
    28c6:	de bf       	out	0x3e, r29	; 62
    28c8:	0f be       	out	0x3f, r0	; 63
    28ca:	cd bf       	out	0x3d, r28	; 61
    28cc:	9f 83       	std	Y+7, r25	; 0x07
    28ce:	8e 83       	std	Y+6, r24	; 0x06
BaseType_t xReturn;
size_t xBytesToStoreMessageLength;
const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    28d0:	8e 81       	ldd	r24, Y+6	; 0x06
    28d2:	9f 81       	ldd	r25, Y+7	; 0x07
    28d4:	9a 83       	std	Y+2, r25	; 0x02
    28d6:	89 83       	std	Y+1, r24	; 0x01

	/* This generic version of the receive function is used by both message
	buffers, which store discrete messages, and stream buffers, which store a
	continuous stream of bytes.  Discrete messages include an additional
	sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the message. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    28d8:	e9 81       	ldd	r30, Y+1	; 0x01
    28da:	fa 81       	ldd	r31, Y+2	; 0x02
    28dc:	86 85       	ldd	r24, Z+14	; 0x0e
    28de:	88 2f       	mov	r24, r24
    28e0:	90 e0       	ldi	r25, 0x00	; 0
    28e2:	81 70       	andi	r24, 0x01	; 1
    28e4:	90 70       	andi	r25, 0x00	; 0
    28e6:	88 23       	and	r24, r24
    28e8:	29 f0       	breq	.+10     	; 0x28f4 <xStreamBufferIsFull+0x3c>
	{
		xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
    28ea:	82 e0       	ldi	r24, 0x02	; 2
    28ec:	90 e0       	ldi	r25, 0x00	; 0
    28ee:	9c 83       	std	Y+4, r25	; 0x04
    28f0:	8b 83       	std	Y+3, r24	; 0x03
    28f2:	02 c0       	rjmp	.+4      	; 0x28f8 <xStreamBufferIsFull+0x40>
	}
	else
	{
		xBytesToStoreMessageLength = 0;
    28f4:	1c 82       	std	Y+4, r1	; 0x04
    28f6:	1b 82       	std	Y+3, r1	; 0x03
	}

	/* True if the available space equals zero. */
	if( xStreamBufferSpacesAvailable( xStreamBuffer ) <= xBytesToStoreMessageLength )
    28f8:	8e 81       	ldd	r24, Y+6	; 0x06
    28fa:	9f 81       	ldd	r25, Y+7	; 0x07
    28fc:	0e 94 24 10 	call	0x2048	; 0x2048 <xStreamBufferSpacesAvailable>
    2900:	9c 01       	movw	r18, r24
    2902:	8b 81       	ldd	r24, Y+3	; 0x03
    2904:	9c 81       	ldd	r25, Y+4	; 0x04
    2906:	82 17       	cp	r24, r18
    2908:	93 07       	cpc	r25, r19
    290a:	18 f0       	brcs	.+6      	; 0x2912 <xStreamBufferIsFull+0x5a>
	{
		xReturn = pdTRUE;
    290c:	81 e0       	ldi	r24, 0x01	; 1
    290e:	8d 83       	std	Y+5, r24	; 0x05
    2910:	01 c0       	rjmp	.+2      	; 0x2914 <xStreamBufferIsFull+0x5c>
	}
	else
	{
		xReturn = pdFALSE;
    2912:	1d 82       	std	Y+5, r1	; 0x05
	}

	return xReturn;
    2914:	8d 81       	ldd	r24, Y+5	; 0x05
}
    2916:	27 96       	adiw	r28, 0x07	; 7
    2918:	0f b6       	in	r0, 0x3f	; 63
    291a:	f8 94       	cli
    291c:	de bf       	out	0x3e, r29	; 62
    291e:	0f be       	out	0x3f, r0	; 63
    2920:	cd bf       	out	0x3d, r28	; 61
    2922:	cf 91       	pop	r28
    2924:	df 91       	pop	r29
    2926:	08 95       	ret

00002928 <xStreamBufferSendCompletedFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferSendCompletedFromISR( StreamBufferHandle_t xStreamBuffer, BaseType_t *pxHigherPriorityTaskWoken )
{
    2928:	ef 92       	push	r14
    292a:	ff 92       	push	r15
    292c:	0f 93       	push	r16
    292e:	1f 93       	push	r17
    2930:	df 93       	push	r29
    2932:	cf 93       	push	r28
    2934:	cd b7       	in	r28, 0x3d	; 61
    2936:	de b7       	in	r29, 0x3e	; 62
    2938:	28 97       	sbiw	r28, 0x08	; 8
    293a:	0f b6       	in	r0, 0x3f	; 63
    293c:	f8 94       	cli
    293e:	de bf       	out	0x3e, r29	; 62
    2940:	0f be       	out	0x3f, r0	; 63
    2942:	cd bf       	out	0x3d, r28	; 61
    2944:	9e 83       	std	Y+6, r25	; 0x06
    2946:	8d 83       	std	Y+5, r24	; 0x05
    2948:	78 87       	std	Y+8, r23	; 0x08
    294a:	6f 83       	std	Y+7, r22	; 0x07
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    294c:	8d 81       	ldd	r24, Y+5	; 0x05
    294e:	9e 81       	ldd	r25, Y+6	; 0x06
    2950:	9c 83       	std	Y+4, r25	; 0x04
    2952:	8b 83       	std	Y+3, r24	; 0x03
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;

	configASSERT( pxStreamBuffer );

	uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();
    2954:	19 82       	std	Y+1, r1	; 0x01
	{
		if( ( pxStreamBuffer )->xTaskWaitingToReceive != NULL )
    2956:	eb 81       	ldd	r30, Y+3	; 0x03
    2958:	fc 81       	ldd	r31, Y+4	; 0x04
    295a:	80 85       	ldd	r24, Z+8	; 0x08
    295c:	91 85       	ldd	r25, Z+9	; 0x09
    295e:	00 97       	sbiw	r24, 0x00	; 0
    2960:	b9 f0       	breq	.+46     	; 0x2990 <xStreamBufferSendCompletedFromISR+0x68>
		{
			( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToReceive,
    2962:	eb 81       	ldd	r30, Y+3	; 0x03
    2964:	fc 81       	ldd	r31, Y+4	; 0x04
    2966:	80 85       	ldd	r24, Z+8	; 0x08
    2968:	91 85       	ldd	r25, Z+9	; 0x09
    296a:	ef 81       	ldd	r30, Y+7	; 0x07
    296c:	f8 85       	ldd	r31, Y+8	; 0x08
    296e:	40 e0       	ldi	r20, 0x00	; 0
    2970:	50 e0       	ldi	r21, 0x00	; 0
    2972:	60 e0       	ldi	r22, 0x00	; 0
    2974:	70 e0       	ldi	r23, 0x00	; 0
    2976:	20 e0       	ldi	r18, 0x00	; 0
    2978:	00 e0       	ldi	r16, 0x00	; 0
    297a:	10 e0       	ldi	r17, 0x00	; 0
    297c:	7f 01       	movw	r14, r30
    297e:	0e 94 af 21 	call	0x435e	; 0x435e <xTaskGenericNotifyFromISR>
										 ( uint32_t ) 0,
										 eNoAction,
										 pxHigherPriorityTaskWoken );
			( pxStreamBuffer )->xTaskWaitingToReceive = NULL;
    2982:	eb 81       	ldd	r30, Y+3	; 0x03
    2984:	fc 81       	ldd	r31, Y+4	; 0x04
    2986:	11 86       	std	Z+9, r1	; 0x09
    2988:	10 86       	std	Z+8, r1	; 0x08
			xReturn = pdTRUE;
    298a:	81 e0       	ldi	r24, 0x01	; 1
    298c:	8a 83       	std	Y+2, r24	; 0x02
    298e:	01 c0       	rjmp	.+2      	; 0x2992 <xStreamBufferSendCompletedFromISR+0x6a>
		}
		else
		{
			xReturn = pdFALSE;
    2990:	1a 82       	std	Y+2, r1	; 0x02
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    2992:	8a 81       	ldd	r24, Y+2	; 0x02
}
    2994:	28 96       	adiw	r28, 0x08	; 8
    2996:	0f b6       	in	r0, 0x3f	; 63
    2998:	f8 94       	cli
    299a:	de bf       	out	0x3e, r29	; 62
    299c:	0f be       	out	0x3f, r0	; 63
    299e:	cd bf       	out	0x3d, r28	; 61
    29a0:	cf 91       	pop	r28
    29a2:	df 91       	pop	r29
    29a4:	1f 91       	pop	r17
    29a6:	0f 91       	pop	r16
    29a8:	ff 90       	pop	r15
    29aa:	ef 90       	pop	r14
    29ac:	08 95       	ret

000029ae <xStreamBufferReceiveCompletedFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferReceiveCompletedFromISR( StreamBufferHandle_t xStreamBuffer, BaseType_t *pxHigherPriorityTaskWoken )
{
    29ae:	ef 92       	push	r14
    29b0:	ff 92       	push	r15
    29b2:	0f 93       	push	r16
    29b4:	1f 93       	push	r17
    29b6:	df 93       	push	r29
    29b8:	cf 93       	push	r28
    29ba:	cd b7       	in	r28, 0x3d	; 61
    29bc:	de b7       	in	r29, 0x3e	; 62
    29be:	28 97       	sbiw	r28, 0x08	; 8
    29c0:	0f b6       	in	r0, 0x3f	; 63
    29c2:	f8 94       	cli
    29c4:	de bf       	out	0x3e, r29	; 62
    29c6:	0f be       	out	0x3f, r0	; 63
    29c8:	cd bf       	out	0x3d, r28	; 61
    29ca:	9e 83       	std	Y+6, r25	; 0x06
    29cc:	8d 83       	std	Y+5, r24	; 0x05
    29ce:	78 87       	std	Y+8, r23	; 0x08
    29d0:	6f 83       	std	Y+7, r22	; 0x07
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    29d2:	8d 81       	ldd	r24, Y+5	; 0x05
    29d4:	9e 81       	ldd	r25, Y+6	; 0x06
    29d6:	9c 83       	std	Y+4, r25	; 0x04
    29d8:	8b 83       	std	Y+3, r24	; 0x03
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;

	configASSERT( pxStreamBuffer );

	uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();
    29da:	19 82       	std	Y+1, r1	; 0x01
	{
		if( ( pxStreamBuffer )->xTaskWaitingToSend != NULL )
    29dc:	eb 81       	ldd	r30, Y+3	; 0x03
    29de:	fc 81       	ldd	r31, Y+4	; 0x04
    29e0:	82 85       	ldd	r24, Z+10	; 0x0a
    29e2:	93 85       	ldd	r25, Z+11	; 0x0b
    29e4:	00 97       	sbiw	r24, 0x00	; 0
    29e6:	b9 f0       	breq	.+46     	; 0x2a16 <xStreamBufferReceiveCompletedFromISR+0x68>
		{
			( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToSend,
    29e8:	eb 81       	ldd	r30, Y+3	; 0x03
    29ea:	fc 81       	ldd	r31, Y+4	; 0x04
    29ec:	82 85       	ldd	r24, Z+10	; 0x0a
    29ee:	93 85       	ldd	r25, Z+11	; 0x0b
    29f0:	ef 81       	ldd	r30, Y+7	; 0x07
    29f2:	f8 85       	ldd	r31, Y+8	; 0x08
    29f4:	40 e0       	ldi	r20, 0x00	; 0
    29f6:	50 e0       	ldi	r21, 0x00	; 0
    29f8:	60 e0       	ldi	r22, 0x00	; 0
    29fa:	70 e0       	ldi	r23, 0x00	; 0
    29fc:	20 e0       	ldi	r18, 0x00	; 0
    29fe:	00 e0       	ldi	r16, 0x00	; 0
    2a00:	10 e0       	ldi	r17, 0x00	; 0
    2a02:	7f 01       	movw	r14, r30
    2a04:	0e 94 af 21 	call	0x435e	; 0x435e <xTaskGenericNotifyFromISR>
										 ( uint32_t ) 0,
										 eNoAction,
										 pxHigherPriorityTaskWoken );
			( pxStreamBuffer )->xTaskWaitingToSend = NULL;
    2a08:	eb 81       	ldd	r30, Y+3	; 0x03
    2a0a:	fc 81       	ldd	r31, Y+4	; 0x04
    2a0c:	13 86       	std	Z+11, r1	; 0x0b
    2a0e:	12 86       	std	Z+10, r1	; 0x0a
			xReturn = pdTRUE;
    2a10:	81 e0       	ldi	r24, 0x01	; 1
    2a12:	8a 83       	std	Y+2, r24	; 0x02
    2a14:	01 c0       	rjmp	.+2      	; 0x2a18 <xStreamBufferReceiveCompletedFromISR+0x6a>
		}
		else
		{
			xReturn = pdFALSE;
    2a16:	1a 82       	std	Y+2, r1	; 0x02
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    2a18:	8a 81       	ldd	r24, Y+2	; 0x02
}
    2a1a:	28 96       	adiw	r28, 0x08	; 8
    2a1c:	0f b6       	in	r0, 0x3f	; 63
    2a1e:	f8 94       	cli
    2a20:	de bf       	out	0x3e, r29	; 62
    2a22:	0f be       	out	0x3f, r0	; 63
    2a24:	cd bf       	out	0x3d, r28	; 61
    2a26:	cf 91       	pop	r28
    2a28:	df 91       	pop	r29
    2a2a:	1f 91       	pop	r17
    2a2c:	0f 91       	pop	r16
    2a2e:	ff 90       	pop	r15
    2a30:	ef 90       	pop	r14
    2a32:	08 95       	ret

00002a34 <prvWriteBytesToBuffer>:
/*-----------------------------------------------------------*/

static size_t prvWriteBytesToBuffer( StreamBuffer_t * const pxStreamBuffer, const uint8_t *pucData, size_t xCount )
{
    2a34:	df 93       	push	r29
    2a36:	cf 93       	push	r28
    2a38:	cd b7       	in	r28, 0x3d	; 61
    2a3a:	de b7       	in	r29, 0x3e	; 62
    2a3c:	2e 97       	sbiw	r28, 0x0e	; 14
    2a3e:	0f b6       	in	r0, 0x3f	; 63
    2a40:	f8 94       	cli
    2a42:	de bf       	out	0x3e, r29	; 62
    2a44:	0f be       	out	0x3f, r0	; 63
    2a46:	cd bf       	out	0x3d, r28	; 61
    2a48:	9e 83       	std	Y+6, r25	; 0x06
    2a4a:	8d 83       	std	Y+5, r24	; 0x05
    2a4c:	78 87       	std	Y+8, r23	; 0x08
    2a4e:	6f 83       	std	Y+7, r22	; 0x07
    2a50:	5a 87       	std	Y+10, r21	; 0x0a
    2a52:	49 87       	std	Y+9, r20	; 0x09
size_t xNextHead, xFirstLength;

	configASSERT( xCount > ( size_t ) 0 );

	xNextHead = pxStreamBuffer->xHead;
    2a54:	ed 81       	ldd	r30, Y+5	; 0x05
    2a56:	fe 81       	ldd	r31, Y+6	; 0x06
    2a58:	82 81       	ldd	r24, Z+2	; 0x02
    2a5a:	93 81       	ldd	r25, Z+3	; 0x03
    2a5c:	9c 83       	std	Y+4, r25	; 0x04
    2a5e:	8b 83       	std	Y+3, r24	; 0x03

	/* Calculate the number of bytes that can be added in the first write -
	which may be less than the total number of bytes that need to be added if
	the buffer will wrap back to the beginning. */
	xFirstLength = configMIN( pxStreamBuffer->xLength - xNextHead, xCount );
    2a60:	ed 81       	ldd	r30, Y+5	; 0x05
    2a62:	fe 81       	ldd	r31, Y+6	; 0x06
    2a64:	24 81       	ldd	r18, Z+4	; 0x04
    2a66:	35 81       	ldd	r19, Z+5	; 0x05
    2a68:	8b 81       	ldd	r24, Y+3	; 0x03
    2a6a:	9c 81       	ldd	r25, Y+4	; 0x04
    2a6c:	a9 01       	movw	r20, r18
    2a6e:	48 1b       	sub	r20, r24
    2a70:	59 0b       	sbc	r21, r25
    2a72:	ca 01       	movw	r24, r20
    2a74:	29 85       	ldd	r18, Y+9	; 0x09
    2a76:	3a 85       	ldd	r19, Y+10	; 0x0a
    2a78:	3e 87       	std	Y+14, r19	; 0x0e
    2a7a:	2d 87       	std	Y+13, r18	; 0x0d
    2a7c:	9c 87       	std	Y+12, r25	; 0x0c
    2a7e:	8b 87       	std	Y+11, r24	; 0x0b
    2a80:	4b 85       	ldd	r20, Y+11	; 0x0b
    2a82:	5c 85       	ldd	r21, Y+12	; 0x0c
    2a84:	8d 85       	ldd	r24, Y+13	; 0x0d
    2a86:	9e 85       	ldd	r25, Y+14	; 0x0e
    2a88:	84 17       	cp	r24, r20
    2a8a:	95 07       	cpc	r25, r21
    2a8c:	20 f4       	brcc	.+8      	; 0x2a96 <prvWriteBytesToBuffer+0x62>
    2a8e:	2d 85       	ldd	r18, Y+13	; 0x0d
    2a90:	3e 85       	ldd	r19, Y+14	; 0x0e
    2a92:	3c 87       	std	Y+12, r19	; 0x0c
    2a94:	2b 87       	std	Y+11, r18	; 0x0b
    2a96:	4b 85       	ldd	r20, Y+11	; 0x0b
    2a98:	5c 85       	ldd	r21, Y+12	; 0x0c
    2a9a:	5a 83       	std	Y+2, r21	; 0x02
    2a9c:	49 83       	std	Y+1, r20	; 0x01

	/* Write as many bytes as can be written in the first write. */
	configASSERT( ( xNextHead + xFirstLength ) <= pxStreamBuffer->xLength );
	( void ) memcpy( ( void* ) ( &( pxStreamBuffer->pucBuffer[ xNextHead ] ) ), ( const void * ) pucData, xFirstLength ); /*lint !e9087 memcpy() requires void *. */
    2a9e:	ed 81       	ldd	r30, Y+5	; 0x05
    2aa0:	fe 81       	ldd	r31, Y+6	; 0x06
    2aa2:	24 85       	ldd	r18, Z+12	; 0x0c
    2aa4:	35 85       	ldd	r19, Z+13	; 0x0d
    2aa6:	8b 81       	ldd	r24, Y+3	; 0x03
    2aa8:	9c 81       	ldd	r25, Y+4	; 0x04
    2aaa:	82 0f       	add	r24, r18
    2aac:	93 1f       	adc	r25, r19
    2aae:	2f 81       	ldd	r18, Y+7	; 0x07
    2ab0:	38 85       	ldd	r19, Y+8	; 0x08
    2ab2:	49 81       	ldd	r20, Y+1	; 0x01
    2ab4:	5a 81       	ldd	r21, Y+2	; 0x02
    2ab6:	b9 01       	movw	r22, r18
    2ab8:	0e 94 87 24 	call	0x490e	; 0x490e <memcpy>

	/* If the number of bytes written was less than the number that could be
	written in the first write... */
	if( xCount > xFirstLength )
    2abc:	29 85       	ldd	r18, Y+9	; 0x09
    2abe:	3a 85       	ldd	r19, Y+10	; 0x0a
    2ac0:	89 81       	ldd	r24, Y+1	; 0x01
    2ac2:	9a 81       	ldd	r25, Y+2	; 0x02
    2ac4:	82 17       	cp	r24, r18
    2ac6:	93 07       	cpc	r25, r19
    2ac8:	b0 f4       	brcc	.+44     	; 0x2af6 <prvWriteBytesToBuffer+0xc2>
	{
		/* ...then write the remaining bytes to the start of the buffer. */
		configASSERT( ( xCount - xFirstLength ) <= pxStreamBuffer->xLength );
		( void ) memcpy( ( void * ) pxStreamBuffer->pucBuffer, ( const void * ) &( pucData[ xFirstLength ] ), xCount - xFirstLength ); /*lint !e9087 memcpy() requires void *. */
    2aca:	ed 81       	ldd	r30, Y+5	; 0x05
    2acc:	fe 81       	ldd	r31, Y+6	; 0x06
    2ace:	64 85       	ldd	r22, Z+12	; 0x0c
    2ad0:	75 85       	ldd	r23, Z+13	; 0x0d
    2ad2:	2f 81       	ldd	r18, Y+7	; 0x07
    2ad4:	38 85       	ldd	r19, Y+8	; 0x08
    2ad6:	89 81       	ldd	r24, Y+1	; 0x01
    2ad8:	9a 81       	ldd	r25, Y+2	; 0x02
    2ada:	a9 01       	movw	r20, r18
    2adc:	48 0f       	add	r20, r24
    2ade:	59 1f       	adc	r21, r25
    2ae0:	29 85       	ldd	r18, Y+9	; 0x09
    2ae2:	3a 85       	ldd	r19, Y+10	; 0x0a
    2ae4:	89 81       	ldd	r24, Y+1	; 0x01
    2ae6:	9a 81       	ldd	r25, Y+2	; 0x02
    2ae8:	28 1b       	sub	r18, r24
    2aea:	39 0b       	sbc	r19, r25
    2aec:	cb 01       	movw	r24, r22
    2aee:	ba 01       	movw	r22, r20
    2af0:	a9 01       	movw	r20, r18
    2af2:	0e 94 87 24 	call	0x490e	; 0x490e <memcpy>
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	xNextHead += xCount;
    2af6:	2b 81       	ldd	r18, Y+3	; 0x03
    2af8:	3c 81       	ldd	r19, Y+4	; 0x04
    2afa:	89 85       	ldd	r24, Y+9	; 0x09
    2afc:	9a 85       	ldd	r25, Y+10	; 0x0a
    2afe:	82 0f       	add	r24, r18
    2b00:	93 1f       	adc	r25, r19
    2b02:	9c 83       	std	Y+4, r25	; 0x04
    2b04:	8b 83       	std	Y+3, r24	; 0x03
	if( xNextHead >= pxStreamBuffer->xLength )
    2b06:	ed 81       	ldd	r30, Y+5	; 0x05
    2b08:	fe 81       	ldd	r31, Y+6	; 0x06
    2b0a:	24 81       	ldd	r18, Z+4	; 0x04
    2b0c:	35 81       	ldd	r19, Z+5	; 0x05
    2b0e:	8b 81       	ldd	r24, Y+3	; 0x03
    2b10:	9c 81       	ldd	r25, Y+4	; 0x04
    2b12:	82 17       	cp	r24, r18
    2b14:	93 07       	cpc	r25, r19
    2b16:	50 f0       	brcs	.+20     	; 0x2b2c <prvWriteBytesToBuffer+0xf8>
	{
		xNextHead -= pxStreamBuffer->xLength;
    2b18:	ed 81       	ldd	r30, Y+5	; 0x05
    2b1a:	fe 81       	ldd	r31, Y+6	; 0x06
    2b1c:	24 81       	ldd	r18, Z+4	; 0x04
    2b1e:	35 81       	ldd	r19, Z+5	; 0x05
    2b20:	8b 81       	ldd	r24, Y+3	; 0x03
    2b22:	9c 81       	ldd	r25, Y+4	; 0x04
    2b24:	82 1b       	sub	r24, r18
    2b26:	93 0b       	sbc	r25, r19
    2b28:	9c 83       	std	Y+4, r25	; 0x04
    2b2a:	8b 83       	std	Y+3, r24	; 0x03
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxStreamBuffer->xHead = xNextHead;
    2b2c:	ed 81       	ldd	r30, Y+5	; 0x05
    2b2e:	fe 81       	ldd	r31, Y+6	; 0x06
    2b30:	8b 81       	ldd	r24, Y+3	; 0x03
    2b32:	9c 81       	ldd	r25, Y+4	; 0x04
    2b34:	93 83       	std	Z+3, r25	; 0x03
    2b36:	82 83       	std	Z+2, r24	; 0x02

	return xCount;
    2b38:	89 85       	ldd	r24, Y+9	; 0x09
    2b3a:	9a 85       	ldd	r25, Y+10	; 0x0a
}
    2b3c:	2e 96       	adiw	r28, 0x0e	; 14
    2b3e:	0f b6       	in	r0, 0x3f	; 63
    2b40:	f8 94       	cli
    2b42:	de bf       	out	0x3e, r29	; 62
    2b44:	0f be       	out	0x3f, r0	; 63
    2b46:	cd bf       	out	0x3d, r28	; 61
    2b48:	cf 91       	pop	r28
    2b4a:	df 91       	pop	r29
    2b4c:	08 95       	ret

00002b4e <prvReadBytesFromBuffer>:
/*-----------------------------------------------------------*/

static size_t prvReadBytesFromBuffer( StreamBuffer_t *pxStreamBuffer, uint8_t *pucData, size_t xMaxCount, size_t xBytesAvailable )
{
    2b4e:	df 93       	push	r29
    2b50:	cf 93       	push	r28
    2b52:	cd b7       	in	r28, 0x3d	; 61
    2b54:	de b7       	in	r29, 0x3e	; 62
    2b56:	66 97       	sbiw	r28, 0x16	; 22
    2b58:	0f b6       	in	r0, 0x3f	; 63
    2b5a:	f8 94       	cli
    2b5c:	de bf       	out	0x3e, r29	; 62
    2b5e:	0f be       	out	0x3f, r0	; 63
    2b60:	cd bf       	out	0x3d, r28	; 61
    2b62:	98 87       	std	Y+8, r25	; 0x08
    2b64:	8f 83       	std	Y+7, r24	; 0x07
    2b66:	7a 87       	std	Y+10, r23	; 0x0a
    2b68:	69 87       	std	Y+9, r22	; 0x09
    2b6a:	5c 87       	std	Y+12, r21	; 0x0c
    2b6c:	4b 87       	std	Y+11, r20	; 0x0b
    2b6e:	3e 87       	std	Y+14, r19	; 0x0e
    2b70:	2d 87       	std	Y+13, r18	; 0x0d
size_t xCount, xFirstLength, xNextTail;

	/* Use the minimum of the wanted bytes and the available bytes. */
	xCount = configMIN( xBytesAvailable, xMaxCount );
    2b72:	2d 85       	ldd	r18, Y+13	; 0x0d
    2b74:	3e 85       	ldd	r19, Y+14	; 0x0e
    2b76:	3a 8b       	std	Y+18, r19	; 0x12
    2b78:	29 8b       	std	Y+17, r18	; 0x11
    2b7a:	4b 85       	ldd	r20, Y+11	; 0x0b
    2b7c:	5c 85       	ldd	r21, Y+12	; 0x0c
    2b7e:	58 8b       	std	Y+16, r21	; 0x10
    2b80:	4f 87       	std	Y+15, r20	; 0x0f
    2b82:	8f 85       	ldd	r24, Y+15	; 0x0f
    2b84:	98 89       	ldd	r25, Y+16	; 0x10
    2b86:	29 89       	ldd	r18, Y+17	; 0x11
    2b88:	3a 89       	ldd	r19, Y+18	; 0x12
    2b8a:	28 17       	cp	r18, r24
    2b8c:	39 07       	cpc	r19, r25
    2b8e:	20 f4       	brcc	.+8      	; 0x2b98 <prvReadBytesFromBuffer+0x4a>
    2b90:	49 89       	ldd	r20, Y+17	; 0x11
    2b92:	5a 89       	ldd	r21, Y+18	; 0x12
    2b94:	58 8b       	std	Y+16, r21	; 0x10
    2b96:	4f 87       	std	Y+15, r20	; 0x0f
    2b98:	8f 85       	ldd	r24, Y+15	; 0x0f
    2b9a:	98 89       	ldd	r25, Y+16	; 0x10
    2b9c:	9e 83       	std	Y+6, r25	; 0x06
    2b9e:	8d 83       	std	Y+5, r24	; 0x05

	if( xCount > ( size_t ) 0 )
    2ba0:	8d 81       	ldd	r24, Y+5	; 0x05
    2ba2:	9e 81       	ldd	r25, Y+6	; 0x06
    2ba4:	00 97       	sbiw	r24, 0x00	; 0
    2ba6:	09 f4       	brne	.+2      	; 0x2baa <prvReadBytesFromBuffer+0x5c>
    2ba8:	74 c0       	rjmp	.+232    	; 0x2c92 <prvReadBytesFromBuffer+0x144>
	{
		xNextTail = pxStreamBuffer->xTail;
    2baa:	ef 81       	ldd	r30, Y+7	; 0x07
    2bac:	f8 85       	ldd	r31, Y+8	; 0x08
    2bae:	80 81       	ld	r24, Z
    2bb0:	91 81       	ldd	r25, Z+1	; 0x01
    2bb2:	9a 83       	std	Y+2, r25	; 0x02
    2bb4:	89 83       	std	Y+1, r24	; 0x01

		/* Calculate the number of bytes that can be read - which may be
		less than the number wanted if the data wraps around to the start of
		the buffer. */
		xFirstLength = configMIN( pxStreamBuffer->xLength - xNextTail, xCount );
    2bb6:	ef 81       	ldd	r30, Y+7	; 0x07
    2bb8:	f8 85       	ldd	r31, Y+8	; 0x08
    2bba:	24 81       	ldd	r18, Z+4	; 0x04
    2bbc:	35 81       	ldd	r19, Z+5	; 0x05
    2bbe:	89 81       	ldd	r24, Y+1	; 0x01
    2bc0:	9a 81       	ldd	r25, Y+2	; 0x02
    2bc2:	a9 01       	movw	r20, r18
    2bc4:	48 1b       	sub	r20, r24
    2bc6:	59 0b       	sbc	r21, r25
    2bc8:	ca 01       	movw	r24, r20
    2bca:	2d 81       	ldd	r18, Y+5	; 0x05
    2bcc:	3e 81       	ldd	r19, Y+6	; 0x06
    2bce:	3e 8b       	std	Y+22, r19	; 0x16
    2bd0:	2d 8b       	std	Y+21, r18	; 0x15
    2bd2:	9c 8b       	std	Y+20, r25	; 0x14
    2bd4:	8b 8b       	std	Y+19, r24	; 0x13
    2bd6:	4b 89       	ldd	r20, Y+19	; 0x13
    2bd8:	5c 89       	ldd	r21, Y+20	; 0x14
    2bda:	8d 89       	ldd	r24, Y+21	; 0x15
    2bdc:	9e 89       	ldd	r25, Y+22	; 0x16
    2bde:	84 17       	cp	r24, r20
    2be0:	95 07       	cpc	r25, r21
    2be2:	20 f4       	brcc	.+8      	; 0x2bec <prvReadBytesFromBuffer+0x9e>
    2be4:	2d 89       	ldd	r18, Y+21	; 0x15
    2be6:	3e 89       	ldd	r19, Y+22	; 0x16
    2be8:	3c 8b       	std	Y+20, r19	; 0x14
    2bea:	2b 8b       	std	Y+19, r18	; 0x13
    2bec:	4b 89       	ldd	r20, Y+19	; 0x13
    2bee:	5c 89       	ldd	r21, Y+20	; 0x14
    2bf0:	5c 83       	std	Y+4, r21	; 0x04
    2bf2:	4b 83       	std	Y+3, r20	; 0x03

		/* Obtain the number of bytes it is possible to obtain in the first
		read.  Asserts check bounds of read and write. */
		configASSERT( xFirstLength <= xMaxCount );
		configASSERT( ( xNextTail + xFirstLength ) <= pxStreamBuffer->xLength );
		( void ) memcpy( ( void * ) pucData, ( const void * ) &( pxStreamBuffer->pucBuffer[ xNextTail ] ), xFirstLength ); /*lint !e9087 memcpy() requires void *. */
    2bf4:	ef 81       	ldd	r30, Y+7	; 0x07
    2bf6:	f8 85       	ldd	r31, Y+8	; 0x08
    2bf8:	24 85       	ldd	r18, Z+12	; 0x0c
    2bfa:	35 85       	ldd	r19, Z+13	; 0x0d
    2bfc:	89 81       	ldd	r24, Y+1	; 0x01
    2bfe:	9a 81       	ldd	r25, Y+2	; 0x02
    2c00:	a9 01       	movw	r20, r18
    2c02:	48 0f       	add	r20, r24
    2c04:	59 1f       	adc	r21, r25
    2c06:	89 85       	ldd	r24, Y+9	; 0x09
    2c08:	9a 85       	ldd	r25, Y+10	; 0x0a
    2c0a:	2b 81       	ldd	r18, Y+3	; 0x03
    2c0c:	3c 81       	ldd	r19, Y+4	; 0x04
    2c0e:	ba 01       	movw	r22, r20
    2c10:	a9 01       	movw	r20, r18
    2c12:	0e 94 87 24 	call	0x490e	; 0x490e <memcpy>

		/* If the total number of wanted bytes is greater than the number
		that could be read in the first read... */
		if( xCount > xFirstLength )
    2c16:	2d 81       	ldd	r18, Y+5	; 0x05
    2c18:	3e 81       	ldd	r19, Y+6	; 0x06
    2c1a:	8b 81       	ldd	r24, Y+3	; 0x03
    2c1c:	9c 81       	ldd	r25, Y+4	; 0x04
    2c1e:	82 17       	cp	r24, r18
    2c20:	93 07       	cpc	r25, r19
    2c22:	b0 f4       	brcc	.+44     	; 0x2c50 <prvReadBytesFromBuffer+0x102>
		{
			/*...then read the remaining bytes from the start of the buffer. */
			configASSERT( xCount <= xMaxCount );
			( void ) memcpy( ( void * ) &( pucData[ xFirstLength ] ), ( void * ) ( pxStreamBuffer->pucBuffer ), xCount - xFirstLength ); /*lint !e9087 memcpy() requires void *. */
    2c24:	29 85       	ldd	r18, Y+9	; 0x09
    2c26:	3a 85       	ldd	r19, Y+10	; 0x0a
    2c28:	8b 81       	ldd	r24, Y+3	; 0x03
    2c2a:	9c 81       	ldd	r25, Y+4	; 0x04
    2c2c:	b9 01       	movw	r22, r18
    2c2e:	68 0f       	add	r22, r24
    2c30:	79 1f       	adc	r23, r25
    2c32:	ef 81       	ldd	r30, Y+7	; 0x07
    2c34:	f8 85       	ldd	r31, Y+8	; 0x08
    2c36:	44 85       	ldd	r20, Z+12	; 0x0c
    2c38:	55 85       	ldd	r21, Z+13	; 0x0d
    2c3a:	2d 81       	ldd	r18, Y+5	; 0x05
    2c3c:	3e 81       	ldd	r19, Y+6	; 0x06
    2c3e:	8b 81       	ldd	r24, Y+3	; 0x03
    2c40:	9c 81       	ldd	r25, Y+4	; 0x04
    2c42:	28 1b       	sub	r18, r24
    2c44:	39 0b       	sbc	r19, r25
    2c46:	cb 01       	movw	r24, r22
    2c48:	ba 01       	movw	r22, r20
    2c4a:	a9 01       	movw	r20, r18
    2c4c:	0e 94 87 24 	call	0x490e	; 0x490e <memcpy>
			mtCOVERAGE_TEST_MARKER();
		}

		/* Move the tail pointer to effectively remove the data read from
		the buffer. */
		xNextTail += xCount;
    2c50:	29 81       	ldd	r18, Y+1	; 0x01
    2c52:	3a 81       	ldd	r19, Y+2	; 0x02
    2c54:	8d 81       	ldd	r24, Y+5	; 0x05
    2c56:	9e 81       	ldd	r25, Y+6	; 0x06
    2c58:	82 0f       	add	r24, r18
    2c5a:	93 1f       	adc	r25, r19
    2c5c:	9a 83       	std	Y+2, r25	; 0x02
    2c5e:	89 83       	std	Y+1, r24	; 0x01

		if( xNextTail >= pxStreamBuffer->xLength )
    2c60:	ef 81       	ldd	r30, Y+7	; 0x07
    2c62:	f8 85       	ldd	r31, Y+8	; 0x08
    2c64:	24 81       	ldd	r18, Z+4	; 0x04
    2c66:	35 81       	ldd	r19, Z+5	; 0x05
    2c68:	89 81       	ldd	r24, Y+1	; 0x01
    2c6a:	9a 81       	ldd	r25, Y+2	; 0x02
    2c6c:	82 17       	cp	r24, r18
    2c6e:	93 07       	cpc	r25, r19
    2c70:	50 f0       	brcs	.+20     	; 0x2c86 <prvReadBytesFromBuffer+0x138>
		{
			xNextTail -= pxStreamBuffer->xLength;
    2c72:	ef 81       	ldd	r30, Y+7	; 0x07
    2c74:	f8 85       	ldd	r31, Y+8	; 0x08
    2c76:	24 81       	ldd	r18, Z+4	; 0x04
    2c78:	35 81       	ldd	r19, Z+5	; 0x05
    2c7a:	89 81       	ldd	r24, Y+1	; 0x01
    2c7c:	9a 81       	ldd	r25, Y+2	; 0x02
    2c7e:	82 1b       	sub	r24, r18
    2c80:	93 0b       	sbc	r25, r19
    2c82:	9a 83       	std	Y+2, r25	; 0x02
    2c84:	89 83       	std	Y+1, r24	; 0x01
		}

		pxStreamBuffer->xTail = xNextTail;
    2c86:	ef 81       	ldd	r30, Y+7	; 0x07
    2c88:	f8 85       	ldd	r31, Y+8	; 0x08
    2c8a:	89 81       	ldd	r24, Y+1	; 0x01
    2c8c:	9a 81       	ldd	r25, Y+2	; 0x02
    2c8e:	91 83       	std	Z+1, r25	; 0x01
    2c90:	80 83       	st	Z, r24
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xCount;
    2c92:	8d 81       	ldd	r24, Y+5	; 0x05
    2c94:	9e 81       	ldd	r25, Y+6	; 0x06
}
    2c96:	66 96       	adiw	r28, 0x16	; 22
    2c98:	0f b6       	in	r0, 0x3f	; 63
    2c9a:	f8 94       	cli
    2c9c:	de bf       	out	0x3e, r29	; 62
    2c9e:	0f be       	out	0x3f, r0	; 63
    2ca0:	cd bf       	out	0x3d, r28	; 61
    2ca2:	cf 91       	pop	r28
    2ca4:	df 91       	pop	r29
    2ca6:	08 95       	ret

00002ca8 <prvBytesInBuffer>:
/*-----------------------------------------------------------*/

static size_t prvBytesInBuffer( const StreamBuffer_t * const pxStreamBuffer )
{
    2ca8:	df 93       	push	r29
    2caa:	cf 93       	push	r28
    2cac:	00 d0       	rcall	.+0      	; 0x2cae <prvBytesInBuffer+0x6>
    2cae:	00 d0       	rcall	.+0      	; 0x2cb0 <prvBytesInBuffer+0x8>
    2cb0:	cd b7       	in	r28, 0x3d	; 61
    2cb2:	de b7       	in	r29, 0x3e	; 62
    2cb4:	9c 83       	std	Y+4, r25	; 0x04
    2cb6:	8b 83       	std	Y+3, r24	; 0x03
/* Returns the distance between xTail and xHead. */
size_t xCount;

	xCount = pxStreamBuffer->xLength + pxStreamBuffer->xHead;
    2cb8:	eb 81       	ldd	r30, Y+3	; 0x03
    2cba:	fc 81       	ldd	r31, Y+4	; 0x04
    2cbc:	24 81       	ldd	r18, Z+4	; 0x04
    2cbe:	35 81       	ldd	r19, Z+5	; 0x05
    2cc0:	eb 81       	ldd	r30, Y+3	; 0x03
    2cc2:	fc 81       	ldd	r31, Y+4	; 0x04
    2cc4:	82 81       	ldd	r24, Z+2	; 0x02
    2cc6:	93 81       	ldd	r25, Z+3	; 0x03
    2cc8:	82 0f       	add	r24, r18
    2cca:	93 1f       	adc	r25, r19
    2ccc:	9a 83       	std	Y+2, r25	; 0x02
    2cce:	89 83       	std	Y+1, r24	; 0x01
	xCount -= pxStreamBuffer->xTail;
    2cd0:	eb 81       	ldd	r30, Y+3	; 0x03
    2cd2:	fc 81       	ldd	r31, Y+4	; 0x04
    2cd4:	20 81       	ld	r18, Z
    2cd6:	31 81       	ldd	r19, Z+1	; 0x01
    2cd8:	89 81       	ldd	r24, Y+1	; 0x01
    2cda:	9a 81       	ldd	r25, Y+2	; 0x02
    2cdc:	82 1b       	sub	r24, r18
    2cde:	93 0b       	sbc	r25, r19
    2ce0:	9a 83       	std	Y+2, r25	; 0x02
    2ce2:	89 83       	std	Y+1, r24	; 0x01
	if ( xCount >= pxStreamBuffer->xLength )
    2ce4:	eb 81       	ldd	r30, Y+3	; 0x03
    2ce6:	fc 81       	ldd	r31, Y+4	; 0x04
    2ce8:	24 81       	ldd	r18, Z+4	; 0x04
    2cea:	35 81       	ldd	r19, Z+5	; 0x05
    2cec:	89 81       	ldd	r24, Y+1	; 0x01
    2cee:	9a 81       	ldd	r25, Y+2	; 0x02
    2cf0:	82 17       	cp	r24, r18
    2cf2:	93 07       	cpc	r25, r19
    2cf4:	50 f0       	brcs	.+20     	; 0x2d0a <prvBytesInBuffer+0x62>
	{
		xCount -= pxStreamBuffer->xLength;
    2cf6:	eb 81       	ldd	r30, Y+3	; 0x03
    2cf8:	fc 81       	ldd	r31, Y+4	; 0x04
    2cfa:	24 81       	ldd	r18, Z+4	; 0x04
    2cfc:	35 81       	ldd	r19, Z+5	; 0x05
    2cfe:	89 81       	ldd	r24, Y+1	; 0x01
    2d00:	9a 81       	ldd	r25, Y+2	; 0x02
    2d02:	82 1b       	sub	r24, r18
    2d04:	93 0b       	sbc	r25, r19
    2d06:	9a 83       	std	Y+2, r25	; 0x02
    2d08:	89 83       	std	Y+1, r24	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xCount;
    2d0a:	89 81       	ldd	r24, Y+1	; 0x01
    2d0c:	9a 81       	ldd	r25, Y+2	; 0x02
}
    2d0e:	0f 90       	pop	r0
    2d10:	0f 90       	pop	r0
    2d12:	0f 90       	pop	r0
    2d14:	0f 90       	pop	r0
    2d16:	cf 91       	pop	r28
    2d18:	df 91       	pop	r29
    2d1a:	08 95       	ret

00002d1c <prvInitialiseNewStreamBuffer>:
static void prvInitialiseNewStreamBuffer( StreamBuffer_t * const pxStreamBuffer,
										  uint8_t * const pucBuffer,
										  size_t xBufferSizeBytes,
										  size_t xTriggerLevelBytes,
										  uint8_t ucFlags )
{
    2d1c:	0f 93       	push	r16
    2d1e:	df 93       	push	r29
    2d20:	cf 93       	push	r28
    2d22:	cd b7       	in	r28, 0x3d	; 61
    2d24:	de b7       	in	r29, 0x3e	; 62
    2d26:	29 97       	sbiw	r28, 0x09	; 9
    2d28:	0f b6       	in	r0, 0x3f	; 63
    2d2a:	f8 94       	cli
    2d2c:	de bf       	out	0x3e, r29	; 62
    2d2e:	0f be       	out	0x3f, r0	; 63
    2d30:	cd bf       	out	0x3d, r28	; 61
    2d32:	9a 83       	std	Y+2, r25	; 0x02
    2d34:	89 83       	std	Y+1, r24	; 0x01
    2d36:	7c 83       	std	Y+4, r23	; 0x04
    2d38:	6b 83       	std	Y+3, r22	; 0x03
    2d3a:	5e 83       	std	Y+6, r21	; 0x06
    2d3c:	4d 83       	std	Y+5, r20	; 0x05
    2d3e:	38 87       	std	Y+8, r19	; 0x08
    2d40:	2f 83       	std	Y+7, r18	; 0x07
    2d42:	09 87       	std	Y+9, r16	; 0x09
		const BaseType_t xWriteValue = 0x55;
		configASSERT( memset( pucBuffer, ( int ) xWriteValue, xBufferSizeBytes ) == pucBuffer );
	} /*lint !e529 !e438 xWriteValue is only used if configASSERT() is defined. */
	#endif

	( void ) memset( ( void * ) pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) ); /*lint !e9087 memset() requires void *. */
    2d44:	89 81       	ldd	r24, Y+1	; 0x01
    2d46:	9a 81       	ldd	r25, Y+2	; 0x02
    2d48:	60 e0       	ldi	r22, 0x00	; 0
    2d4a:	70 e0       	ldi	r23, 0x00	; 0
    2d4c:	4f e0       	ldi	r20, 0x0F	; 15
    2d4e:	50 e0       	ldi	r21, 0x00	; 0
    2d50:	0e 94 90 24 	call	0x4920	; 0x4920 <memset>
	pxStreamBuffer->pucBuffer = pucBuffer;
    2d54:	e9 81       	ldd	r30, Y+1	; 0x01
    2d56:	fa 81       	ldd	r31, Y+2	; 0x02
    2d58:	8b 81       	ldd	r24, Y+3	; 0x03
    2d5a:	9c 81       	ldd	r25, Y+4	; 0x04
    2d5c:	95 87       	std	Z+13, r25	; 0x0d
    2d5e:	84 87       	std	Z+12, r24	; 0x0c
	pxStreamBuffer->xLength = xBufferSizeBytes;
    2d60:	e9 81       	ldd	r30, Y+1	; 0x01
    2d62:	fa 81       	ldd	r31, Y+2	; 0x02
    2d64:	8d 81       	ldd	r24, Y+5	; 0x05
    2d66:	9e 81       	ldd	r25, Y+6	; 0x06
    2d68:	95 83       	std	Z+5, r25	; 0x05
    2d6a:	84 83       	std	Z+4, r24	; 0x04
	pxStreamBuffer->xTriggerLevelBytes = xTriggerLevelBytes;
    2d6c:	e9 81       	ldd	r30, Y+1	; 0x01
    2d6e:	fa 81       	ldd	r31, Y+2	; 0x02
    2d70:	8f 81       	ldd	r24, Y+7	; 0x07
    2d72:	98 85       	ldd	r25, Y+8	; 0x08
    2d74:	97 83       	std	Z+7, r25	; 0x07
    2d76:	86 83       	std	Z+6, r24	; 0x06
	pxStreamBuffer->ucFlags = ucFlags;
    2d78:	e9 81       	ldd	r30, Y+1	; 0x01
    2d7a:	fa 81       	ldd	r31, Y+2	; 0x02
    2d7c:	89 85       	ldd	r24, Y+9	; 0x09
    2d7e:	86 87       	std	Z+14, r24	; 0x0e
}
    2d80:	29 96       	adiw	r28, 0x09	; 9
    2d82:	0f b6       	in	r0, 0x3f	; 63
    2d84:	f8 94       	cli
    2d86:	de bf       	out	0x3e, r29	; 62
    2d88:	0f be       	out	0x3f, r0	; 63
    2d8a:	cd bf       	out	0x3d, r28	; 61
    2d8c:	cf 91       	pop	r28
    2d8e:	df 91       	pop	r29
    2d90:	0f 91       	pop	r16
    2d92:	08 95       	ret

00002d94 <xTaskCreate>:
							const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
							const configSTACK_DEPTH_TYPE usStackDepth,
							void * const pvParameters,
							UBaseType_t uxPriority,
							TaskHandle_t * const pxCreatedTask )
	{
    2d94:	8f 92       	push	r8
    2d96:	9f 92       	push	r9
    2d98:	af 92       	push	r10
    2d9a:	bf 92       	push	r11
    2d9c:	cf 92       	push	r12
    2d9e:	df 92       	push	r13
    2da0:	ef 92       	push	r14
    2da2:	ff 92       	push	r15
    2da4:	0f 93       	push	r16
    2da6:	1f 93       	push	r17
    2da8:	df 93       	push	r29
    2daa:	cf 93       	push	r28
    2dac:	cd b7       	in	r28, 0x3d	; 61
    2dae:	de b7       	in	r29, 0x3e	; 62
    2db0:	60 97       	sbiw	r28, 0x10	; 16
    2db2:	0f b6       	in	r0, 0x3f	; 63
    2db4:	f8 94       	cli
    2db6:	de bf       	out	0x3e, r29	; 62
    2db8:	0f be       	out	0x3f, r0	; 63
    2dba:	cd bf       	out	0x3d, r28	; 61
    2dbc:	9f 83       	std	Y+7, r25	; 0x07
    2dbe:	8e 83       	std	Y+6, r24	; 0x06
    2dc0:	79 87       	std	Y+9, r23	; 0x09
    2dc2:	68 87       	std	Y+8, r22	; 0x08
    2dc4:	5b 87       	std	Y+11, r21	; 0x0b
    2dc6:	4a 87       	std	Y+10, r20	; 0x0a
    2dc8:	3d 87       	std	Y+13, r19	; 0x0d
    2dca:	2c 87       	std	Y+12, r18	; 0x0c
    2dcc:	0e 87       	std	Y+14, r16	; 0x0e
    2dce:	f8 8a       	std	Y+16, r15	; 0x10
    2dd0:	ef 86       	std	Y+15, r14	; 0x0f
		#else /* portSTACK_GROWTH */
		{
		StackType_t *pxStack;

			/* Allocate space for the stack used by the task being created. */
			pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
    2dd2:	8a 85       	ldd	r24, Y+10	; 0x0a
    2dd4:	9b 85       	ldd	r25, Y+11	; 0x0b
    2dd6:	0e 94 62 06 	call	0xcc4	; 0xcc4 <pvPortMalloc>
    2dda:	9a 83       	std	Y+2, r25	; 0x02
    2ddc:	89 83       	std	Y+1, r24	; 0x01

			if( pxStack != NULL )
    2dde:	89 81       	ldd	r24, Y+1	; 0x01
    2de0:	9a 81       	ldd	r25, Y+2	; 0x02
    2de2:	00 97       	sbiw	r24, 0x00	; 0
    2de4:	b1 f0       	breq	.+44     	; 0x2e12 <xTaskCreate+0x7e>
			{
				/* Allocate space for the TCB. */
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
    2de6:	88 e2       	ldi	r24, 0x28	; 40
    2de8:	90 e0       	ldi	r25, 0x00	; 0
    2dea:	0e 94 62 06 	call	0xcc4	; 0xcc4 <pvPortMalloc>
    2dee:	9d 83       	std	Y+5, r25	; 0x05
    2df0:	8c 83       	std	Y+4, r24	; 0x04

				if( pxNewTCB != NULL )
    2df2:	8c 81       	ldd	r24, Y+4	; 0x04
    2df4:	9d 81       	ldd	r25, Y+5	; 0x05
    2df6:	00 97       	sbiw	r24, 0x00	; 0
    2df8:	39 f0       	breq	.+14     	; 0x2e08 <xTaskCreate+0x74>
				{
					/* Store the stack location in the TCB. */
					pxNewTCB->pxStack = pxStack;
    2dfa:	ec 81       	ldd	r30, Y+4	; 0x04
    2dfc:	fd 81       	ldd	r31, Y+5	; 0x05
    2dfe:	89 81       	ldd	r24, Y+1	; 0x01
    2e00:	9a 81       	ldd	r25, Y+2	; 0x02
    2e02:	90 8f       	std	Z+24, r25	; 0x18
    2e04:	87 8b       	std	Z+23, r24	; 0x17
    2e06:	07 c0       	rjmp	.+14     	; 0x2e16 <xTaskCreate+0x82>
				}
				else
				{
					/* The stack cannot be used as the TCB was not created.  Free
					it again. */
					vPortFree( pxStack );
    2e08:	89 81       	ldd	r24, Y+1	; 0x01
    2e0a:	9a 81       	ldd	r25, Y+2	; 0x02
    2e0c:	0e 94 b8 06 	call	0xd70	; 0xd70 <vPortFree>
    2e10:	02 c0       	rjmp	.+4      	; 0x2e16 <xTaskCreate+0x82>
				}
			}
			else
			{
				pxNewTCB = NULL;
    2e12:	1d 82       	std	Y+5, r1	; 0x05
    2e14:	1c 82       	std	Y+4, r1	; 0x04
			}
		}
		#endif /* portSTACK_GROWTH */

		if( pxNewTCB != NULL )
    2e16:	8c 81       	ldd	r24, Y+4	; 0x04
    2e18:	9d 81       	ldd	r25, Y+5	; 0x05
    2e1a:	00 97       	sbiw	r24, 0x00	; 0
    2e1c:	e9 f0       	breq	.+58     	; 0x2e58 <xTaskCreate+0xc4>
				task was created dynamically in case it is later deleted. */
				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
			}
			#endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */

			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
    2e1e:	8a 85       	ldd	r24, Y+10	; 0x0a
    2e20:	9b 85       	ldd	r25, Y+11	; 0x0b
    2e22:	9c 01       	movw	r18, r24
    2e24:	40 e0       	ldi	r20, 0x00	; 0
    2e26:	50 e0       	ldi	r21, 0x00	; 0
    2e28:	8e 81       	ldd	r24, Y+6	; 0x06
    2e2a:	9f 81       	ldd	r25, Y+7	; 0x07
    2e2c:	68 85       	ldd	r22, Y+8	; 0x08
    2e2e:	79 85       	ldd	r23, Y+9	; 0x09
    2e30:	ec 85       	ldd	r30, Y+12	; 0x0c
    2e32:	fd 85       	ldd	r31, Y+13	; 0x0d
    2e34:	af 85       	ldd	r26, Y+15	; 0x0f
    2e36:	b8 89       	ldd	r27, Y+16	; 0x10
    2e38:	ac 80       	ldd	r10, Y+4	; 0x04
    2e3a:	bd 80       	ldd	r11, Y+5	; 0x05
    2e3c:	8f 01       	movw	r16, r30
    2e3e:	ee 84       	ldd	r14, Y+14	; 0x0e
    2e40:	6d 01       	movw	r12, r26
    2e42:	88 24       	eor	r8, r8
    2e44:	99 24       	eor	r9, r9
    2e46:	0e 94 42 17 	call	0x2e84	; 0x2e84 <prvInitialiseNewTask>
			prvAddNewTaskToReadyList( pxNewTCB );
    2e4a:	8c 81       	ldd	r24, Y+4	; 0x04
    2e4c:	9d 81       	ldd	r25, Y+5	; 0x05
    2e4e:	0e 94 fe 17 	call	0x2ffc	; 0x2ffc <prvAddNewTaskToReadyList>
			xReturn = pdPASS;
    2e52:	81 e0       	ldi	r24, 0x01	; 1
    2e54:	8b 83       	std	Y+3, r24	; 0x03
    2e56:	02 c0       	rjmp	.+4      	; 0x2e5c <xTaskCreate+0xc8>
		}
		else
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    2e58:	8f ef       	ldi	r24, 0xFF	; 255
    2e5a:	8b 83       	std	Y+3, r24	; 0x03
		}

		return xReturn;
    2e5c:	8b 81       	ldd	r24, Y+3	; 0x03
	}
    2e5e:	60 96       	adiw	r28, 0x10	; 16
    2e60:	0f b6       	in	r0, 0x3f	; 63
    2e62:	f8 94       	cli
    2e64:	de bf       	out	0x3e, r29	; 62
    2e66:	0f be       	out	0x3f, r0	; 63
    2e68:	cd bf       	out	0x3d, r28	; 61
    2e6a:	cf 91       	pop	r28
    2e6c:	df 91       	pop	r29
    2e6e:	1f 91       	pop	r17
    2e70:	0f 91       	pop	r16
    2e72:	ff 90       	pop	r15
    2e74:	ef 90       	pop	r14
    2e76:	df 90       	pop	r13
    2e78:	cf 90       	pop	r12
    2e7a:	bf 90       	pop	r11
    2e7c:	af 90       	pop	r10
    2e7e:	9f 90       	pop	r9
    2e80:	8f 90       	pop	r8
    2e82:	08 95       	ret

00002e84 <prvInitialiseNewTask>:
									void * const pvParameters,
									UBaseType_t uxPriority,
									TaskHandle_t * const pxCreatedTask,
									TCB_t *pxNewTCB,
									const MemoryRegion_t * const xRegions )
{
    2e84:	8f 92       	push	r8
    2e86:	9f 92       	push	r9
    2e88:	af 92       	push	r10
    2e8a:	bf 92       	push	r11
    2e8c:	cf 92       	push	r12
    2e8e:	df 92       	push	r13
    2e90:	ef 92       	push	r14
    2e92:	0f 93       	push	r16
    2e94:	1f 93       	push	r17
    2e96:	df 93       	push	r29
    2e98:	cf 93       	push	r28
    2e9a:	cd b7       	in	r28, 0x3d	; 61
    2e9c:	de b7       	in	r29, 0x3e	; 62
    2e9e:	64 97       	sbiw	r28, 0x14	; 20
    2ea0:	0f b6       	in	r0, 0x3f	; 63
    2ea2:	f8 94       	cli
    2ea4:	de bf       	out	0x3e, r29	; 62
    2ea6:	0f be       	out	0x3f, r0	; 63
    2ea8:	cd bf       	out	0x3d, r28	; 61
    2eaa:	9d 83       	std	Y+5, r25	; 0x05
    2eac:	8c 83       	std	Y+4, r24	; 0x04
    2eae:	7f 83       	std	Y+7, r23	; 0x07
    2eb0:	6e 83       	std	Y+6, r22	; 0x06
    2eb2:	28 87       	std	Y+8, r18	; 0x08
    2eb4:	39 87       	std	Y+9, r19	; 0x09
    2eb6:	4a 87       	std	Y+10, r20	; 0x0a
    2eb8:	5b 87       	std	Y+11, r21	; 0x0b
    2eba:	1d 87       	std	Y+13, r17	; 0x0d
    2ebc:	0c 87       	std	Y+12, r16	; 0x0c
    2ebe:	ee 86       	std	Y+14, r14	; 0x0e
    2ec0:	d8 8a       	std	Y+16, r13	; 0x10
    2ec2:	cf 86       	std	Y+15, r12	; 0x0f
    2ec4:	ba 8a       	std	Y+18, r11	; 0x12
    2ec6:	a9 8a       	std	Y+17, r10	; 0x11
    2ec8:	9c 8a       	std	Y+20, r9	; 0x14
    2eca:	8b 8a       	std	Y+19, r8	; 0x13
	grows from high memory to low (as per the 80x86) or vice versa.
	portSTACK_GROWTH is used to make the result positive or negative as required
	by the port. */
	#if( portSTACK_GROWTH < 0 )
	{
		pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
    2ecc:	e9 89       	ldd	r30, Y+17	; 0x11
    2ece:	fa 89       	ldd	r31, Y+18	; 0x12
    2ed0:	27 89       	ldd	r18, Z+23	; 0x17
    2ed2:	30 8d       	ldd	r19, Z+24	; 0x18
    2ed4:	88 85       	ldd	r24, Y+8	; 0x08
    2ed6:	99 85       	ldd	r25, Y+9	; 0x09
    2ed8:	01 97       	sbiw	r24, 0x01	; 1
    2eda:	82 0f       	add	r24, r18
    2edc:	93 1f       	adc	r25, r19
    2ede:	9b 83       	std	Y+3, r25	; 0x03
    2ee0:	8a 83       	std	Y+2, r24	; 0x02
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	if( pcName != NULL )
    2ee2:	8e 81       	ldd	r24, Y+6	; 0x06
    2ee4:	9f 81       	ldd	r25, Y+7	; 0x07
    2ee6:	00 97       	sbiw	r24, 0x00	; 0
    2ee8:	51 f1       	breq	.+84     	; 0x2f3e <prvInitialiseNewTask+0xba>
	{
		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    2eea:	19 82       	std	Y+1, r1	; 0x01
    2eec:	21 c0       	rjmp	.+66     	; 0x2f30 <prvInitialiseNewTask+0xac>
		{
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    2eee:	89 81       	ldd	r24, Y+1	; 0x01
    2ef0:	48 2f       	mov	r20, r24
    2ef2:	50 e0       	ldi	r21, 0x00	; 0
    2ef4:	89 81       	ldd	r24, Y+1	; 0x01
    2ef6:	28 2f       	mov	r18, r24
    2ef8:	30 e0       	ldi	r19, 0x00	; 0
    2efa:	8e 81       	ldd	r24, Y+6	; 0x06
    2efc:	9f 81       	ldd	r25, Y+7	; 0x07
    2efe:	fc 01       	movw	r30, r24
    2f00:	e2 0f       	add	r30, r18
    2f02:	f3 1f       	adc	r31, r19
    2f04:	20 81       	ld	r18, Z
    2f06:	89 89       	ldd	r24, Y+17	; 0x11
    2f08:	9a 89       	ldd	r25, Y+18	; 0x12
    2f0a:	84 0f       	add	r24, r20
    2f0c:	95 1f       	adc	r25, r21
    2f0e:	fc 01       	movw	r30, r24
    2f10:	79 96       	adiw	r30, 0x19	; 25
    2f12:	20 83       	st	Z, r18

			/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
			configMAX_TASK_NAME_LEN characters just in case the memory after the
			string is not accessible (extremely unlikely). */
			if( pcName[ x ] == ( char ) 0x00 )
    2f14:	89 81       	ldd	r24, Y+1	; 0x01
    2f16:	28 2f       	mov	r18, r24
    2f18:	30 e0       	ldi	r19, 0x00	; 0
    2f1a:	8e 81       	ldd	r24, Y+6	; 0x06
    2f1c:	9f 81       	ldd	r25, Y+7	; 0x07
    2f1e:	fc 01       	movw	r30, r24
    2f20:	e2 0f       	add	r30, r18
    2f22:	f3 1f       	adc	r31, r19
    2f24:	80 81       	ld	r24, Z
    2f26:	88 23       	and	r24, r24
    2f28:	31 f0       	breq	.+12     	; 0x2f36 <prvInitialiseNewTask+0xb2>
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	if( pcName != NULL )
	{
		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    2f2a:	89 81       	ldd	r24, Y+1	; 0x01
    2f2c:	8f 5f       	subi	r24, 0xFF	; 255
    2f2e:	89 83       	std	Y+1, r24	; 0x01
    2f30:	89 81       	ldd	r24, Y+1	; 0x01
    2f32:	8a 30       	cpi	r24, 0x0A	; 10
    2f34:	e0 f2       	brcs	.-72     	; 0x2eee <prvInitialiseNewTask+0x6a>
			}
		}

		/* Ensure the name string is terminated in the case that the string length
		was greater or equal to configMAX_TASK_NAME_LEN. */
		pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    2f36:	e9 89       	ldd	r30, Y+17	; 0x11
    2f38:	fa 89       	ldd	r31, Y+18	; 0x12
    2f3a:	12 a2       	std	Z+34, r1	; 0x22
    2f3c:	03 c0       	rjmp	.+6      	; 0x2f44 <prvInitialiseNewTask+0xc0>
	}
	else
	{
		/* The task has not been given a name, so just ensure there is a NULL
		terminator when it is read out. */
		pxNewTCB->pcTaskName[ 0 ] = 0x00;
    2f3e:	e9 89       	ldd	r30, Y+17	; 0x11
    2f40:	fa 89       	ldd	r31, Y+18	; 0x12
    2f42:	11 8e       	std	Z+25, r1	; 0x19
	}

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
    2f44:	8e 85       	ldd	r24, Y+14	; 0x0e
    2f46:	84 30       	cpi	r24, 0x04	; 4
    2f48:	10 f0       	brcs	.+4      	; 0x2f4e <prvInitialiseNewTask+0xca>
	{
		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
    2f4a:	83 e0       	ldi	r24, 0x03	; 3
    2f4c:	8e 87       	std	Y+14, r24	; 0x0e
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxNewTCB->uxPriority = uxPriority;
    2f4e:	e9 89       	ldd	r30, Y+17	; 0x11
    2f50:	fa 89       	ldd	r31, Y+18	; 0x12
    2f52:	8e 85       	ldd	r24, Y+14	; 0x0e
    2f54:	86 8b       	std	Z+22, r24	; 0x16
		pxNewTCB->uxBasePriority = uxPriority;
		pxNewTCB->uxMutexesHeld = 0;
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
    2f56:	89 89       	ldd	r24, Y+17	; 0x11
    2f58:	9a 89       	ldd	r25, Y+18	; 0x12
    2f5a:	02 96       	adiw	r24, 0x02	; 2
    2f5c:	0e 94 08 07 	call	0xe10	; 0xe10 <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
    2f60:	89 89       	ldd	r24, Y+17	; 0x11
    2f62:	9a 89       	ldd	r25, Y+18	; 0x12
    2f64:	0c 96       	adiw	r24, 0x0c	; 12
    2f66:	0e 94 08 07 	call	0xe10	; 0xe10 <vListInitialiseItem>

	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
    2f6a:	e9 89       	ldd	r30, Y+17	; 0x11
    2f6c:	fa 89       	ldd	r31, Y+18	; 0x12
    2f6e:	89 89       	ldd	r24, Y+17	; 0x11
    2f70:	9a 89       	ldd	r25, Y+18	; 0x12
    2f72:	91 87       	std	Z+9, r25	; 0x09
    2f74:	80 87       	std	Z+8, r24	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    2f76:	8e 85       	ldd	r24, Y+14	; 0x0e
    2f78:	28 2f       	mov	r18, r24
    2f7a:	30 e0       	ldi	r19, 0x00	; 0
    2f7c:	84 e0       	ldi	r24, 0x04	; 4
    2f7e:	90 e0       	ldi	r25, 0x00	; 0
    2f80:	82 1b       	sub	r24, r18
    2f82:	93 0b       	sbc	r25, r19
    2f84:	e9 89       	ldd	r30, Y+17	; 0x11
    2f86:	fa 89       	ldd	r31, Y+18	; 0x12
    2f88:	95 87       	std	Z+13, r25	; 0x0d
    2f8a:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
    2f8c:	e9 89       	ldd	r30, Y+17	; 0x11
    2f8e:	fa 89       	ldd	r31, Y+18	; 0x12
    2f90:	89 89       	ldd	r24, Y+17	; 0x11
    2f92:	9a 89       	ldd	r25, Y+18	; 0x12
    2f94:	93 8b       	std	Z+19, r25	; 0x13
    2f96:	82 8b       	std	Z+18, r24	; 0x12
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxNewTCB->ulNotifiedValue = 0;
    2f98:	e9 89       	ldd	r30, Y+17	; 0x11
    2f9a:	fa 89       	ldd	r31, Y+18	; 0x12
    2f9c:	13 a2       	std	Z+35, r1	; 0x23
    2f9e:	14 a2       	std	Z+36, r1	; 0x24
    2fa0:	15 a2       	std	Z+37, r1	; 0x25
    2fa2:	16 a2       	std	Z+38, r1	; 0x26
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    2fa4:	e9 89       	ldd	r30, Y+17	; 0x11
    2fa6:	fa 89       	ldd	r31, Y+18	; 0x12
    2fa8:	17 a2       	std	Z+39, r1	; 0x27
			}
			#endif /* portSTACK_GROWTH */
		}
		#else /* portHAS_STACK_OVERFLOW_CHECKING */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    2faa:	8a 81       	ldd	r24, Y+2	; 0x02
    2fac:	9b 81       	ldd	r25, Y+3	; 0x03
    2fae:	2c 81       	ldd	r18, Y+4	; 0x04
    2fb0:	3d 81       	ldd	r19, Y+5	; 0x05
    2fb2:	4c 85       	ldd	r20, Y+12	; 0x0c
    2fb4:	5d 85       	ldd	r21, Y+13	; 0x0d
    2fb6:	b9 01       	movw	r22, r18
    2fb8:	0e 94 49 00 	call	0x92	; 0x92 <pxPortInitialiseStack>
    2fbc:	e9 89       	ldd	r30, Y+17	; 0x11
    2fbe:	fa 89       	ldd	r31, Y+18	; 0x12
    2fc0:	91 83       	std	Z+1, r25	; 0x01
    2fc2:	80 83       	st	Z, r24
		}
		#endif /* portHAS_STACK_OVERFLOW_CHECKING */
	}
	#endif /* portUSING_MPU_WRAPPERS */

	if( pxCreatedTask != NULL )
    2fc4:	8f 85       	ldd	r24, Y+15	; 0x0f
    2fc6:	98 89       	ldd	r25, Y+16	; 0x10
    2fc8:	00 97       	sbiw	r24, 0x00	; 0
    2fca:	31 f0       	breq	.+12     	; 0x2fd8 <prvInitialiseNewTask+0x154>
	{
		/* Pass the handle out in an anonymous way.  The handle can be used to
		change the created task's priority, delete the created task, etc.*/
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    2fcc:	ef 85       	ldd	r30, Y+15	; 0x0f
    2fce:	f8 89       	ldd	r31, Y+16	; 0x10
    2fd0:	89 89       	ldd	r24, Y+17	; 0x11
    2fd2:	9a 89       	ldd	r25, Y+18	; 0x12
    2fd4:	91 83       	std	Z+1, r25	; 0x01
    2fd6:	80 83       	st	Z, r24
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
    2fd8:	64 96       	adiw	r28, 0x14	; 20
    2fda:	0f b6       	in	r0, 0x3f	; 63
    2fdc:	f8 94       	cli
    2fde:	de bf       	out	0x3e, r29	; 62
    2fe0:	0f be       	out	0x3f, r0	; 63
    2fe2:	cd bf       	out	0x3d, r28	; 61
    2fe4:	cf 91       	pop	r28
    2fe6:	df 91       	pop	r29
    2fe8:	1f 91       	pop	r17
    2fea:	0f 91       	pop	r16
    2fec:	ef 90       	pop	r14
    2fee:	df 90       	pop	r13
    2ff0:	cf 90       	pop	r12
    2ff2:	bf 90       	pop	r11
    2ff4:	af 90       	pop	r10
    2ff6:	9f 90       	pop	r9
    2ff8:	8f 90       	pop	r8
    2ffa:	08 95       	ret

00002ffc <prvAddNewTaskToReadyList>:
/*-----------------------------------------------------------*/

static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
{
    2ffc:	df 93       	push	r29
    2ffe:	cf 93       	push	r28
    3000:	00 d0       	rcall	.+0      	; 0x3002 <prvAddNewTaskToReadyList+0x6>
    3002:	cd b7       	in	r28, 0x3d	; 61
    3004:	de b7       	in	r29, 0x3e	; 62
    3006:	9a 83       	std	Y+2, r25	; 0x02
    3008:	89 83       	std	Y+1, r24	; 0x01
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	taskENTER_CRITICAL();
    300a:	0f b6       	in	r0, 0x3f	; 63
    300c:	f8 94       	cli
    300e:	0f 92       	push	r0
	{
		uxCurrentNumberOfTasks++;
    3010:	80 91 5b 06 	lds	r24, 0x065B
    3014:	8f 5f       	subi	r24, 0xFF	; 255
    3016:	80 93 5b 06 	sts	0x065B, r24
		if( pxCurrentTCB == NULL )
    301a:	80 91 58 06 	lds	r24, 0x0658
    301e:	90 91 59 06 	lds	r25, 0x0659
    3022:	00 97       	sbiw	r24, 0x00	; 0
    3024:	69 f4       	brne	.+26     	; 0x3040 <prvAddNewTaskToReadyList+0x44>
		{
			/* There are no other tasks, or all the other tasks are in
			the suspended state - make this the current task. */
			pxCurrentTCB = pxNewTCB;
    3026:	89 81       	ldd	r24, Y+1	; 0x01
    3028:	9a 81       	ldd	r25, Y+2	; 0x02
    302a:	90 93 59 06 	sts	0x0659, r25
    302e:	80 93 58 06 	sts	0x0658, r24

			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    3032:	80 91 5b 06 	lds	r24, 0x065B
    3036:	81 30       	cpi	r24, 0x01	; 1
    3038:	b9 f4       	brne	.+46     	; 0x3068 <prvAddNewTaskToReadyList+0x6c>
			{
				/* This is the first task to be created so do the preliminary
				initialisation required.  We will not recover if this call
				fails, but we will report the failure. */
				prvInitialiseTaskLists();
    303a:	0e 94 d5 1e 	call	0x3daa	; 0x3daa <prvInitialiseTaskLists>
    303e:	14 c0       	rjmp	.+40     	; 0x3068 <prvAddNewTaskToReadyList+0x6c>
		else
		{
			/* If the scheduler is not already running, make this task the
			current task if it is the highest priority task to be created
			so far. */
			if( xSchedulerRunning == pdFALSE )
    3040:	80 91 5f 06 	lds	r24, 0x065F
    3044:	88 23       	and	r24, r24
    3046:	81 f4       	brne	.+32     	; 0x3068 <prvAddNewTaskToReadyList+0x6c>
			{
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
    3048:	e0 91 58 06 	lds	r30, 0x0658
    304c:	f0 91 59 06 	lds	r31, 0x0659
    3050:	96 89       	ldd	r25, Z+22	; 0x16
    3052:	e9 81       	ldd	r30, Y+1	; 0x01
    3054:	fa 81       	ldd	r31, Y+2	; 0x02
    3056:	86 89       	ldd	r24, Z+22	; 0x16
    3058:	89 17       	cp	r24, r25
    305a:	30 f0       	brcs	.+12     	; 0x3068 <prvAddNewTaskToReadyList+0x6c>
				{
					pxCurrentTCB = pxNewTCB;
    305c:	89 81       	ldd	r24, Y+1	; 0x01
    305e:	9a 81       	ldd	r25, Y+2	; 0x02
    3060:	90 93 59 06 	sts	0x0659, r25
    3064:	80 93 58 06 	sts	0x0658, r24
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		uxTaskNumber++;
    3068:	80 91 63 06 	lds	r24, 0x0663
    306c:	8f 5f       	subi	r24, 0xFF	; 255
    306e:	80 93 63 06 	sts	0x0663, r24
			pxNewTCB->uxTCBNumber = uxTaskNumber;
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );

		prvAddTaskToReadyList( pxNewTCB );
    3072:	e9 81       	ldd	r30, Y+1	; 0x01
    3074:	fa 81       	ldd	r31, Y+2	; 0x02
    3076:	96 89       	ldd	r25, Z+22	; 0x16
    3078:	80 91 5e 06 	lds	r24, 0x065E
    307c:	89 17       	cp	r24, r25
    307e:	28 f4       	brcc	.+10     	; 0x308a <prvAddNewTaskToReadyList+0x8e>
    3080:	e9 81       	ldd	r30, Y+1	; 0x01
    3082:	fa 81       	ldd	r31, Y+2	; 0x02
    3084:	86 89       	ldd	r24, Z+22	; 0x16
    3086:	80 93 5e 06 	sts	0x065E, r24
    308a:	e9 81       	ldd	r30, Y+1	; 0x01
    308c:	fa 81       	ldd	r31, Y+2	; 0x02
    308e:	86 89       	ldd	r24, Z+22	; 0x16
    3090:	28 2f       	mov	r18, r24
    3092:	30 e0       	ldi	r19, 0x00	; 0
    3094:	c9 01       	movw	r24, r18
    3096:	88 0f       	add	r24, r24
    3098:	99 1f       	adc	r25, r25
    309a:	88 0f       	add	r24, r24
    309c:	99 1f       	adc	r25, r25
    309e:	88 0f       	add	r24, r24
    30a0:	99 1f       	adc	r25, r25
    30a2:	82 0f       	add	r24, r18
    30a4:	93 1f       	adc	r25, r19
    30a6:	ac 01       	movw	r20, r24
    30a8:	47 59       	subi	r20, 0x97	; 151
    30aa:	59 4f       	sbci	r21, 0xF9	; 249
    30ac:	89 81       	ldd	r24, Y+1	; 0x01
    30ae:	9a 81       	ldd	r25, Y+2	; 0x02
    30b0:	9c 01       	movw	r18, r24
    30b2:	2e 5f       	subi	r18, 0xFE	; 254
    30b4:	3f 4f       	sbci	r19, 0xFF	; 255
    30b6:	ca 01       	movw	r24, r20
    30b8:	b9 01       	movw	r22, r18
    30ba:	0e 94 18 07 	call	0xe30	; 0xe30 <vListInsertEnd>

		portSETUP_TCB( pxNewTCB );
	}
	taskEXIT_CRITICAL();
    30be:	0f 90       	pop	r0
    30c0:	0f be       	out	0x3f, r0	; 63

	if( xSchedulerRunning != pdFALSE )
    30c2:	80 91 5f 06 	lds	r24, 0x065F
    30c6:	88 23       	and	r24, r24
    30c8:	61 f0       	breq	.+24     	; 0x30e2 <prvAddNewTaskToReadyList+0xe6>
	{
		/* If the created task is of a higher priority than the current task
		then it should run now. */
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
    30ca:	e0 91 58 06 	lds	r30, 0x0658
    30ce:	f0 91 59 06 	lds	r31, 0x0659
    30d2:	96 89       	ldd	r25, Z+22	; 0x16
    30d4:	e9 81       	ldd	r30, Y+1	; 0x01
    30d6:	fa 81       	ldd	r31, Y+2	; 0x02
    30d8:	86 89       	ldd	r24, Z+22	; 0x16
    30da:	98 17       	cp	r25, r24
    30dc:	10 f4       	brcc	.+4      	; 0x30e2 <prvAddNewTaskToReadyList+0xe6>
		{
			taskYIELD_IF_USING_PREEMPTION();
    30de:	0e 94 08 02 	call	0x410	; 0x410 <vPortYield>
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
    30e2:	0f 90       	pop	r0
    30e4:	0f 90       	pop	r0
    30e6:	cf 91       	pop	r28
    30e8:	df 91       	pop	r29
    30ea:	08 95       	ret

000030ec <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( TaskHandle_t xTaskToDelete )
	{
    30ec:	df 93       	push	r29
    30ee:	cf 93       	push	r28
    30f0:	00 d0       	rcall	.+0      	; 0x30f2 <vTaskDelete+0x6>
    30f2:	00 d0       	rcall	.+0      	; 0x30f4 <vTaskDelete+0x8>
    30f4:	00 d0       	rcall	.+0      	; 0x30f6 <vTaskDelete+0xa>
    30f6:	cd b7       	in	r28, 0x3d	; 61
    30f8:	de b7       	in	r29, 0x3e	; 62
    30fa:	9c 83       	std	Y+4, r25	; 0x04
    30fc:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
    30fe:	0f b6       	in	r0, 0x3f	; 63
    3100:	f8 94       	cli
    3102:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the calling task that is
			being deleted. */
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
    3104:	8b 81       	ldd	r24, Y+3	; 0x03
    3106:	9c 81       	ldd	r25, Y+4	; 0x04
    3108:	00 97       	sbiw	r24, 0x00	; 0
    310a:	39 f4       	brne	.+14     	; 0x311a <vTaskDelete+0x2e>
    310c:	80 91 58 06 	lds	r24, 0x0658
    3110:	90 91 59 06 	lds	r25, 0x0659
    3114:	9e 83       	std	Y+6, r25	; 0x06
    3116:	8d 83       	std	Y+5, r24	; 0x05
    3118:	04 c0       	rjmp	.+8      	; 0x3122 <vTaskDelete+0x36>
    311a:	8b 81       	ldd	r24, Y+3	; 0x03
    311c:	9c 81       	ldd	r25, Y+4	; 0x04
    311e:	9e 83       	std	Y+6, r25	; 0x06
    3120:	8d 83       	std	Y+5, r24	; 0x05
    3122:	8d 81       	ldd	r24, Y+5	; 0x05
    3124:	9e 81       	ldd	r25, Y+6	; 0x06
    3126:	9a 83       	std	Y+2, r25	; 0x02
    3128:	89 83       	std	Y+1, r24	; 0x01

			/* Remove task from the ready list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    312a:	89 81       	ldd	r24, Y+1	; 0x01
    312c:	9a 81       	ldd	r25, Y+2	; 0x02
    312e:	02 96       	adiw	r24, 0x02	; 2
    3130:	0e 94 c8 07 	call	0xf90	; 0xf90 <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    3134:	e9 81       	ldd	r30, Y+1	; 0x01
    3136:	fa 81       	ldd	r31, Y+2	; 0x02
    3138:	84 89       	ldd	r24, Z+20	; 0x14
    313a:	95 89       	ldd	r25, Z+21	; 0x15
    313c:	00 97       	sbiw	r24, 0x00	; 0
    313e:	29 f0       	breq	.+10     	; 0x314a <vTaskDelete+0x5e>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    3140:	89 81       	ldd	r24, Y+1	; 0x01
    3142:	9a 81       	ldd	r25, Y+2	; 0x02
    3144:	0c 96       	adiw	r24, 0x0c	; 12
    3146:	0e 94 c8 07 	call	0xf90	; 0xf90 <uxListRemove>

			/* Increment the uxTaskNumber also so kernel aware debuggers can
			detect that the task lists need re-generating.  This is done before
			portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
			not return. */
			uxTaskNumber++;
    314a:	80 91 63 06 	lds	r24, 0x0663
    314e:	8f 5f       	subi	r24, 0xFF	; 255
    3150:	80 93 63 06 	sts	0x0663, r24

			if( pxTCB == pxCurrentTCB )
    3154:	20 91 58 06 	lds	r18, 0x0658
    3158:	30 91 59 06 	lds	r19, 0x0659
    315c:	89 81       	ldd	r24, Y+1	; 0x01
    315e:	9a 81       	ldd	r25, Y+2	; 0x02
    3160:	82 17       	cp	r24, r18
    3162:	93 07       	cpc	r25, r19
    3164:	81 f4       	brne	.+32     	; 0x3186 <vTaskDelete+0x9a>
				/* A task is deleting itself.  This cannot complete within the
				task itself, as a context switch to another task is required.
				Place the task in the termination list.  The idle task will
				check the termination list and free up any memory allocated by
				the scheduler for the TCB and stack of the deleted task. */
				vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
    3166:	89 81       	ldd	r24, Y+1	; 0x01
    3168:	9a 81       	ldd	r25, Y+2	; 0x02
    316a:	9c 01       	movw	r18, r24
    316c:	2e 5f       	subi	r18, 0xFE	; 254
    316e:	3f 4f       	sbci	r19, 0xFF	; 255
    3170:	8c ea       	ldi	r24, 0xAC	; 172
    3172:	96 e0       	ldi	r25, 0x06	; 6
    3174:	b9 01       	movw	r22, r18
    3176:	0e 94 18 07 	call	0xe30	; 0xe30 <vListInsertEnd>

				/* Increment the ucTasksDeleted variable so the idle task knows
				there is a task that has been deleted and that it should therefore
				check the xTasksWaitingTermination list. */
				++uxDeletedTasksWaitingCleanUp;
    317a:	80 91 5a 06 	lds	r24, 0x065A
    317e:	8f 5f       	subi	r24, 0xFF	; 255
    3180:	80 93 5a 06 	sts	0x065A, r24
    3184:	0b c0       	rjmp	.+22     	; 0x319c <vTaskDelete+0xb0>
				required. */
				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
			}
			else
			{
				--uxCurrentNumberOfTasks;
    3186:	80 91 5b 06 	lds	r24, 0x065B
    318a:	81 50       	subi	r24, 0x01	; 1
    318c:	80 93 5b 06 	sts	0x065B, r24
				prvDeleteTCB( pxTCB );
    3190:	89 81       	ldd	r24, Y+1	; 0x01
    3192:	9a 81       	ldd	r25, Y+2	; 0x02
    3194:	0e 94 45 1f 	call	0x3e8a	; 0x3e8a <prvDeleteTCB>

				/* Reset the next expected unblock time in case it referred to
				the task that has just been deleted. */
				prvResetNextTaskUnblockTime();
    3198:	0e 94 5b 1f 	call	0x3eb6	; 0x3eb6 <prvResetNextTaskUnblockTime>
			}

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
    319c:	0f 90       	pop	r0
    319e:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if it is the currently running task that has just
		been deleted. */
		if( xSchedulerRunning != pdFALSE )
    31a0:	80 91 5f 06 	lds	r24, 0x065F
    31a4:	88 23       	and	r24, r24
    31a6:	59 f0       	breq	.+22     	; 0x31be <vTaskDelete+0xd2>
		{
			if( pxTCB == pxCurrentTCB )
    31a8:	20 91 58 06 	lds	r18, 0x0658
    31ac:	30 91 59 06 	lds	r19, 0x0659
    31b0:	89 81       	ldd	r24, Y+1	; 0x01
    31b2:	9a 81       	ldd	r25, Y+2	; 0x02
    31b4:	82 17       	cp	r24, r18
    31b6:	93 07       	cpc	r25, r19
    31b8:	11 f4       	brne	.+4      	; 0x31be <vTaskDelete+0xd2>
			{
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
    31ba:	0e 94 08 02 	call	0x410	; 0x410 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
    31be:	26 96       	adiw	r28, 0x06	; 6
    31c0:	0f b6       	in	r0, 0x3f	; 63
    31c2:	f8 94       	cli
    31c4:	de bf       	out	0x3e, r29	; 62
    31c6:	0f be       	out	0x3f, r0	; 63
    31c8:	cd bf       	out	0x3d, r28	; 61
    31ca:	cf 91       	pop	r28
    31cc:	df 91       	pop	r29
    31ce:	08 95       	ret

000031d0 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
    31d0:	df 93       	push	r29
    31d2:	cf 93       	push	r28
    31d4:	00 d0       	rcall	.+0      	; 0x31d6 <vTaskDelay+0x6>
    31d6:	0f 92       	push	r0
    31d8:	cd b7       	in	r28, 0x3d	; 61
    31da:	de b7       	in	r29, 0x3e	; 62
    31dc:	9b 83       	std	Y+3, r25	; 0x03
    31de:	8a 83       	std	Y+2, r24	; 0x02
	BaseType_t xAlreadyYielded = pdFALSE;
    31e0:	19 82       	std	Y+1, r1	; 0x01

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
    31e2:	8a 81       	ldd	r24, Y+2	; 0x02
    31e4:	9b 81       	ldd	r25, Y+3	; 0x03
    31e6:	00 97       	sbiw	r24, 0x00	; 0
    31e8:	51 f0       	breq	.+20     	; 0x31fe <vTaskDelay+0x2e>
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
    31ea:	0e 94 b5 1a 	call	0x356a	; 0x356a <vTaskSuspendAll>
				list or removed from the blocked list until the scheduler
				is resumed.

				This task cannot be in an event list as it is the currently
				executing task. */
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
    31ee:	8a 81       	ldd	r24, Y+2	; 0x02
    31f0:	9b 81       	ldd	r25, Y+3	; 0x03
    31f2:	60 e0       	ldi	r22, 0x00	; 0
    31f4:	0e 94 67 23 	call	0x46ce	; 0x46ce <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    31f8:	0e 94 c1 1a 	call	0x3582	; 0x3582 <xTaskResumeAll>
    31fc:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    31fe:	89 81       	ldd	r24, Y+1	; 0x01
    3200:	88 23       	and	r24, r24
    3202:	11 f4       	brne	.+4      	; 0x3208 <vTaskDelay+0x38>
		{
			portYIELD_WITHIN_API();
    3204:	0e 94 08 02 	call	0x410	; 0x410 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    3208:	0f 90       	pop	r0
    320a:	0f 90       	pop	r0
    320c:	0f 90       	pop	r0
    320e:	cf 91       	pop	r28
    3210:	df 91       	pop	r29
    3212:	08 95       	ret

00003214 <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
	{
    3214:	df 93       	push	r29
    3216:	cf 93       	push	r28
    3218:	00 d0       	rcall	.+0      	; 0x321a <vTaskSuspend+0x6>
    321a:	00 d0       	rcall	.+0      	; 0x321c <vTaskSuspend+0x8>
    321c:	00 d0       	rcall	.+0      	; 0x321e <vTaskSuspend+0xa>
    321e:	cd b7       	in	r28, 0x3d	; 61
    3220:	de b7       	in	r29, 0x3e	; 62
    3222:	9c 83       	std	Y+4, r25	; 0x04
    3224:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
    3226:	0f b6       	in	r0, 0x3f	; 63
    3228:	f8 94       	cli
    322a:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the running task that is
			being suspended. */
			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
    322c:	8b 81       	ldd	r24, Y+3	; 0x03
    322e:	9c 81       	ldd	r25, Y+4	; 0x04
    3230:	00 97       	sbiw	r24, 0x00	; 0
    3232:	39 f4       	brne	.+14     	; 0x3242 <vTaskSuspend+0x2e>
    3234:	80 91 58 06 	lds	r24, 0x0658
    3238:	90 91 59 06 	lds	r25, 0x0659
    323c:	9e 83       	std	Y+6, r25	; 0x06
    323e:	8d 83       	std	Y+5, r24	; 0x05
    3240:	04 c0       	rjmp	.+8      	; 0x324a <vTaskSuspend+0x36>
    3242:	8b 81       	ldd	r24, Y+3	; 0x03
    3244:	9c 81       	ldd	r25, Y+4	; 0x04
    3246:	9e 83       	std	Y+6, r25	; 0x06
    3248:	8d 83       	std	Y+5, r24	; 0x05
    324a:	8d 81       	ldd	r24, Y+5	; 0x05
    324c:	9e 81       	ldd	r25, Y+6	; 0x06
    324e:	9a 83       	std	Y+2, r25	; 0x02
    3250:	89 83       	std	Y+1, r24	; 0x01

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the
			suspended list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    3252:	89 81       	ldd	r24, Y+1	; 0x01
    3254:	9a 81       	ldd	r25, Y+2	; 0x02
    3256:	02 96       	adiw	r24, 0x02	; 2
    3258:	0e 94 c8 07 	call	0xf90	; 0xf90 <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    325c:	e9 81       	ldd	r30, Y+1	; 0x01
    325e:	fa 81       	ldd	r31, Y+2	; 0x02
    3260:	84 89       	ldd	r24, Z+20	; 0x14
    3262:	95 89       	ldd	r25, Z+21	; 0x15
    3264:	00 97       	sbiw	r24, 0x00	; 0
    3266:	29 f0       	breq	.+10     	; 0x3272 <vTaskSuspend+0x5e>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    3268:	89 81       	ldd	r24, Y+1	; 0x01
    326a:	9a 81       	ldd	r25, Y+2	; 0x02
    326c:	0c 96       	adiw	r24, 0x0c	; 12
    326e:	0e 94 c8 07 	call	0xf90	; 0xf90 <uxListRemove>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
    3272:	89 81       	ldd	r24, Y+1	; 0x01
    3274:	9a 81       	ldd	r25, Y+2	; 0x02
    3276:	9c 01       	movw	r18, r24
    3278:	2e 5f       	subi	r18, 0xFE	; 254
    327a:	3f 4f       	sbci	r19, 0xFF	; 255
    327c:	85 eb       	ldi	r24, 0xB5	; 181
    327e:	96 e0       	ldi	r25, 0x06	; 6
    3280:	b9 01       	movw	r22, r18
    3282:	0e 94 18 07 	call	0xe30	; 0xe30 <vListInsertEnd>

			#if( configUSE_TASK_NOTIFICATIONS == 1 )
			{
				if( pxTCB->ucNotifyState == taskWAITING_NOTIFICATION )
    3286:	e9 81       	ldd	r30, Y+1	; 0x01
    3288:	fa 81       	ldd	r31, Y+2	; 0x02
    328a:	87 a1       	ldd	r24, Z+39	; 0x27
    328c:	81 30       	cpi	r24, 0x01	; 1
    328e:	19 f4       	brne	.+6      	; 0x3296 <vTaskSuspend+0x82>
				{
					/* The task was blocked to wait for a notification, but is
					now suspended, so no notification was received. */
					pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    3290:	e9 81       	ldd	r30, Y+1	; 0x01
    3292:	fa 81       	ldd	r31, Y+2	; 0x02
    3294:	17 a2       	std	Z+39, r1	; 0x27
				}
			}
			#endif
		}
		taskEXIT_CRITICAL();
    3296:	0f 90       	pop	r0
    3298:	0f be       	out	0x3f, r0	; 63

		if( xSchedulerRunning != pdFALSE )
    329a:	80 91 5f 06 	lds	r24, 0x065F
    329e:	88 23       	and	r24, r24
    32a0:	39 f0       	breq	.+14     	; 0x32b0 <vTaskSuspend+0x9c>
		{
			/* Reset the next expected unblock time in case it referred to the
			task that is now in the Suspended state. */
			taskENTER_CRITICAL();
    32a2:	0f b6       	in	r0, 0x3f	; 63
    32a4:	f8 94       	cli
    32a6:	0f 92       	push	r0
			{
				prvResetNextTaskUnblockTime();
    32a8:	0e 94 5b 1f 	call	0x3eb6	; 0x3eb6 <prvResetNextTaskUnblockTime>
			}
			taskEXIT_CRITICAL();
    32ac:	0f 90       	pop	r0
    32ae:	0f be       	out	0x3f, r0	; 63
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( pxTCB == pxCurrentTCB )
    32b0:	20 91 58 06 	lds	r18, 0x0658
    32b4:	30 91 59 06 	lds	r19, 0x0659
    32b8:	89 81       	ldd	r24, Y+1	; 0x01
    32ba:	9a 81       	ldd	r25, Y+2	; 0x02
    32bc:	82 17       	cp	r24, r18
    32be:	93 07       	cpc	r25, r19
    32c0:	a1 f4       	brne	.+40     	; 0x32ea <vTaskSuspend+0xd6>
		{
			if( xSchedulerRunning != pdFALSE )
    32c2:	80 91 5f 06 	lds	r24, 0x065F
    32c6:	88 23       	and	r24, r24
    32c8:	19 f0       	breq	.+6      	; 0x32d0 <vTaskSuspend+0xbc>
			{
				/* The current task has just been suspended. */
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
    32ca:	0e 94 08 02 	call	0x410	; 0x410 <vPortYield>
    32ce:	0d c0       	rjmp	.+26     	; 0x32ea <vTaskSuspend+0xd6>
			else
			{
				/* The scheduler is not running, but the task that was pointed
				to by pxCurrentTCB has just been suspended and pxCurrentTCB
				must be adjusted to point to a different task. */
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks ) /*lint !e931 Right has no side effect, just volatile. */
    32d0:	90 91 b5 06 	lds	r25, 0x06B5
    32d4:	80 91 5b 06 	lds	r24, 0x065B
    32d8:	98 17       	cp	r25, r24
    32da:	29 f4       	brne	.+10     	; 0x32e6 <vTaskSuspend+0xd2>
				{
					/* No other tasks are ready, so set pxCurrentTCB back to
					NULL so when the next task is created pxCurrentTCB will
					be set to point to it no matter what its relative priority
					is. */
					pxCurrentTCB = NULL;
    32dc:	10 92 59 06 	sts	0x0659, r1
    32e0:	10 92 58 06 	sts	0x0658, r1
    32e4:	02 c0       	rjmp	.+4      	; 0x32ea <vTaskSuspend+0xd6>
				}
				else
				{
					vTaskSwitchContext();
    32e6:	0e 94 96 1c 	call	0x392c	; 0x392c <vTaskSwitchContext>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    32ea:	26 96       	adiw	r28, 0x06	; 6
    32ec:	0f b6       	in	r0, 0x3f	; 63
    32ee:	f8 94       	cli
    32f0:	de bf       	out	0x3e, r29	; 62
    32f2:	0f be       	out	0x3f, r0	; 63
    32f4:	cd bf       	out	0x3d, r28	; 61
    32f6:	cf 91       	pop	r28
    32f8:	df 91       	pop	r29
    32fa:	08 95       	ret

000032fc <prvTaskIsTaskSuspended>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
	{
    32fc:	df 93       	push	r29
    32fe:	cf 93       	push	r28
    3300:	00 d0       	rcall	.+0      	; 0x3302 <prvTaskIsTaskSuspended+0x6>
    3302:	00 d0       	rcall	.+0      	; 0x3304 <prvTaskIsTaskSuspended+0x8>
    3304:	0f 92       	push	r0
    3306:	cd b7       	in	r28, 0x3d	; 61
    3308:	de b7       	in	r29, 0x3e	; 62
    330a:	9d 83       	std	Y+5, r25	; 0x05
    330c:	8c 83       	std	Y+4, r24	; 0x04
	BaseType_t xReturn = pdFALSE;
    330e:	1b 82       	std	Y+3, r1	; 0x03
	const TCB_t * const pxTCB = xTask;
    3310:	8c 81       	ldd	r24, Y+4	; 0x04
    3312:	9d 81       	ldd	r25, Y+5	; 0x05
    3314:	9a 83       	std	Y+2, r25	; 0x02
    3316:	89 83       	std	Y+1, r24	; 0x01

		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );

		/* Is the task being resumed actually in the suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
    3318:	e9 81       	ldd	r30, Y+1	; 0x01
    331a:	fa 81       	ldd	r31, Y+2	; 0x02
    331c:	82 85       	ldd	r24, Z+10	; 0x0a
    331e:	93 85       	ldd	r25, Z+11	; 0x0b
    3320:	26 e0       	ldi	r18, 0x06	; 6
    3322:	85 3b       	cpi	r24, 0xB5	; 181
    3324:	92 07       	cpc	r25, r18
    3326:	81 f4       	brne	.+32     	; 0x3348 <prvTaskIsTaskSuspended+0x4c>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
    3328:	e9 81       	ldd	r30, Y+1	; 0x01
    332a:	fa 81       	ldd	r31, Y+2	; 0x02
    332c:	84 89       	ldd	r24, Z+20	; 0x14
    332e:	95 89       	ldd	r25, Z+21	; 0x15
    3330:	26 e0       	ldi	r18, 0x06	; 6
    3332:	83 3a       	cpi	r24, 0xA3	; 163
    3334:	92 07       	cpc	r25, r18
    3336:	41 f0       	breq	.+16     	; 0x3348 <prvTaskIsTaskSuspended+0x4c>
			{
				/* Is it in the suspended list because it is in the	Suspended
				state, or because is is blocked with no timeout? */
				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE ) /*lint !e961.  The cast is only redundant when NULL is used. */
    3338:	e9 81       	ldd	r30, Y+1	; 0x01
    333a:	fa 81       	ldd	r31, Y+2	; 0x02
    333c:	84 89       	ldd	r24, Z+20	; 0x14
    333e:	95 89       	ldd	r25, Z+21	; 0x15
    3340:	00 97       	sbiw	r24, 0x00	; 0
    3342:	11 f4       	brne	.+4      	; 0x3348 <prvTaskIsTaskSuspended+0x4c>
				{
					xReturn = pdTRUE;
    3344:	81 e0       	ldi	r24, 0x01	; 1
    3346:	8b 83       	std	Y+3, r24	; 0x03
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
    3348:	8b 81       	ldd	r24, Y+3	; 0x03
	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
    334a:	0f 90       	pop	r0
    334c:	0f 90       	pop	r0
    334e:	0f 90       	pop	r0
    3350:	0f 90       	pop	r0
    3352:	0f 90       	pop	r0
    3354:	cf 91       	pop	r28
    3356:	df 91       	pop	r29
    3358:	08 95       	ret

0000335a <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskResume( TaskHandle_t xTaskToResume )
	{
    335a:	df 93       	push	r29
    335c:	cf 93       	push	r28
    335e:	00 d0       	rcall	.+0      	; 0x3360 <vTaskResume+0x6>
    3360:	00 d0       	rcall	.+0      	; 0x3362 <vTaskResume+0x8>
    3362:	cd b7       	in	r28, 0x3d	; 61
    3364:	de b7       	in	r29, 0x3e	; 62
    3366:	9c 83       	std	Y+4, r25	; 0x04
    3368:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t * const pxTCB = xTaskToResume;
    336a:	8b 81       	ldd	r24, Y+3	; 0x03
    336c:	9c 81       	ldd	r25, Y+4	; 0x04
    336e:	9a 83       	std	Y+2, r25	; 0x02
    3370:	89 83       	std	Y+1, r24	; 0x01
		/* It does not make sense to resume the calling task. */
		configASSERT( xTaskToResume );

		/* The parameter cannot be NULL as it is impossible to resume the
		currently executing task. */
		if( ( pxTCB != pxCurrentTCB ) && ( pxTCB != NULL ) )
    3372:	20 91 58 06 	lds	r18, 0x0658
    3376:	30 91 59 06 	lds	r19, 0x0659
    337a:	89 81       	ldd	r24, Y+1	; 0x01
    337c:	9a 81       	ldd	r25, Y+2	; 0x02
    337e:	82 17       	cp	r24, r18
    3380:	93 07       	cpc	r25, r19
    3382:	09 f4       	brne	.+2      	; 0x3386 <vTaskResume+0x2c>
    3384:	47 c0       	rjmp	.+142    	; 0x3414 <vTaskResume+0xba>
    3386:	89 81       	ldd	r24, Y+1	; 0x01
    3388:	9a 81       	ldd	r25, Y+2	; 0x02
    338a:	00 97       	sbiw	r24, 0x00	; 0
    338c:	09 f4       	brne	.+2      	; 0x3390 <vTaskResume+0x36>
    338e:	42 c0       	rjmp	.+132    	; 0x3414 <vTaskResume+0xba>
		{
			taskENTER_CRITICAL();
    3390:	0f b6       	in	r0, 0x3f	; 63
    3392:	f8 94       	cli
    3394:	0f 92       	push	r0
			{
				if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
    3396:	89 81       	ldd	r24, Y+1	; 0x01
    3398:	9a 81       	ldd	r25, Y+2	; 0x02
    339a:	0e 94 7e 19 	call	0x32fc	; 0x32fc <prvTaskIsTaskSuspended>
    339e:	88 23       	and	r24, r24
    33a0:	b9 f1       	breq	.+110    	; 0x3410 <vTaskResume+0xb6>
				{
					traceTASK_RESUME( pxTCB );

					/* The ready list can be accessed even if the scheduler is
					suspended because this is inside a critical section. */
					( void ) uxListRemove(  &( pxTCB->xStateListItem ) );
    33a2:	89 81       	ldd	r24, Y+1	; 0x01
    33a4:	9a 81       	ldd	r25, Y+2	; 0x02
    33a6:	02 96       	adiw	r24, 0x02	; 2
    33a8:	0e 94 c8 07 	call	0xf90	; 0xf90 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    33ac:	e9 81       	ldd	r30, Y+1	; 0x01
    33ae:	fa 81       	ldd	r31, Y+2	; 0x02
    33b0:	96 89       	ldd	r25, Z+22	; 0x16
    33b2:	80 91 5e 06 	lds	r24, 0x065E
    33b6:	89 17       	cp	r24, r25
    33b8:	28 f4       	brcc	.+10     	; 0x33c4 <vTaskResume+0x6a>
    33ba:	e9 81       	ldd	r30, Y+1	; 0x01
    33bc:	fa 81       	ldd	r31, Y+2	; 0x02
    33be:	86 89       	ldd	r24, Z+22	; 0x16
    33c0:	80 93 5e 06 	sts	0x065E, r24
    33c4:	e9 81       	ldd	r30, Y+1	; 0x01
    33c6:	fa 81       	ldd	r31, Y+2	; 0x02
    33c8:	86 89       	ldd	r24, Z+22	; 0x16
    33ca:	28 2f       	mov	r18, r24
    33cc:	30 e0       	ldi	r19, 0x00	; 0
    33ce:	c9 01       	movw	r24, r18
    33d0:	88 0f       	add	r24, r24
    33d2:	99 1f       	adc	r25, r25
    33d4:	88 0f       	add	r24, r24
    33d6:	99 1f       	adc	r25, r25
    33d8:	88 0f       	add	r24, r24
    33da:	99 1f       	adc	r25, r25
    33dc:	82 0f       	add	r24, r18
    33de:	93 1f       	adc	r25, r19
    33e0:	ac 01       	movw	r20, r24
    33e2:	47 59       	subi	r20, 0x97	; 151
    33e4:	59 4f       	sbci	r21, 0xF9	; 249
    33e6:	89 81       	ldd	r24, Y+1	; 0x01
    33e8:	9a 81       	ldd	r25, Y+2	; 0x02
    33ea:	9c 01       	movw	r18, r24
    33ec:	2e 5f       	subi	r18, 0xFE	; 254
    33ee:	3f 4f       	sbci	r19, 0xFF	; 255
    33f0:	ca 01       	movw	r24, r20
    33f2:	b9 01       	movw	r22, r18
    33f4:	0e 94 18 07 	call	0xe30	; 0xe30 <vListInsertEnd>

					/* A higher priority task may have just been resumed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    33f8:	e9 81       	ldd	r30, Y+1	; 0x01
    33fa:	fa 81       	ldd	r31, Y+2	; 0x02
    33fc:	96 89       	ldd	r25, Z+22	; 0x16
    33fe:	e0 91 58 06 	lds	r30, 0x0658
    3402:	f0 91 59 06 	lds	r31, 0x0659
    3406:	86 89       	ldd	r24, Z+22	; 0x16
    3408:	98 17       	cp	r25, r24
    340a:	10 f0       	brcs	.+4      	; 0x3410 <vTaskResume+0xb6>
					{
						/* This yield may not cause the task just resumed to run,
						but will leave the lists in the correct state for the
						next yield. */
						taskYIELD_IF_USING_PREEMPTION();
    340c:	0e 94 08 02 	call	0x410	; 0x410 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
    3410:	0f 90       	pop	r0
    3412:	0f be       	out	0x3f, r0	; 63
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    3414:	0f 90       	pop	r0
    3416:	0f 90       	pop	r0
    3418:	0f 90       	pop	r0
    341a:	0f 90       	pop	r0
    341c:	cf 91       	pop	r28
    341e:	df 91       	pop	r29
    3420:	08 95       	ret

00003422 <xTaskResumeFromISR>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
	{
    3422:	df 93       	push	r29
    3424:	cf 93       	push	r28
    3426:	00 d0       	rcall	.+0      	; 0x3428 <xTaskResumeFromISR+0x6>
    3428:	00 d0       	rcall	.+0      	; 0x342a <xTaskResumeFromISR+0x8>
    342a:	00 d0       	rcall	.+0      	; 0x342c <xTaskResumeFromISR+0xa>
    342c:	cd b7       	in	r28, 0x3d	; 61
    342e:	de b7       	in	r29, 0x3e	; 62
    3430:	9e 83       	std	Y+6, r25	; 0x06
    3432:	8d 83       	std	Y+5, r24	; 0x05
	BaseType_t xYieldRequired = pdFALSE;
    3434:	1c 82       	std	Y+4, r1	; 0x04
	TCB_t * const pxTCB = xTaskToResume;
    3436:	8d 81       	ldd	r24, Y+5	; 0x05
    3438:	9e 81       	ldd	r25, Y+6	; 0x06
    343a:	9b 83       	std	Y+3, r25	; 0x03
    343c:	8a 83       	std	Y+2, r24	; 0x02
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		https://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    343e:	19 82       	std	Y+1, r1	; 0x01
		{
			if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
    3440:	8a 81       	ldd	r24, Y+2	; 0x02
    3442:	9b 81       	ldd	r25, Y+3	; 0x03
    3444:	0e 94 7e 19 	call	0x32fc	; 0x32fc <prvTaskIsTaskSuspended>
    3448:	88 23       	and	r24, r24
    344a:	09 f4       	brne	.+2      	; 0x344e <xTaskResumeFromISR+0x2c>
    344c:	46 c0       	rjmp	.+140    	; 0x34da <xTaskResumeFromISR+0xb8>
			{
				traceTASK_RESUME_FROM_ISR( pxTCB );

				/* Check the ready lists can be accessed. */
				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    344e:	80 91 68 06 	lds	r24, 0x0668
    3452:	88 23       	and	r24, r24
    3454:	c1 f5       	brne	.+112    	; 0x34c6 <xTaskResumeFromISR+0xa4>
				{
					/* Ready lists can be accessed so move the task from the
					suspended list to the ready list directly. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    3456:	ea 81       	ldd	r30, Y+2	; 0x02
    3458:	fb 81       	ldd	r31, Y+3	; 0x03
    345a:	96 89       	ldd	r25, Z+22	; 0x16
    345c:	e0 91 58 06 	lds	r30, 0x0658
    3460:	f0 91 59 06 	lds	r31, 0x0659
    3464:	86 89       	ldd	r24, Z+22	; 0x16
    3466:	98 17       	cp	r25, r24
    3468:	10 f0       	brcs	.+4      	; 0x346e <xTaskResumeFromISR+0x4c>
					{
						xYieldRequired = pdTRUE;
    346a:	81 e0       	ldi	r24, 0x01	; 1
    346c:	8c 83       	std	Y+4, r24	; 0x04
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    346e:	8a 81       	ldd	r24, Y+2	; 0x02
    3470:	9b 81       	ldd	r25, Y+3	; 0x03
    3472:	02 96       	adiw	r24, 0x02	; 2
    3474:	0e 94 c8 07 	call	0xf90	; 0xf90 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    3478:	ea 81       	ldd	r30, Y+2	; 0x02
    347a:	fb 81       	ldd	r31, Y+3	; 0x03
    347c:	96 89       	ldd	r25, Z+22	; 0x16
    347e:	80 91 5e 06 	lds	r24, 0x065E
    3482:	89 17       	cp	r24, r25
    3484:	28 f4       	brcc	.+10     	; 0x3490 <xTaskResumeFromISR+0x6e>
    3486:	ea 81       	ldd	r30, Y+2	; 0x02
    3488:	fb 81       	ldd	r31, Y+3	; 0x03
    348a:	86 89       	ldd	r24, Z+22	; 0x16
    348c:	80 93 5e 06 	sts	0x065E, r24
    3490:	ea 81       	ldd	r30, Y+2	; 0x02
    3492:	fb 81       	ldd	r31, Y+3	; 0x03
    3494:	86 89       	ldd	r24, Z+22	; 0x16
    3496:	28 2f       	mov	r18, r24
    3498:	30 e0       	ldi	r19, 0x00	; 0
    349a:	c9 01       	movw	r24, r18
    349c:	88 0f       	add	r24, r24
    349e:	99 1f       	adc	r25, r25
    34a0:	88 0f       	add	r24, r24
    34a2:	99 1f       	adc	r25, r25
    34a4:	88 0f       	add	r24, r24
    34a6:	99 1f       	adc	r25, r25
    34a8:	82 0f       	add	r24, r18
    34aa:	93 1f       	adc	r25, r19
    34ac:	ac 01       	movw	r20, r24
    34ae:	47 59       	subi	r20, 0x97	; 151
    34b0:	59 4f       	sbci	r21, 0xF9	; 249
    34b2:	8a 81       	ldd	r24, Y+2	; 0x02
    34b4:	9b 81       	ldd	r25, Y+3	; 0x03
    34b6:	9c 01       	movw	r18, r24
    34b8:	2e 5f       	subi	r18, 0xFE	; 254
    34ba:	3f 4f       	sbci	r19, 0xFF	; 255
    34bc:	ca 01       	movw	r24, r20
    34be:	b9 01       	movw	r22, r18
    34c0:	0e 94 18 07 	call	0xe30	; 0xe30 <vListInsertEnd>
    34c4:	0a c0       	rjmp	.+20     	; 0x34da <xTaskResumeFromISR+0xb8>
				else
				{
					/* The delayed or ready lists cannot be accessed so the task
					is held in the pending ready list until the scheduler is
					unsuspended. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    34c6:	8a 81       	ldd	r24, Y+2	; 0x02
    34c8:	9b 81       	ldd	r25, Y+3	; 0x03
    34ca:	9c 01       	movw	r18, r24
    34cc:	24 5f       	subi	r18, 0xF4	; 244
    34ce:	3f 4f       	sbci	r19, 0xFF	; 255
    34d0:	83 ea       	ldi	r24, 0xA3	; 163
    34d2:	96 e0       	ldi	r25, 0x06	; 6
    34d4:	b9 01       	movw	r22, r18
    34d6:	0e 94 18 07 	call	0xe30	; 0xe30 <vListInsertEnd>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xYieldRequired;
    34da:	8c 81       	ldd	r24, Y+4	; 0x04
	}
    34dc:	26 96       	adiw	r28, 0x06	; 6
    34de:	0f b6       	in	r0, 0x3f	; 63
    34e0:	f8 94       	cli
    34e2:	de bf       	out	0x3e, r29	; 62
    34e4:	0f be       	out	0x3f, r0	; 63
    34e6:	cd bf       	out	0x3d, r28	; 61
    34e8:	cf 91       	pop	r28
    34ea:	df 91       	pop	r29
    34ec:	08 95       	ret

000034ee <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
    34ee:	ef 92       	push	r14
    34f0:	ff 92       	push	r15
    34f2:	0f 93       	push	r16
    34f4:	df 93       	push	r29
    34f6:	cf 93       	push	r28
    34f8:	0f 92       	push	r0
    34fa:	cd b7       	in	r28, 0x3d	; 61
    34fc:	de b7       	in	r29, 0x3e	; 62
		}
	}
	#else
	{
		/* The Idle task is being created using dynamically allocated RAM. */
		xReturn = xTaskCreate(	prvIdleTask,
    34fe:	8b ec       	ldi	r24, 0xCB	; 203
    3500:	9e e1       	ldi	r25, 0x1E	; 30
    3502:	20 e6       	ldi	r18, 0x60	; 96
    3504:	30 e0       	ldi	r19, 0x00	; 0
    3506:	e6 e6       	ldi	r30, 0x66	; 102
    3508:	f6 e0       	ldi	r31, 0x06	; 6
    350a:	b9 01       	movw	r22, r18
    350c:	45 e5       	ldi	r20, 0x55	; 85
    350e:	50 e0       	ldi	r21, 0x00	; 0
    3510:	20 e0       	ldi	r18, 0x00	; 0
    3512:	30 e0       	ldi	r19, 0x00	; 0
    3514:	00 e0       	ldi	r16, 0x00	; 0
    3516:	7f 01       	movw	r14, r30
    3518:	0e 94 ca 16 	call	0x2d94	; 0x2d94 <xTaskCreate>
    351c:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
    351e:	89 81       	ldd	r24, Y+1	; 0x01
    3520:	81 30       	cpi	r24, 0x01	; 1
    3522:	81 f4       	brne	.+32     	; 0x3544 <vTaskStartScheduler+0x56>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
    3524:	f8 94       	cli
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
    3526:	8f ef       	ldi	r24, 0xFF	; 255
    3528:	9f ef       	ldi	r25, 0xFF	; 255
    352a:	90 93 65 06 	sts	0x0665, r25
    352e:	80 93 64 06 	sts	0x0664, r24
		xSchedulerRunning = pdTRUE;
    3532:	81 e0       	ldi	r24, 0x01	; 1
    3534:	80 93 5f 06 	sts	0x065F, r24
		xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
    3538:	10 92 5d 06 	sts	0x065D, r1
    353c:	10 92 5c 06 	sts	0x065C, r1

		traceTASK_SWITCHED_IN();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    3540:	0e 94 cc 01 	call	0x398	; 0x398 <xPortStartScheduler>
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
    3544:	0f 90       	pop	r0
    3546:	cf 91       	pop	r28
    3548:	df 91       	pop	r29
    354a:	0f 91       	pop	r16
    354c:	ff 90       	pop	r15
    354e:	ef 90       	pop	r14
    3550:	08 95       	ret

00003552 <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    3552:	df 93       	push	r29
    3554:	cf 93       	push	r28
    3556:	cd b7       	in	r28, 0x3d	; 61
    3558:	de b7       	in	r29, 0x3e	; 62
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    355a:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    355c:	10 92 5f 06 	sts	0x065F, r1
	vPortEndScheduler();
    3560:	0e 94 01 02 	call	0x402	; 0x402 <vPortEndScheduler>
}
    3564:	cf 91       	pop	r28
    3566:	df 91       	pop	r29
    3568:	08 95       	ret

0000356a <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    356a:	df 93       	push	r29
    356c:	cf 93       	push	r28
    356e:	cd b7       	in	r28, 0x3d	; 61
    3570:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
    3572:	80 91 68 06 	lds	r24, 0x0668
    3576:	8f 5f       	subi	r24, 0xFF	; 255
    3578:	80 93 68 06 	sts	0x0668, r24
}
    357c:	cf 91       	pop	r28
    357e:	df 91       	pop	r29
    3580:	08 95       	ret

00003582 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
    3582:	df 93       	push	r29
    3584:	cf 93       	push	r28
    3586:	00 d0       	rcall	.+0      	; 0x3588 <xTaskResumeAll+0x6>
    3588:	00 d0       	rcall	.+0      	; 0x358a <xTaskResumeAll+0x8>
    358a:	cd b7       	in	r28, 0x3d	; 61
    358c:	de b7       	in	r29, 0x3e	; 62
TCB_t *pxTCB = NULL;
    358e:	1c 82       	std	Y+4, r1	; 0x04
    3590:	1b 82       	std	Y+3, r1	; 0x03
BaseType_t xAlreadyYielded = pdFALSE;
    3592:	1a 82       	std	Y+2, r1	; 0x02
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    3594:	0f b6       	in	r0, 0x3f	; 63
    3596:	f8 94       	cli
    3598:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    359a:	80 91 68 06 	lds	r24, 0x0668
    359e:	81 50       	subi	r24, 0x01	; 1
    35a0:	80 93 68 06 	sts	0x0668, r24

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    35a4:	80 91 68 06 	lds	r24, 0x0668
    35a8:	88 23       	and	r24, r24
    35aa:	09 f0       	breq	.+2      	; 0x35ae <xTaskResumeAll+0x2c>
    35ac:	73 c0       	rjmp	.+230    	; 0x3694 <xTaskResumeAll+0x112>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    35ae:	80 91 5b 06 	lds	r24, 0x065B
    35b2:	88 23       	and	r24, r24
    35b4:	09 f4       	brne	.+2      	; 0x35b8 <xTaskResumeAll+0x36>
    35b6:	6e c0       	rjmp	.+220    	; 0x3694 <xTaskResumeAll+0x112>
    35b8:	45 c0       	rjmp	.+138    	; 0x3644 <xTaskResumeAll+0xc2>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    35ba:	e0 91 a8 06 	lds	r30, 0x06A8
    35be:	f0 91 a9 06 	lds	r31, 0x06A9
    35c2:	86 81       	ldd	r24, Z+6	; 0x06
    35c4:	97 81       	ldd	r25, Z+7	; 0x07
    35c6:	9c 83       	std	Y+4, r25	; 0x04
    35c8:	8b 83       	std	Y+3, r24	; 0x03
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    35ca:	8b 81       	ldd	r24, Y+3	; 0x03
    35cc:	9c 81       	ldd	r25, Y+4	; 0x04
    35ce:	0c 96       	adiw	r24, 0x0c	; 12
    35d0:	0e 94 c8 07 	call	0xf90	; 0xf90 <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    35d4:	8b 81       	ldd	r24, Y+3	; 0x03
    35d6:	9c 81       	ldd	r25, Y+4	; 0x04
    35d8:	02 96       	adiw	r24, 0x02	; 2
    35da:	0e 94 c8 07 	call	0xf90	; 0xf90 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    35de:	eb 81       	ldd	r30, Y+3	; 0x03
    35e0:	fc 81       	ldd	r31, Y+4	; 0x04
    35e2:	96 89       	ldd	r25, Z+22	; 0x16
    35e4:	80 91 5e 06 	lds	r24, 0x065E
    35e8:	89 17       	cp	r24, r25
    35ea:	28 f4       	brcc	.+10     	; 0x35f6 <xTaskResumeAll+0x74>
    35ec:	eb 81       	ldd	r30, Y+3	; 0x03
    35ee:	fc 81       	ldd	r31, Y+4	; 0x04
    35f0:	86 89       	ldd	r24, Z+22	; 0x16
    35f2:	80 93 5e 06 	sts	0x065E, r24
    35f6:	eb 81       	ldd	r30, Y+3	; 0x03
    35f8:	fc 81       	ldd	r31, Y+4	; 0x04
    35fa:	86 89       	ldd	r24, Z+22	; 0x16
    35fc:	28 2f       	mov	r18, r24
    35fe:	30 e0       	ldi	r19, 0x00	; 0
    3600:	c9 01       	movw	r24, r18
    3602:	88 0f       	add	r24, r24
    3604:	99 1f       	adc	r25, r25
    3606:	88 0f       	add	r24, r24
    3608:	99 1f       	adc	r25, r25
    360a:	88 0f       	add	r24, r24
    360c:	99 1f       	adc	r25, r25
    360e:	82 0f       	add	r24, r18
    3610:	93 1f       	adc	r25, r19
    3612:	ac 01       	movw	r20, r24
    3614:	47 59       	subi	r20, 0x97	; 151
    3616:	59 4f       	sbci	r21, 0xF9	; 249
    3618:	8b 81       	ldd	r24, Y+3	; 0x03
    361a:	9c 81       	ldd	r25, Y+4	; 0x04
    361c:	9c 01       	movw	r18, r24
    361e:	2e 5f       	subi	r18, 0xFE	; 254
    3620:	3f 4f       	sbci	r19, 0xFF	; 255
    3622:	ca 01       	movw	r24, r20
    3624:	b9 01       	movw	r22, r18
    3626:	0e 94 18 07 	call	0xe30	; 0xe30 <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    362a:	eb 81       	ldd	r30, Y+3	; 0x03
    362c:	fc 81       	ldd	r31, Y+4	; 0x04
    362e:	96 89       	ldd	r25, Z+22	; 0x16
    3630:	e0 91 58 06 	lds	r30, 0x0658
    3634:	f0 91 59 06 	lds	r31, 0x0659
    3638:	86 89       	ldd	r24, Z+22	; 0x16
    363a:	98 17       	cp	r25, r24
    363c:	18 f0       	brcs	.+6      	; 0x3644 <xTaskResumeAll+0xc2>
					{
						xYieldPending = pdTRUE;
    363e:	81 e0       	ldi	r24, 0x01	; 1
    3640:	80 93 61 06 	sts	0x0661, r24
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    3644:	80 91 a3 06 	lds	r24, 0x06A3
    3648:	88 23       	and	r24, r24
    364a:	09 f0       	breq	.+2      	; 0x364e <xTaskResumeAll+0xcc>
    364c:	b6 cf       	rjmp	.-148    	; 0x35ba <xTaskResumeAll+0x38>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( pxTCB != NULL )
    364e:	8b 81       	ldd	r24, Y+3	; 0x03
    3650:	9c 81       	ldd	r25, Y+4	; 0x04
    3652:	00 97       	sbiw	r24, 0x00	; 0
    3654:	11 f0       	breq	.+4      	; 0x365a <xTaskResumeAll+0xd8>
					which may have prevented the next unblock time from being
					re-calculated, in which case re-calculate it now.  Mainly
					important for low power tickless implementations, where
					this can prevent an unnecessary exit from low power
					state. */
					prvResetNextTaskUnblockTime();
    3656:	0e 94 5b 1f 	call	0x3eb6	; 0x3eb6 <prvResetNextTaskUnblockTime>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				{
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
    365a:	80 91 60 06 	lds	r24, 0x0660
    365e:	89 83       	std	Y+1, r24	; 0x01

					if( uxPendedCounts > ( UBaseType_t ) 0U )
    3660:	89 81       	ldd	r24, Y+1	; 0x01
    3662:	88 23       	and	r24, r24
    3664:	79 f0       	breq	.+30     	; 0x3684 <xTaskResumeAll+0x102>
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
    3666:	0e 94 b1 1b 	call	0x3762	; 0x3762 <xTaskIncrementTick>
    366a:	88 23       	and	r24, r24
    366c:	19 f0       	breq	.+6      	; 0x3674 <xTaskResumeAll+0xf2>
							{
								xYieldPending = pdTRUE;
    366e:	81 e0       	ldi	r24, 0x01	; 1
    3670:	80 93 61 06 	sts	0x0661, r24
							}
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
							--uxPendedCounts;
    3674:	89 81       	ldd	r24, Y+1	; 0x01
    3676:	81 50       	subi	r24, 0x01	; 1
    3678:	89 83       	std	Y+1, r24	; 0x01
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
    367a:	89 81       	ldd	r24, Y+1	; 0x01
    367c:	88 23       	and	r24, r24
    367e:	99 f7       	brne	.-26     	; 0x3666 <xTaskResumeAll+0xe4>

						uxPendedTicks = 0;
    3680:	10 92 60 06 	sts	0x0660, r1
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( xYieldPending != pdFALSE )
    3684:	80 91 61 06 	lds	r24, 0x0661
    3688:	88 23       	and	r24, r24
    368a:	21 f0       	breq	.+8      	; 0x3694 <xTaskResumeAll+0x112>
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
    368c:	81 e0       	ldi	r24, 0x01	; 1
    368e:	8a 83       	std	Y+2, r24	; 0x02
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
    3690:	0e 94 08 02 	call	0x410	; 0x410 <vPortYield>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
    3694:	0f 90       	pop	r0
    3696:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
    3698:	8a 81       	ldd	r24, Y+2	; 0x02
}
    369a:	0f 90       	pop	r0
    369c:	0f 90       	pop	r0
    369e:	0f 90       	pop	r0
    36a0:	0f 90       	pop	r0
    36a2:	cf 91       	pop	r28
    36a4:	df 91       	pop	r29
    36a6:	08 95       	ret

000036a8 <xTaskGetTickCount>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCount( void )
{
    36a8:	df 93       	push	r29
    36aa:	cf 93       	push	r28
    36ac:	00 d0       	rcall	.+0      	; 0x36ae <xTaskGetTickCount+0x6>
    36ae:	cd b7       	in	r28, 0x3d	; 61
    36b0:	de b7       	in	r29, 0x3e	; 62
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portTICK_TYPE_ENTER_CRITICAL();
    36b2:	0f b6       	in	r0, 0x3f	; 63
    36b4:	f8 94       	cli
    36b6:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    36b8:	80 91 5c 06 	lds	r24, 0x065C
    36bc:	90 91 5d 06 	lds	r25, 0x065D
    36c0:	9a 83       	std	Y+2, r25	; 0x02
    36c2:	89 83       	std	Y+1, r24	; 0x01
	}
	portTICK_TYPE_EXIT_CRITICAL();
    36c4:	0f 90       	pop	r0
    36c6:	0f be       	out	0x3f, r0	; 63

	return xTicks;
    36c8:	89 81       	ldd	r24, Y+1	; 0x01
    36ca:	9a 81       	ldd	r25, Y+2	; 0x02
}
    36cc:	0f 90       	pop	r0
    36ce:	0f 90       	pop	r0
    36d0:	cf 91       	pop	r28
    36d2:	df 91       	pop	r29
    36d4:	08 95       	ret

000036d6 <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCountFromISR( void )
{
    36d6:	df 93       	push	r29
    36d8:	cf 93       	push	r28
    36da:	00 d0       	rcall	.+0      	; 0x36dc <xTaskGetTickCountFromISR+0x6>
    36dc:	0f 92       	push	r0
    36de:	cd b7       	in	r28, 0x3d	; 61
    36e0:	de b7       	in	r29, 0x3e	; 62
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: https://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
    36e2:	19 82       	std	Y+1, r1	; 0x01
	{
		xReturn = xTickCount;
    36e4:	80 91 5c 06 	lds	r24, 0x065C
    36e8:	90 91 5d 06 	lds	r25, 0x065D
    36ec:	9b 83       	std	Y+3, r25	; 0x03
    36ee:	8a 83       	std	Y+2, r24	; 0x02
	}
	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    36f0:	8a 81       	ldd	r24, Y+2	; 0x02
    36f2:	9b 81       	ldd	r25, Y+3	; 0x03
}
    36f4:	0f 90       	pop	r0
    36f6:	0f 90       	pop	r0
    36f8:	0f 90       	pop	r0
    36fa:	cf 91       	pop	r28
    36fc:	df 91       	pop	r29
    36fe:	08 95       	ret

00003700 <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

UBaseType_t uxTaskGetNumberOfTasks( void )
{
    3700:	df 93       	push	r29
    3702:	cf 93       	push	r28
    3704:	cd b7       	in	r28, 0x3d	; 61
    3706:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required because the variables are of type
	BaseType_t. */
	return uxCurrentNumberOfTasks;
    3708:	80 91 5b 06 	lds	r24, 0x065B
}
    370c:	cf 91       	pop	r28
    370e:	df 91       	pop	r29
    3710:	08 95       	ret

00003712 <pcTaskGetName>:
/*-----------------------------------------------------------*/

char *pcTaskGetName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    3712:	df 93       	push	r29
    3714:	cf 93       	push	r28
    3716:	00 d0       	rcall	.+0      	; 0x3718 <pcTaskGetName+0x6>
    3718:	00 d0       	rcall	.+0      	; 0x371a <pcTaskGetName+0x8>
    371a:	00 d0       	rcall	.+0      	; 0x371c <pcTaskGetName+0xa>
    371c:	cd b7       	in	r28, 0x3d	; 61
    371e:	de b7       	in	r29, 0x3e	; 62
    3720:	9c 83       	std	Y+4, r25	; 0x04
    3722:	8b 83       	std	Y+3, r24	; 0x03
TCB_t *pxTCB;

	/* If null is passed in here then the name of the calling task is being
	queried. */
	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
    3724:	8b 81       	ldd	r24, Y+3	; 0x03
    3726:	9c 81       	ldd	r25, Y+4	; 0x04
    3728:	00 97       	sbiw	r24, 0x00	; 0
    372a:	39 f4       	brne	.+14     	; 0x373a <pcTaskGetName+0x28>
    372c:	80 91 58 06 	lds	r24, 0x0658
    3730:	90 91 59 06 	lds	r25, 0x0659
    3734:	9e 83       	std	Y+6, r25	; 0x06
    3736:	8d 83       	std	Y+5, r24	; 0x05
    3738:	04 c0       	rjmp	.+8      	; 0x3742 <pcTaskGetName+0x30>
    373a:	8b 81       	ldd	r24, Y+3	; 0x03
    373c:	9c 81       	ldd	r25, Y+4	; 0x04
    373e:	9e 83       	std	Y+6, r25	; 0x06
    3740:	8d 83       	std	Y+5, r24	; 0x05
    3742:	8d 81       	ldd	r24, Y+5	; 0x05
    3744:	9e 81       	ldd	r25, Y+6	; 0x06
    3746:	9a 83       	std	Y+2, r25	; 0x02
    3748:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTCB );
	return &( pxTCB->pcTaskName[ 0 ] );
    374a:	89 81       	ldd	r24, Y+1	; 0x01
    374c:	9a 81       	ldd	r25, Y+2	; 0x02
    374e:	49 96       	adiw	r24, 0x19	; 25
}
    3750:	26 96       	adiw	r28, 0x06	; 6
    3752:	0f b6       	in	r0, 0x3f	; 63
    3754:	f8 94       	cli
    3756:	de bf       	out	0x3e, r29	; 62
    3758:	0f be       	out	0x3f, r0	; 63
    375a:	cd bf       	out	0x3d, r28	; 61
    375c:	cf 91       	pop	r28
    375e:	df 91       	pop	r29
    3760:	08 95       	ret

00003762 <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
    3762:	df 93       	push	r29
    3764:	cf 93       	push	r28
    3766:	cd b7       	in	r28, 0x3d	; 61
    3768:	de b7       	in	r29, 0x3e	; 62
    376a:	29 97       	sbiw	r28, 0x09	; 9
    376c:	0f b6       	in	r0, 0x3f	; 63
    376e:	f8 94       	cli
    3770:	de bf       	out	0x3e, r29	; 62
    3772:	0f be       	out	0x3f, r0	; 63
    3774:	cd bf       	out	0x3d, r28	; 61
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
    3776:	1d 82       	std	Y+5, r1	; 0x05

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    3778:	80 91 68 06 	lds	r24, 0x0668
    377c:	88 23       	and	r24, r24
    377e:	09 f0       	breq	.+2      	; 0x3782 <xTaskIncrementTick+0x20>
    3780:	c0 c0       	rjmp	.+384    	; 0x3902 <xTaskIncrementTick+0x1a0>
	{
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
    3782:	80 91 5c 06 	lds	r24, 0x065C
    3786:	90 91 5d 06 	lds	r25, 0x065D
    378a:	01 96       	adiw	r24, 0x01	; 1
    378c:	9c 83       	std	Y+4, r25	; 0x04
    378e:	8b 83       	std	Y+3, r24	; 0x03

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;
    3790:	8b 81       	ldd	r24, Y+3	; 0x03
    3792:	9c 81       	ldd	r25, Y+4	; 0x04
    3794:	90 93 5d 06 	sts	0x065D, r25
    3798:	80 93 5c 06 	sts	0x065C, r24

		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
    379c:	8b 81       	ldd	r24, Y+3	; 0x03
    379e:	9c 81       	ldd	r25, Y+4	; 0x04
    37a0:	00 97       	sbiw	r24, 0x00	; 0
    37a2:	d9 f4       	brne	.+54     	; 0x37da <xTaskIncrementTick+0x78>
		{
			taskSWITCH_DELAYED_LISTS();
    37a4:	80 91 9f 06 	lds	r24, 0x069F
    37a8:	90 91 a0 06 	lds	r25, 0x06A0
    37ac:	9a 83       	std	Y+2, r25	; 0x02
    37ae:	89 83       	std	Y+1, r24	; 0x01
    37b0:	80 91 a1 06 	lds	r24, 0x06A1
    37b4:	90 91 a2 06 	lds	r25, 0x06A2
    37b8:	90 93 a0 06 	sts	0x06A0, r25
    37bc:	80 93 9f 06 	sts	0x069F, r24
    37c0:	89 81       	ldd	r24, Y+1	; 0x01
    37c2:	9a 81       	ldd	r25, Y+2	; 0x02
    37c4:	90 93 a2 06 	sts	0x06A2, r25
    37c8:	80 93 a1 06 	sts	0x06A1, r24
    37cc:	80 91 62 06 	lds	r24, 0x0662
    37d0:	8f 5f       	subi	r24, 0xFF	; 255
    37d2:	80 93 62 06 	sts	0x0662, r24
    37d6:	0e 94 5b 1f 	call	0x3eb6	; 0x3eb6 <prvResetNextTaskUnblockTime>

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
    37da:	20 91 64 06 	lds	r18, 0x0664
    37de:	30 91 65 06 	lds	r19, 0x0665
    37e2:	8b 81       	ldd	r24, Y+3	; 0x03
    37e4:	9c 81       	ldd	r25, Y+4	; 0x04
    37e6:	82 17       	cp	r24, r18
    37e8:	93 07       	cpc	r25, r19
    37ea:	08 f4       	brcc	.+2      	; 0x37ee <xTaskIncrementTick+0x8c>
    37ec:	71 c0       	rjmp	.+226    	; 0x38d0 <xTaskIncrementTick+0x16e>
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    37ee:	e0 91 9f 06 	lds	r30, 0x069F
    37f2:	f0 91 a0 06 	lds	r31, 0x06A0
    37f6:	80 81       	ld	r24, Z
    37f8:	88 23       	and	r24, r24
    37fa:	39 f4       	brne	.+14     	; 0x380a <xTaskIncrementTick+0xa8>
					/* The delayed list is empty.  Set xNextTaskUnblockTime
					to the maximum possible value so it is extremely
					unlikely that the
					if( xTickCount >= xNextTaskUnblockTime ) test will pass
					next time through. */
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    37fc:	8f ef       	ldi	r24, 0xFF	; 255
    37fe:	9f ef       	ldi	r25, 0xFF	; 255
    3800:	90 93 65 06 	sts	0x0665, r25
    3804:	80 93 64 06 	sts	0x0664, r24
    3808:	63 c0       	rjmp	.+198    	; 0x38d0 <xTaskIncrementTick+0x16e>
				{
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    380a:	e0 91 9f 06 	lds	r30, 0x069F
    380e:	f0 91 a0 06 	lds	r31, 0x06A0
    3812:	05 80       	ldd	r0, Z+5	; 0x05
    3814:	f6 81       	ldd	r31, Z+6	; 0x06
    3816:	e0 2d       	mov	r30, r0
    3818:	86 81       	ldd	r24, Z+6	; 0x06
    381a:	97 81       	ldd	r25, Z+7	; 0x07
    381c:	99 87       	std	Y+9, r25	; 0x09
    381e:	88 87       	std	Y+8, r24	; 0x08
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
    3820:	e8 85       	ldd	r30, Y+8	; 0x08
    3822:	f9 85       	ldd	r31, Y+9	; 0x09
    3824:	82 81       	ldd	r24, Z+2	; 0x02
    3826:	93 81       	ldd	r25, Z+3	; 0x03
    3828:	9f 83       	std	Y+7, r25	; 0x07
    382a:	8e 83       	std	Y+6, r24	; 0x06

					if( xConstTickCount < xItemValue )
    382c:	2b 81       	ldd	r18, Y+3	; 0x03
    382e:	3c 81       	ldd	r19, Y+4	; 0x04
    3830:	8e 81       	ldd	r24, Y+6	; 0x06
    3832:	9f 81       	ldd	r25, Y+7	; 0x07
    3834:	28 17       	cp	r18, r24
    3836:	39 07       	cpc	r19, r25
    3838:	38 f4       	brcc	.+14     	; 0x3848 <xTaskIncrementTick+0xe6>
						/* It is not time to unblock this item yet, but the
						item value is the time at which the task at the head
						of the blocked list must be removed from the Blocked
						state -	so record the item value in
						xNextTaskUnblockTime. */
						xNextTaskUnblockTime = xItemValue;
    383a:	8e 81       	ldd	r24, Y+6	; 0x06
    383c:	9f 81       	ldd	r25, Y+7	; 0x07
    383e:	90 93 65 06 	sts	0x0665, r25
    3842:	80 93 64 06 	sts	0x0664, r24
    3846:	44 c0       	rjmp	.+136    	; 0x38d0 <xTaskIncrementTick+0x16e>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* It is time to remove the item from the Blocked state. */
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    3848:	88 85       	ldd	r24, Y+8	; 0x08
    384a:	99 85       	ldd	r25, Y+9	; 0x09
    384c:	02 96       	adiw	r24, 0x02	; 2
    384e:	0e 94 c8 07 	call	0xf90	; 0xf90 <uxListRemove>

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    3852:	e8 85       	ldd	r30, Y+8	; 0x08
    3854:	f9 85       	ldd	r31, Y+9	; 0x09
    3856:	84 89       	ldd	r24, Z+20	; 0x14
    3858:	95 89       	ldd	r25, Z+21	; 0x15
    385a:	00 97       	sbiw	r24, 0x00	; 0
    385c:	29 f0       	breq	.+10     	; 0x3868 <xTaskIncrementTick+0x106>
					{
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    385e:	88 85       	ldd	r24, Y+8	; 0x08
    3860:	99 85       	ldd	r25, Y+9	; 0x09
    3862:	0c 96       	adiw	r24, 0x0c	; 12
    3864:	0e 94 c8 07 	call	0xf90	; 0xf90 <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
    3868:	e8 85       	ldd	r30, Y+8	; 0x08
    386a:	f9 85       	ldd	r31, Y+9	; 0x09
    386c:	96 89       	ldd	r25, Z+22	; 0x16
    386e:	80 91 5e 06 	lds	r24, 0x065E
    3872:	89 17       	cp	r24, r25
    3874:	28 f4       	brcc	.+10     	; 0x3880 <xTaskIncrementTick+0x11e>
    3876:	e8 85       	ldd	r30, Y+8	; 0x08
    3878:	f9 85       	ldd	r31, Y+9	; 0x09
    387a:	86 89       	ldd	r24, Z+22	; 0x16
    387c:	80 93 5e 06 	sts	0x065E, r24
    3880:	e8 85       	ldd	r30, Y+8	; 0x08
    3882:	f9 85       	ldd	r31, Y+9	; 0x09
    3884:	86 89       	ldd	r24, Z+22	; 0x16
    3886:	28 2f       	mov	r18, r24
    3888:	30 e0       	ldi	r19, 0x00	; 0
    388a:	c9 01       	movw	r24, r18
    388c:	88 0f       	add	r24, r24
    388e:	99 1f       	adc	r25, r25
    3890:	88 0f       	add	r24, r24
    3892:	99 1f       	adc	r25, r25
    3894:	88 0f       	add	r24, r24
    3896:	99 1f       	adc	r25, r25
    3898:	82 0f       	add	r24, r18
    389a:	93 1f       	adc	r25, r19
    389c:	ac 01       	movw	r20, r24
    389e:	47 59       	subi	r20, 0x97	; 151
    38a0:	59 4f       	sbci	r21, 0xF9	; 249
    38a2:	88 85       	ldd	r24, Y+8	; 0x08
    38a4:	99 85       	ldd	r25, Y+9	; 0x09
    38a6:	9c 01       	movw	r18, r24
    38a8:	2e 5f       	subi	r18, 0xFE	; 254
    38aa:	3f 4f       	sbci	r19, 0xFF	; 255
    38ac:	ca 01       	movw	r24, r20
    38ae:	b9 01       	movw	r22, r18
    38b0:	0e 94 18 07 	call	0xe30	; 0xe30 <vListInsertEnd>
					{
						/* Preemption is on, but a context switch should
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    38b4:	e8 85       	ldd	r30, Y+8	; 0x08
    38b6:	f9 85       	ldd	r31, Y+9	; 0x09
    38b8:	96 89       	ldd	r25, Z+22	; 0x16
    38ba:	e0 91 58 06 	lds	r30, 0x0658
    38be:	f0 91 59 06 	lds	r31, 0x0659
    38c2:	86 89       	ldd	r24, Z+22	; 0x16
    38c4:	98 17       	cp	r25, r24
    38c6:	08 f4       	brcc	.+2      	; 0x38ca <xTaskIncrementTick+0x168>
    38c8:	92 cf       	rjmp	.-220    	; 0x37ee <xTaskIncrementTick+0x8c>
						{
							xSwitchRequired = pdTRUE;
    38ca:	81 e0       	ldi	r24, 0x01	; 1
    38cc:	8d 83       	std	Y+5, r24	; 0x05
    38ce:	8f cf       	rjmp	.-226    	; 0x37ee <xTaskIncrementTick+0x8c>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
    38d0:	e0 91 58 06 	lds	r30, 0x0658
    38d4:	f0 91 59 06 	lds	r31, 0x0659
    38d8:	86 89       	ldd	r24, Z+22	; 0x16
    38da:	28 2f       	mov	r18, r24
    38dc:	30 e0       	ldi	r19, 0x00	; 0
    38de:	c9 01       	movw	r24, r18
    38e0:	88 0f       	add	r24, r24
    38e2:	99 1f       	adc	r25, r25
    38e4:	88 0f       	add	r24, r24
    38e6:	99 1f       	adc	r25, r25
    38e8:	88 0f       	add	r24, r24
    38ea:	99 1f       	adc	r25, r25
    38ec:	82 0f       	add	r24, r18
    38ee:	93 1f       	adc	r25, r19
    38f0:	fc 01       	movw	r30, r24
    38f2:	e7 59       	subi	r30, 0x97	; 151
    38f4:	f9 4f       	sbci	r31, 0xF9	; 249
    38f6:	80 81       	ld	r24, Z
    38f8:	82 30       	cpi	r24, 0x02	; 2
    38fa:	40 f0       	brcs	.+16     	; 0x390c <xTaskIncrementTick+0x1aa>
			{
				xSwitchRequired = pdTRUE;
    38fc:	81 e0       	ldi	r24, 0x01	; 1
    38fe:	8d 83       	std	Y+5, r24	; 0x05
    3900:	05 c0       	rjmp	.+10     	; 0x390c <xTaskIncrementTick+0x1aa>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
    3902:	80 91 60 06 	lds	r24, 0x0660
    3906:	8f 5f       	subi	r24, 0xFF	; 255
    3908:	80 93 60 06 	sts	0x0660, r24
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
    390c:	80 91 61 06 	lds	r24, 0x0661
    3910:	88 23       	and	r24, r24
    3912:	11 f0       	breq	.+4      	; 0x3918 <xTaskIncrementTick+0x1b6>
		{
			xSwitchRequired = pdTRUE;
    3914:	81 e0       	ldi	r24, 0x01	; 1
    3916:	8d 83       	std	Y+5, r24	; 0x05
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
    3918:	8d 81       	ldd	r24, Y+5	; 0x05
}
    391a:	29 96       	adiw	r28, 0x09	; 9
    391c:	0f b6       	in	r0, 0x3f	; 63
    391e:	f8 94       	cli
    3920:	de bf       	out	0x3e, r29	; 62
    3922:	0f be       	out	0x3f, r0	; 63
    3924:	cd bf       	out	0x3d, r28	; 61
    3926:	cf 91       	pop	r28
    3928:	df 91       	pop	r29
    392a:	08 95       	ret

0000392c <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    392c:	df 93       	push	r29
    392e:	cf 93       	push	r28
    3930:	00 d0       	rcall	.+0      	; 0x3932 <vTaskSwitchContext+0x6>
    3932:	0f 92       	push	r0
    3934:	cd b7       	in	r28, 0x3d	; 61
    3936:	de b7       	in	r29, 0x3e	; 62
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    3938:	80 91 68 06 	lds	r24, 0x0668
    393c:	88 23       	and	r24, r24
    393e:	21 f0       	breq	.+8      	; 0x3948 <vTaskSwitchContext+0x1c>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
    3940:	81 e0       	ldi	r24, 0x01	; 1
    3942:	80 93 61 06 	sts	0x0661, r24
    3946:	59 c0       	rjmp	.+178    	; 0x39fa <vTaskSwitchContext+0xce>
	}
	else
	{
		xYieldPending = pdFALSE;
    3948:	10 92 61 06 	sts	0x0661, r1
		}
		#endif

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    394c:	80 91 5e 06 	lds	r24, 0x065E
    3950:	8b 83       	std	Y+3, r24	; 0x03
    3952:	03 c0       	rjmp	.+6      	; 0x395a <vTaskSwitchContext+0x2e>
    3954:	8b 81       	ldd	r24, Y+3	; 0x03
    3956:	81 50       	subi	r24, 0x01	; 1
    3958:	8b 83       	std	Y+3, r24	; 0x03
    395a:	8b 81       	ldd	r24, Y+3	; 0x03
    395c:	28 2f       	mov	r18, r24
    395e:	30 e0       	ldi	r19, 0x00	; 0
    3960:	c9 01       	movw	r24, r18
    3962:	88 0f       	add	r24, r24
    3964:	99 1f       	adc	r25, r25
    3966:	88 0f       	add	r24, r24
    3968:	99 1f       	adc	r25, r25
    396a:	88 0f       	add	r24, r24
    396c:	99 1f       	adc	r25, r25
    396e:	82 0f       	add	r24, r18
    3970:	93 1f       	adc	r25, r19
    3972:	fc 01       	movw	r30, r24
    3974:	e7 59       	subi	r30, 0x97	; 151
    3976:	f9 4f       	sbci	r31, 0xF9	; 249
    3978:	80 81       	ld	r24, Z
    397a:	88 23       	and	r24, r24
    397c:	59 f3       	breq	.-42     	; 0x3954 <vTaskSwitchContext+0x28>
    397e:	8b 81       	ldd	r24, Y+3	; 0x03
    3980:	28 2f       	mov	r18, r24
    3982:	30 e0       	ldi	r19, 0x00	; 0
    3984:	c9 01       	movw	r24, r18
    3986:	88 0f       	add	r24, r24
    3988:	99 1f       	adc	r25, r25
    398a:	88 0f       	add	r24, r24
    398c:	99 1f       	adc	r25, r25
    398e:	88 0f       	add	r24, r24
    3990:	99 1f       	adc	r25, r25
    3992:	82 0f       	add	r24, r18
    3994:	93 1f       	adc	r25, r19
    3996:	87 59       	subi	r24, 0x97	; 151
    3998:	99 4f       	sbci	r25, 0xF9	; 249
    399a:	9a 83       	std	Y+2, r25	; 0x02
    399c:	89 83       	std	Y+1, r24	; 0x01
    399e:	e9 81       	ldd	r30, Y+1	; 0x01
    39a0:	fa 81       	ldd	r31, Y+2	; 0x02
    39a2:	01 80       	ldd	r0, Z+1	; 0x01
    39a4:	f2 81       	ldd	r31, Z+2	; 0x02
    39a6:	e0 2d       	mov	r30, r0
    39a8:	82 81       	ldd	r24, Z+2	; 0x02
    39aa:	93 81       	ldd	r25, Z+3	; 0x03
    39ac:	e9 81       	ldd	r30, Y+1	; 0x01
    39ae:	fa 81       	ldd	r31, Y+2	; 0x02
    39b0:	92 83       	std	Z+2, r25	; 0x02
    39b2:	81 83       	std	Z+1, r24	; 0x01
    39b4:	e9 81       	ldd	r30, Y+1	; 0x01
    39b6:	fa 81       	ldd	r31, Y+2	; 0x02
    39b8:	21 81       	ldd	r18, Z+1	; 0x01
    39ba:	32 81       	ldd	r19, Z+2	; 0x02
    39bc:	89 81       	ldd	r24, Y+1	; 0x01
    39be:	9a 81       	ldd	r25, Y+2	; 0x02
    39c0:	03 96       	adiw	r24, 0x03	; 3
    39c2:	28 17       	cp	r18, r24
    39c4:	39 07       	cpc	r19, r25
    39c6:	59 f4       	brne	.+22     	; 0x39de <vTaskSwitchContext+0xb2>
    39c8:	e9 81       	ldd	r30, Y+1	; 0x01
    39ca:	fa 81       	ldd	r31, Y+2	; 0x02
    39cc:	01 80       	ldd	r0, Z+1	; 0x01
    39ce:	f2 81       	ldd	r31, Z+2	; 0x02
    39d0:	e0 2d       	mov	r30, r0
    39d2:	82 81       	ldd	r24, Z+2	; 0x02
    39d4:	93 81       	ldd	r25, Z+3	; 0x03
    39d6:	e9 81       	ldd	r30, Y+1	; 0x01
    39d8:	fa 81       	ldd	r31, Y+2	; 0x02
    39da:	92 83       	std	Z+2, r25	; 0x02
    39dc:	81 83       	std	Z+1, r24	; 0x01
    39de:	e9 81       	ldd	r30, Y+1	; 0x01
    39e0:	fa 81       	ldd	r31, Y+2	; 0x02
    39e2:	01 80       	ldd	r0, Z+1	; 0x01
    39e4:	f2 81       	ldd	r31, Z+2	; 0x02
    39e6:	e0 2d       	mov	r30, r0
    39e8:	86 81       	ldd	r24, Z+6	; 0x06
    39ea:	97 81       	ldd	r25, Z+7	; 0x07
    39ec:	90 93 59 06 	sts	0x0659, r25
    39f0:	80 93 58 06 	sts	0x0658, r24
    39f4:	8b 81       	ldd	r24, Y+3	; 0x03
    39f6:	80 93 5e 06 	sts	0x065E, r24
			structure specific to this task. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
    39fa:	0f 90       	pop	r0
    39fc:	0f 90       	pop	r0
    39fe:	0f 90       	pop	r0
    3a00:	cf 91       	pop	r28
    3a02:	df 91       	pop	r29
    3a04:	08 95       	ret

00003a06 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
    3a06:	df 93       	push	r29
    3a08:	cf 93       	push	r28
    3a0a:	00 d0       	rcall	.+0      	; 0x3a0c <vTaskPlaceOnEventList+0x6>
    3a0c:	00 d0       	rcall	.+0      	; 0x3a0e <vTaskPlaceOnEventList+0x8>
    3a0e:	cd b7       	in	r28, 0x3d	; 61
    3a10:	de b7       	in	r29, 0x3e	; 62
    3a12:	9a 83       	std	Y+2, r25	; 0x02
    3a14:	89 83       	std	Y+1, r24	; 0x01
    3a16:	7c 83       	std	Y+4, r23	; 0x04
    3a18:	6b 83       	std	Y+3, r22	; 0x03

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    3a1a:	80 91 58 06 	lds	r24, 0x0658
    3a1e:	90 91 59 06 	lds	r25, 0x0659
    3a22:	9c 01       	movw	r18, r24
    3a24:	24 5f       	subi	r18, 0xF4	; 244
    3a26:	3f 4f       	sbci	r19, 0xFF	; 255
    3a28:	89 81       	ldd	r24, Y+1	; 0x01
    3a2a:	9a 81       	ldd	r25, Y+2	; 0x02
    3a2c:	b9 01       	movw	r22, r18
    3a2e:	0e 94 5c 07 	call	0xeb8	; 0xeb8 <vListInsert>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    3a32:	8b 81       	ldd	r24, Y+3	; 0x03
    3a34:	9c 81       	ldd	r25, Y+4	; 0x04
    3a36:	61 e0       	ldi	r22, 0x01	; 1
    3a38:	0e 94 67 23 	call	0x46ce	; 0x46ce <prvAddCurrentTaskToDelayedList>
}
    3a3c:	0f 90       	pop	r0
    3a3e:	0f 90       	pop	r0
    3a40:	0f 90       	pop	r0
    3a42:	0f 90       	pop	r0
    3a44:	cf 91       	pop	r28
    3a46:	df 91       	pop	r29
    3a48:	08 95       	ret

00003a4a <vTaskPlaceOnUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
{
    3a4a:	df 93       	push	r29
    3a4c:	cf 93       	push	r28
    3a4e:	00 d0       	rcall	.+0      	; 0x3a50 <vTaskPlaceOnUnorderedEventList+0x6>
    3a50:	00 d0       	rcall	.+0      	; 0x3a52 <vTaskPlaceOnUnorderedEventList+0x8>
    3a52:	00 d0       	rcall	.+0      	; 0x3a54 <vTaskPlaceOnUnorderedEventList+0xa>
    3a54:	cd b7       	in	r28, 0x3d	; 61
    3a56:	de b7       	in	r29, 0x3e	; 62
    3a58:	9a 83       	std	Y+2, r25	; 0x02
    3a5a:	89 83       	std	Y+1, r24	; 0x01
    3a5c:	7c 83       	std	Y+4, r23	; 0x04
    3a5e:	6b 83       	std	Y+3, r22	; 0x03
    3a60:	5e 83       	std	Y+6, r21	; 0x06
    3a62:	4d 83       	std	Y+5, r20	; 0x05
	configASSERT( uxSchedulerSuspended != 0 );

	/* Store the item value in the event list item.  It is safe to access the
	event list item here as interrupts won't access the event list item of a
	task that is not in the Blocked state. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    3a64:	e0 91 58 06 	lds	r30, 0x0658
    3a68:	f0 91 59 06 	lds	r31, 0x0659
    3a6c:	8b 81       	ldd	r24, Y+3	; 0x03
    3a6e:	9c 81       	ldd	r25, Y+4	; 0x04
    3a70:	90 68       	ori	r25, 0x80	; 128
    3a72:	95 87       	std	Z+13, r25	; 0x0d
    3a74:	84 87       	std	Z+12, r24	; 0x0c
	/* Place the event list item of the TCB at the end of the appropriate event
	list.  It is safe to access the event list here because it is part of an
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    3a76:	80 91 58 06 	lds	r24, 0x0658
    3a7a:	90 91 59 06 	lds	r25, 0x0659
    3a7e:	9c 01       	movw	r18, r24
    3a80:	24 5f       	subi	r18, 0xF4	; 244
    3a82:	3f 4f       	sbci	r19, 0xFF	; 255
    3a84:	89 81       	ldd	r24, Y+1	; 0x01
    3a86:	9a 81       	ldd	r25, Y+2	; 0x02
    3a88:	b9 01       	movw	r22, r18
    3a8a:	0e 94 18 07 	call	0xe30	; 0xe30 <vListInsertEnd>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    3a8e:	8d 81       	ldd	r24, Y+5	; 0x05
    3a90:	9e 81       	ldd	r25, Y+6	; 0x06
    3a92:	61 e0       	ldi	r22, 0x01	; 1
    3a94:	0e 94 67 23 	call	0x46ce	; 0x46ce <prvAddCurrentTaskToDelayedList>
}
    3a98:	26 96       	adiw	r28, 0x06	; 6
    3a9a:	0f b6       	in	r0, 0x3f	; 63
    3a9c:	f8 94       	cli
    3a9e:	de bf       	out	0x3e, r29	; 62
    3aa0:	0f be       	out	0x3f, r0	; 63
    3aa2:	cd bf       	out	0x3d, r28	; 61
    3aa4:	cf 91       	pop	r28
    3aa6:	df 91       	pop	r29
    3aa8:	08 95       	ret

00003aaa <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
    3aaa:	df 93       	push	r29
    3aac:	cf 93       	push	r28
    3aae:	00 d0       	rcall	.+0      	; 0x3ab0 <xTaskRemoveFromEventList+0x6>
    3ab0:	00 d0       	rcall	.+0      	; 0x3ab2 <xTaskRemoveFromEventList+0x8>
    3ab2:	0f 92       	push	r0
    3ab4:	cd b7       	in	r28, 0x3d	; 61
    3ab6:	de b7       	in	r29, 0x3e	; 62
    3ab8:	9d 83       	std	Y+5, r25	; 0x05
    3aba:	8c 83       	std	Y+4, r24	; 0x04
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    3abc:	ec 81       	ldd	r30, Y+4	; 0x04
    3abe:	fd 81       	ldd	r31, Y+5	; 0x05
    3ac0:	05 80       	ldd	r0, Z+5	; 0x05
    3ac2:	f6 81       	ldd	r31, Z+6	; 0x06
    3ac4:	e0 2d       	mov	r30, r0
    3ac6:	86 81       	ldd	r24, Z+6	; 0x06
    3ac8:	97 81       	ldd	r25, Z+7	; 0x07
    3aca:	9b 83       	std	Y+3, r25	; 0x03
    3acc:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    3ace:	8a 81       	ldd	r24, Y+2	; 0x02
    3ad0:	9b 81       	ldd	r25, Y+3	; 0x03
    3ad2:	0c 96       	adiw	r24, 0x0c	; 12
    3ad4:	0e 94 c8 07 	call	0xf90	; 0xf90 <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    3ad8:	80 91 68 06 	lds	r24, 0x0668
    3adc:	88 23       	and	r24, r24
    3ade:	61 f5       	brne	.+88     	; 0x3b38 <xTaskRemoveFromEventList+0x8e>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    3ae0:	8a 81       	ldd	r24, Y+2	; 0x02
    3ae2:	9b 81       	ldd	r25, Y+3	; 0x03
    3ae4:	02 96       	adiw	r24, 0x02	; 2
    3ae6:	0e 94 c8 07 	call	0xf90	; 0xf90 <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
    3aea:	ea 81       	ldd	r30, Y+2	; 0x02
    3aec:	fb 81       	ldd	r31, Y+3	; 0x03
    3aee:	96 89       	ldd	r25, Z+22	; 0x16
    3af0:	80 91 5e 06 	lds	r24, 0x065E
    3af4:	89 17       	cp	r24, r25
    3af6:	28 f4       	brcc	.+10     	; 0x3b02 <xTaskRemoveFromEventList+0x58>
    3af8:	ea 81       	ldd	r30, Y+2	; 0x02
    3afa:	fb 81       	ldd	r31, Y+3	; 0x03
    3afc:	86 89       	ldd	r24, Z+22	; 0x16
    3afe:	80 93 5e 06 	sts	0x065E, r24
    3b02:	ea 81       	ldd	r30, Y+2	; 0x02
    3b04:	fb 81       	ldd	r31, Y+3	; 0x03
    3b06:	86 89       	ldd	r24, Z+22	; 0x16
    3b08:	28 2f       	mov	r18, r24
    3b0a:	30 e0       	ldi	r19, 0x00	; 0
    3b0c:	c9 01       	movw	r24, r18
    3b0e:	88 0f       	add	r24, r24
    3b10:	99 1f       	adc	r25, r25
    3b12:	88 0f       	add	r24, r24
    3b14:	99 1f       	adc	r25, r25
    3b16:	88 0f       	add	r24, r24
    3b18:	99 1f       	adc	r25, r25
    3b1a:	82 0f       	add	r24, r18
    3b1c:	93 1f       	adc	r25, r19
    3b1e:	ac 01       	movw	r20, r24
    3b20:	47 59       	subi	r20, 0x97	; 151
    3b22:	59 4f       	sbci	r21, 0xF9	; 249
    3b24:	8a 81       	ldd	r24, Y+2	; 0x02
    3b26:	9b 81       	ldd	r25, Y+3	; 0x03
    3b28:	9c 01       	movw	r18, r24
    3b2a:	2e 5f       	subi	r18, 0xFE	; 254
    3b2c:	3f 4f       	sbci	r19, 0xFF	; 255
    3b2e:	ca 01       	movw	r24, r20
    3b30:	b9 01       	movw	r22, r18
    3b32:	0e 94 18 07 	call	0xe30	; 0xe30 <vListInsertEnd>
    3b36:	0a c0       	rjmp	.+20     	; 0x3b4c <xTaskRemoveFromEventList+0xa2>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    3b38:	8a 81       	ldd	r24, Y+2	; 0x02
    3b3a:	9b 81       	ldd	r25, Y+3	; 0x03
    3b3c:	9c 01       	movw	r18, r24
    3b3e:	24 5f       	subi	r18, 0xF4	; 244
    3b40:	3f 4f       	sbci	r19, 0xFF	; 255
    3b42:	83 ea       	ldi	r24, 0xA3	; 163
    3b44:	96 e0       	ldi	r25, 0x06	; 6
    3b46:	b9 01       	movw	r22, r18
    3b48:	0e 94 18 07 	call	0xe30	; 0xe30 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    3b4c:	ea 81       	ldd	r30, Y+2	; 0x02
    3b4e:	fb 81       	ldd	r31, Y+3	; 0x03
    3b50:	96 89       	ldd	r25, Z+22	; 0x16
    3b52:	e0 91 58 06 	lds	r30, 0x0658
    3b56:	f0 91 59 06 	lds	r31, 0x0659
    3b5a:	86 89       	ldd	r24, Z+22	; 0x16
    3b5c:	89 17       	cp	r24, r25
    3b5e:	30 f4       	brcc	.+12     	; 0x3b6c <xTaskRemoveFromEventList+0xc2>
	{
		/* Return true if the task removed from the event list has a higher
		priority than the calling task.  This allows the calling task to know if
		it should force a context switch now. */
		xReturn = pdTRUE;
    3b60:	81 e0       	ldi	r24, 0x01	; 1
    3b62:	89 83       	std	Y+1, r24	; 0x01

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    3b64:	81 e0       	ldi	r24, 0x01	; 1
    3b66:	80 93 61 06 	sts	0x0661, r24
    3b6a:	01 c0       	rjmp	.+2      	; 0x3b6e <xTaskRemoveFromEventList+0xc4>
	}
	else
	{
		xReturn = pdFALSE;
    3b6c:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    3b6e:	89 81       	ldd	r24, Y+1	; 0x01
}
    3b70:	0f 90       	pop	r0
    3b72:	0f 90       	pop	r0
    3b74:	0f 90       	pop	r0
    3b76:	0f 90       	pop	r0
    3b78:	0f 90       	pop	r0
    3b7a:	cf 91       	pop	r28
    3b7c:	df 91       	pop	r29
    3b7e:	08 95       	ret

00003b80 <vTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
{
    3b80:	df 93       	push	r29
    3b82:	cf 93       	push	r28
    3b84:	00 d0       	rcall	.+0      	; 0x3b86 <vTaskRemoveFromUnorderedEventList+0x6>
    3b86:	00 d0       	rcall	.+0      	; 0x3b88 <vTaskRemoveFromUnorderedEventList+0x8>
    3b88:	00 d0       	rcall	.+0      	; 0x3b8a <vTaskRemoveFromUnorderedEventList+0xa>
    3b8a:	cd b7       	in	r28, 0x3d	; 61
    3b8c:	de b7       	in	r29, 0x3e	; 62
    3b8e:	9c 83       	std	Y+4, r25	; 0x04
    3b90:	8b 83       	std	Y+3, r24	; 0x03
    3b92:	7e 83       	std	Y+6, r23	; 0x06
    3b94:	6d 83       	std	Y+5, r22	; 0x05
	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event flags implementation. */
	configASSERT( uxSchedulerSuspended != pdFALSE );

	/* Store the new item value in the event list. */
	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    3b96:	8d 81       	ldd	r24, Y+5	; 0x05
    3b98:	9e 81       	ldd	r25, Y+6	; 0x06
    3b9a:	90 68       	ori	r25, 0x80	; 128
    3b9c:	eb 81       	ldd	r30, Y+3	; 0x03
    3b9e:	fc 81       	ldd	r31, Y+4	; 0x04
    3ba0:	91 83       	std	Z+1, r25	; 0x01
    3ba2:	80 83       	st	Z, r24

	/* Remove the event list form the event flag.  Interrupts do not access
	event flags. */
	pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    3ba4:	eb 81       	ldd	r30, Y+3	; 0x03
    3ba6:	fc 81       	ldd	r31, Y+4	; 0x04
    3ba8:	86 81       	ldd	r24, Z+6	; 0x06
    3baa:	97 81       	ldd	r25, Z+7	; 0x07
    3bac:	9a 83       	std	Y+2, r25	; 0x02
    3bae:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( pxEventListItem );
    3bb0:	8b 81       	ldd	r24, Y+3	; 0x03
    3bb2:	9c 81       	ldd	r25, Y+4	; 0x04
    3bb4:	0e 94 c8 07 	call	0xf90	; 0xf90 <uxListRemove>

	/* Remove the task from the delayed list and add it to the ready list.  The
	scheduler is suspended so interrupts will not be accessing the ready
	lists. */
	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    3bb8:	89 81       	ldd	r24, Y+1	; 0x01
    3bba:	9a 81       	ldd	r25, Y+2	; 0x02
    3bbc:	02 96       	adiw	r24, 0x02	; 2
    3bbe:	0e 94 c8 07 	call	0xf90	; 0xf90 <uxListRemove>
	prvAddTaskToReadyList( pxUnblockedTCB );
    3bc2:	e9 81       	ldd	r30, Y+1	; 0x01
    3bc4:	fa 81       	ldd	r31, Y+2	; 0x02
    3bc6:	96 89       	ldd	r25, Z+22	; 0x16
    3bc8:	80 91 5e 06 	lds	r24, 0x065E
    3bcc:	89 17       	cp	r24, r25
    3bce:	28 f4       	brcc	.+10     	; 0x3bda <vTaskRemoveFromUnorderedEventList+0x5a>
    3bd0:	e9 81       	ldd	r30, Y+1	; 0x01
    3bd2:	fa 81       	ldd	r31, Y+2	; 0x02
    3bd4:	86 89       	ldd	r24, Z+22	; 0x16
    3bd6:	80 93 5e 06 	sts	0x065E, r24
    3bda:	e9 81       	ldd	r30, Y+1	; 0x01
    3bdc:	fa 81       	ldd	r31, Y+2	; 0x02
    3bde:	86 89       	ldd	r24, Z+22	; 0x16
    3be0:	28 2f       	mov	r18, r24
    3be2:	30 e0       	ldi	r19, 0x00	; 0
    3be4:	c9 01       	movw	r24, r18
    3be6:	88 0f       	add	r24, r24
    3be8:	99 1f       	adc	r25, r25
    3bea:	88 0f       	add	r24, r24
    3bec:	99 1f       	adc	r25, r25
    3bee:	88 0f       	add	r24, r24
    3bf0:	99 1f       	adc	r25, r25
    3bf2:	82 0f       	add	r24, r18
    3bf4:	93 1f       	adc	r25, r19
    3bf6:	ac 01       	movw	r20, r24
    3bf8:	47 59       	subi	r20, 0x97	; 151
    3bfa:	59 4f       	sbci	r21, 0xF9	; 249
    3bfc:	89 81       	ldd	r24, Y+1	; 0x01
    3bfe:	9a 81       	ldd	r25, Y+2	; 0x02
    3c00:	9c 01       	movw	r18, r24
    3c02:	2e 5f       	subi	r18, 0xFE	; 254
    3c04:	3f 4f       	sbci	r19, 0xFF	; 255
    3c06:	ca 01       	movw	r24, r20
    3c08:	b9 01       	movw	r22, r18
    3c0a:	0e 94 18 07 	call	0xe30	; 0xe30 <vListInsertEnd>

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    3c0e:	e9 81       	ldd	r30, Y+1	; 0x01
    3c10:	fa 81       	ldd	r31, Y+2	; 0x02
    3c12:	96 89       	ldd	r25, Z+22	; 0x16
    3c14:	e0 91 58 06 	lds	r30, 0x0658
    3c18:	f0 91 59 06 	lds	r31, 0x0659
    3c1c:	86 89       	ldd	r24, Z+22	; 0x16
    3c1e:	89 17       	cp	r24, r25
    3c20:	18 f4       	brcc	.+6      	; 0x3c28 <vTaskRemoveFromUnorderedEventList+0xa8>
	{
		/* The unblocked task has a priority above that of the calling task, so
		a context switch is required.  This function is called with the
		scheduler suspended so xYieldPending is set so the context switch
		occurs immediately that the scheduler is resumed (unsuspended). */
		xYieldPending = pdTRUE;
    3c22:	81 e0       	ldi	r24, 0x01	; 1
    3c24:	80 93 61 06 	sts	0x0661, r24
	}
}
    3c28:	26 96       	adiw	r28, 0x06	; 6
    3c2a:	0f b6       	in	r0, 0x3f	; 63
    3c2c:	f8 94       	cli
    3c2e:	de bf       	out	0x3e, r29	; 62
    3c30:	0f be       	out	0x3f, r0	; 63
    3c32:	cd bf       	out	0x3d, r28	; 61
    3c34:	cf 91       	pop	r28
    3c36:	df 91       	pop	r29
    3c38:	08 95       	ret

00003c3a <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    3c3a:	df 93       	push	r29
    3c3c:	cf 93       	push	r28
    3c3e:	00 d0       	rcall	.+0      	; 0x3c40 <vTaskSetTimeOutState+0x6>
    3c40:	cd b7       	in	r28, 0x3d	; 61
    3c42:	de b7       	in	r29, 0x3e	; 62
    3c44:	9a 83       	std	Y+2, r25	; 0x02
    3c46:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTimeOut );
	taskENTER_CRITICAL();
    3c48:	0f b6       	in	r0, 0x3f	; 63
    3c4a:	f8 94       	cli
    3c4c:	0f 92       	push	r0
	{
		pxTimeOut->xOverflowCount = xNumOfOverflows;
    3c4e:	80 91 62 06 	lds	r24, 0x0662
    3c52:	e9 81       	ldd	r30, Y+1	; 0x01
    3c54:	fa 81       	ldd	r31, Y+2	; 0x02
    3c56:	80 83       	st	Z, r24
		pxTimeOut->xTimeOnEntering = xTickCount;
    3c58:	80 91 5c 06 	lds	r24, 0x065C
    3c5c:	90 91 5d 06 	lds	r25, 0x065D
    3c60:	e9 81       	ldd	r30, Y+1	; 0x01
    3c62:	fa 81       	ldd	r31, Y+2	; 0x02
    3c64:	92 83       	std	Z+2, r25	; 0x02
    3c66:	81 83       	std	Z+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    3c68:	0f 90       	pop	r0
    3c6a:	0f be       	out	0x3f, r0	; 63
}
    3c6c:	0f 90       	pop	r0
    3c6e:	0f 90       	pop	r0
    3c70:	cf 91       	pop	r28
    3c72:	df 91       	pop	r29
    3c74:	08 95       	ret

00003c76 <vTaskInternalSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    3c76:	df 93       	push	r29
    3c78:	cf 93       	push	r28
    3c7a:	00 d0       	rcall	.+0      	; 0x3c7c <vTaskInternalSetTimeOutState+0x6>
    3c7c:	cd b7       	in	r28, 0x3d	; 61
    3c7e:	de b7       	in	r29, 0x3e	; 62
    3c80:	9a 83       	std	Y+2, r25	; 0x02
    3c82:	89 83       	std	Y+1, r24	; 0x01
	/* For internal use only as it does not use a critical section. */
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    3c84:	80 91 62 06 	lds	r24, 0x0662
    3c88:	e9 81       	ldd	r30, Y+1	; 0x01
    3c8a:	fa 81       	ldd	r31, Y+2	; 0x02
    3c8c:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    3c8e:	80 91 5c 06 	lds	r24, 0x065C
    3c92:	90 91 5d 06 	lds	r25, 0x065D
    3c96:	e9 81       	ldd	r30, Y+1	; 0x01
    3c98:	fa 81       	ldd	r31, Y+2	; 0x02
    3c9a:	92 83       	std	Z+2, r25	; 0x02
    3c9c:	81 83       	std	Z+1, r24	; 0x01
}
    3c9e:	0f 90       	pop	r0
    3ca0:	0f 90       	pop	r0
    3ca2:	cf 91       	pop	r28
    3ca4:	df 91       	pop	r29
    3ca6:	08 95       	ret

00003ca8 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
    3ca8:	df 93       	push	r29
    3caa:	cf 93       	push	r28
    3cac:	cd b7       	in	r28, 0x3d	; 61
    3cae:	de b7       	in	r29, 0x3e	; 62
    3cb0:	29 97       	sbiw	r28, 0x09	; 9
    3cb2:	0f b6       	in	r0, 0x3f	; 63
    3cb4:	f8 94       	cli
    3cb6:	de bf       	out	0x3e, r29	; 62
    3cb8:	0f be       	out	0x3f, r0	; 63
    3cba:	cd bf       	out	0x3d, r28	; 61
    3cbc:	9f 83       	std	Y+7, r25	; 0x07
    3cbe:	8e 83       	std	Y+6, r24	; 0x06
    3cc0:	79 87       	std	Y+9, r23	; 0x09
    3cc2:	68 87       	std	Y+8, r22	; 0x08
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    3cc4:	0f b6       	in	r0, 0x3f	; 63
    3cc6:	f8 94       	cli
    3cc8:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    3cca:	80 91 5c 06 	lds	r24, 0x065C
    3cce:	90 91 5d 06 	lds	r25, 0x065D
    3cd2:	9c 83       	std	Y+4, r25	; 0x04
    3cd4:	8b 83       	std	Y+3, r24	; 0x03
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    3cd6:	ee 81       	ldd	r30, Y+6	; 0x06
    3cd8:	ff 81       	ldd	r31, Y+7	; 0x07
    3cda:	21 81       	ldd	r18, Z+1	; 0x01
    3cdc:	32 81       	ldd	r19, Z+2	; 0x02
    3cde:	8b 81       	ldd	r24, Y+3	; 0x03
    3ce0:	9c 81       	ldd	r25, Y+4	; 0x04
    3ce2:	82 1b       	sub	r24, r18
    3ce4:	93 0b       	sbc	r25, r19
    3ce6:	9a 83       	std	Y+2, r25	; 0x02
    3ce8:	89 83       	std	Y+1, r24	; 0x01
			}
			else
		#endif

		#if ( INCLUDE_vTaskSuspend == 1 )
			if( *pxTicksToWait == portMAX_DELAY )
    3cea:	e8 85       	ldd	r30, Y+8	; 0x08
    3cec:	f9 85       	ldd	r31, Y+9	; 0x09
    3cee:	80 81       	ld	r24, Z
    3cf0:	91 81       	ldd	r25, Z+1	; 0x01
    3cf2:	2f ef       	ldi	r18, 0xFF	; 255
    3cf4:	8f 3f       	cpi	r24, 0xFF	; 255
    3cf6:	92 07       	cpc	r25, r18
    3cf8:	11 f4       	brne	.+4      	; 0x3cfe <xTaskCheckForTimeOut+0x56>
			{
				/* If INCLUDE_vTaskSuspend is set to 1 and the block time
				specified is the maximum block time then the task should block
				indefinitely, and therefore never time out. */
				xReturn = pdFALSE;
    3cfa:	1d 82       	std	Y+5, r1	; 0x05
    3cfc:	36 c0       	rjmp	.+108    	; 0x3d6a <xTaskCheckForTimeOut+0xc2>
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    3cfe:	ee 81       	ldd	r30, Y+6	; 0x06
    3d00:	ff 81       	ldd	r31, Y+7	; 0x07
    3d02:	90 81       	ld	r25, Z
    3d04:	80 91 62 06 	lds	r24, 0x0662
    3d08:	98 17       	cp	r25, r24
    3d0a:	61 f0       	breq	.+24     	; 0x3d24 <xTaskCheckForTimeOut+0x7c>
    3d0c:	ee 81       	ldd	r30, Y+6	; 0x06
    3d0e:	ff 81       	ldd	r31, Y+7	; 0x07
    3d10:	21 81       	ldd	r18, Z+1	; 0x01
    3d12:	32 81       	ldd	r19, Z+2	; 0x02
    3d14:	8b 81       	ldd	r24, Y+3	; 0x03
    3d16:	9c 81       	ldd	r25, Y+4	; 0x04
    3d18:	82 17       	cp	r24, r18
    3d1a:	93 07       	cpc	r25, r19
    3d1c:	18 f0       	brcs	.+6      	; 0x3d24 <xTaskCheckForTimeOut+0x7c>
			/* The tick count is greater than the time at which
			vTaskSetTimeout() was called, but has also overflowed since
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
    3d1e:	81 e0       	ldi	r24, 0x01	; 1
    3d20:	8d 83       	std	Y+5, r24	; 0x05
    3d22:	23 c0       	rjmp	.+70     	; 0x3d6a <xTaskCheckForTimeOut+0xc2>
		}
		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
    3d24:	e8 85       	ldd	r30, Y+8	; 0x08
    3d26:	f9 85       	ldd	r31, Y+9	; 0x09
    3d28:	20 81       	ld	r18, Z
    3d2a:	31 81       	ldd	r19, Z+1	; 0x01
    3d2c:	89 81       	ldd	r24, Y+1	; 0x01
    3d2e:	9a 81       	ldd	r25, Y+2	; 0x02
    3d30:	82 17       	cp	r24, r18
    3d32:	93 07       	cpc	r25, r19
    3d34:	a0 f4       	brcc	.+40     	; 0x3d5e <xTaskCheckForTimeOut+0xb6>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= xElapsedTime;
    3d36:	e8 85       	ldd	r30, Y+8	; 0x08
    3d38:	f9 85       	ldd	r31, Y+9	; 0x09
    3d3a:	20 81       	ld	r18, Z
    3d3c:	31 81       	ldd	r19, Z+1	; 0x01
    3d3e:	89 81       	ldd	r24, Y+1	; 0x01
    3d40:	9a 81       	ldd	r25, Y+2	; 0x02
    3d42:	a9 01       	movw	r20, r18
    3d44:	48 1b       	sub	r20, r24
    3d46:	59 0b       	sbc	r21, r25
    3d48:	ca 01       	movw	r24, r20
    3d4a:	e8 85       	ldd	r30, Y+8	; 0x08
    3d4c:	f9 85       	ldd	r31, Y+9	; 0x09
    3d4e:	91 83       	std	Z+1, r25	; 0x01
    3d50:	80 83       	st	Z, r24
			vTaskInternalSetTimeOutState( pxTimeOut );
    3d52:	8e 81       	ldd	r24, Y+6	; 0x06
    3d54:	9f 81       	ldd	r25, Y+7	; 0x07
    3d56:	0e 94 3b 1e 	call	0x3c76	; 0x3c76 <vTaskInternalSetTimeOutState>
			xReturn = pdFALSE;
    3d5a:	1d 82       	std	Y+5, r1	; 0x05
    3d5c:	06 c0       	rjmp	.+12     	; 0x3d6a <xTaskCheckForTimeOut+0xc2>
		}
		else
		{
			*pxTicksToWait = 0;
    3d5e:	e8 85       	ldd	r30, Y+8	; 0x08
    3d60:	f9 85       	ldd	r31, Y+9	; 0x09
    3d62:	11 82       	std	Z+1, r1	; 0x01
    3d64:	10 82       	st	Z, r1
			xReturn = pdTRUE;
    3d66:	81 e0       	ldi	r24, 0x01	; 1
    3d68:	8d 83       	std	Y+5, r24	; 0x05
		}
	}
	taskEXIT_CRITICAL();
    3d6a:	0f 90       	pop	r0
    3d6c:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    3d6e:	8d 81       	ldd	r24, Y+5	; 0x05
}
    3d70:	29 96       	adiw	r28, 0x09	; 9
    3d72:	0f b6       	in	r0, 0x3f	; 63
    3d74:	f8 94       	cli
    3d76:	de bf       	out	0x3e, r29	; 62
    3d78:	0f be       	out	0x3f, r0	; 63
    3d7a:	cd bf       	out	0x3d, r28	; 61
    3d7c:	cf 91       	pop	r28
    3d7e:	df 91       	pop	r29
    3d80:	08 95       	ret

00003d82 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    3d82:	df 93       	push	r29
    3d84:	cf 93       	push	r28
    3d86:	cd b7       	in	r28, 0x3d	; 61
    3d88:	de b7       	in	r29, 0x3e	; 62
	xYieldPending = pdTRUE;
    3d8a:	81 e0       	ldi	r24, 0x01	; 1
    3d8c:	80 93 61 06 	sts	0x0661, r24
}
    3d90:	cf 91       	pop	r28
    3d92:	df 91       	pop	r29
    3d94:	08 95       	ret

00003d96 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    3d96:	df 93       	push	r29
    3d98:	cf 93       	push	r28
    3d9a:	00 d0       	rcall	.+0      	; 0x3d9c <prvIdleTask+0x6>
    3d9c:	cd b7       	in	r28, 0x3d	; 61
    3d9e:	de b7       	in	r29, 0x3e	; 62
    3da0:	9a 83       	std	Y+2, r25	; 0x02
    3da2:	89 83       	std	Y+1, r24	; 0x01

	for( ;; )
	{
		/* See if any tasks have deleted themselves - if so then the idle task
		is responsible for freeing the deleted task's TCB and stack. */
		prvCheckTasksWaitingTermination();
    3da4:	0e 94 16 1f 	call	0x3e2c	; 0x3e2c <prvCheckTasksWaitingTermination>
    3da8:	fd cf       	rjmp	.-6      	; 0x3da4 <prvIdleTask+0xe>

00003daa <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
    3daa:	df 93       	push	r29
    3dac:	cf 93       	push	r28
    3dae:	0f 92       	push	r0
    3db0:	cd b7       	in	r28, 0x3d	; 61
    3db2:	de b7       	in	r29, 0x3e	; 62
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    3db4:	19 82       	std	Y+1, r1	; 0x01
    3db6:	13 c0       	rjmp	.+38     	; 0x3dde <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    3db8:	89 81       	ldd	r24, Y+1	; 0x01
    3dba:	28 2f       	mov	r18, r24
    3dbc:	30 e0       	ldi	r19, 0x00	; 0
    3dbe:	c9 01       	movw	r24, r18
    3dc0:	88 0f       	add	r24, r24
    3dc2:	99 1f       	adc	r25, r25
    3dc4:	88 0f       	add	r24, r24
    3dc6:	99 1f       	adc	r25, r25
    3dc8:	88 0f       	add	r24, r24
    3dca:	99 1f       	adc	r25, r25
    3dcc:	82 0f       	add	r24, r18
    3dce:	93 1f       	adc	r25, r19
    3dd0:	87 59       	subi	r24, 0x97	; 151
    3dd2:	99 4f       	sbci	r25, 0xF9	; 249
    3dd4:	0e 94 de 06 	call	0xdbc	; 0xdbc <vListInitialise>

static void prvInitialiseTaskLists( void )
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    3dd8:	89 81       	ldd	r24, Y+1	; 0x01
    3dda:	8f 5f       	subi	r24, 0xFF	; 255
    3ddc:	89 83       	std	Y+1, r24	; 0x01
    3dde:	89 81       	ldd	r24, Y+1	; 0x01
    3de0:	84 30       	cpi	r24, 0x04	; 4
    3de2:	50 f3       	brcs	.-44     	; 0x3db8 <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( &xDelayedTaskList1 );
    3de4:	8d e8       	ldi	r24, 0x8D	; 141
    3de6:	96 e0       	ldi	r25, 0x06	; 6
    3de8:	0e 94 de 06 	call	0xdbc	; 0xdbc <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
    3dec:	86 e9       	ldi	r24, 0x96	; 150
    3dee:	96 e0       	ldi	r25, 0x06	; 6
    3df0:	0e 94 de 06 	call	0xdbc	; 0xdbc <vListInitialise>
	vListInitialise( &xPendingReadyList );
    3df4:	83 ea       	ldi	r24, 0xA3	; 163
    3df6:	96 e0       	ldi	r25, 0x06	; 6
    3df8:	0e 94 de 06 	call	0xdbc	; 0xdbc <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
    3dfc:	8c ea       	ldi	r24, 0xAC	; 172
    3dfe:	96 e0       	ldi	r25, 0x06	; 6
    3e00:	0e 94 de 06 	call	0xdbc	; 0xdbc <vListInitialise>
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
    3e04:	85 eb       	ldi	r24, 0xB5	; 181
    3e06:	96 e0       	ldi	r25, 0x06	; 6
    3e08:	0e 94 de 06 	call	0xdbc	; 0xdbc <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    3e0c:	8d e8       	ldi	r24, 0x8D	; 141
    3e0e:	96 e0       	ldi	r25, 0x06	; 6
    3e10:	90 93 a0 06 	sts	0x06A0, r25
    3e14:	80 93 9f 06 	sts	0x069F, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    3e18:	86 e9       	ldi	r24, 0x96	; 150
    3e1a:	96 e0       	ldi	r25, 0x06	; 6
    3e1c:	90 93 a2 06 	sts	0x06A2, r25
    3e20:	80 93 a1 06 	sts	0x06A1, r24
}
    3e24:	0f 90       	pop	r0
    3e26:	cf 91       	pop	r28
    3e28:	df 91       	pop	r29
    3e2a:	08 95       	ret

00003e2c <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    3e2c:	df 93       	push	r29
    3e2e:	cf 93       	push	r28
    3e30:	00 d0       	rcall	.+0      	; 0x3e32 <prvCheckTasksWaitingTermination+0x6>
    3e32:	cd b7       	in	r28, 0x3d	; 61
    3e34:	de b7       	in	r29, 0x3e	; 62
    3e36:	20 c0       	rjmp	.+64     	; 0x3e78 <prvCheckTasksWaitingTermination+0x4c>

		/* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
		being called too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
		{
			taskENTER_CRITICAL();
    3e38:	0f b6       	in	r0, 0x3f	; 63
    3e3a:	f8 94       	cli
    3e3c:	0f 92       	push	r0
			{
				pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    3e3e:	e0 91 b1 06 	lds	r30, 0x06B1
    3e42:	f0 91 b2 06 	lds	r31, 0x06B2
    3e46:	86 81       	ldd	r24, Z+6	; 0x06
    3e48:	97 81       	ldd	r25, Z+7	; 0x07
    3e4a:	9a 83       	std	Y+2, r25	; 0x02
    3e4c:	89 83       	std	Y+1, r24	; 0x01
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    3e4e:	89 81       	ldd	r24, Y+1	; 0x01
    3e50:	9a 81       	ldd	r25, Y+2	; 0x02
    3e52:	02 96       	adiw	r24, 0x02	; 2
    3e54:	0e 94 c8 07 	call	0xf90	; 0xf90 <uxListRemove>
				--uxCurrentNumberOfTasks;
    3e58:	80 91 5b 06 	lds	r24, 0x065B
    3e5c:	81 50       	subi	r24, 0x01	; 1
    3e5e:	80 93 5b 06 	sts	0x065B, r24
				--uxDeletedTasksWaitingCleanUp;
    3e62:	80 91 5a 06 	lds	r24, 0x065A
    3e66:	81 50       	subi	r24, 0x01	; 1
    3e68:	80 93 5a 06 	sts	0x065A, r24
			}
			taskEXIT_CRITICAL();
    3e6c:	0f 90       	pop	r0
    3e6e:	0f be       	out	0x3f, r0	; 63

			prvDeleteTCB( pxTCB );
    3e70:	89 81       	ldd	r24, Y+1	; 0x01
    3e72:	9a 81       	ldd	r25, Y+2	; 0x02
    3e74:	0e 94 45 1f 	call	0x3e8a	; 0x3e8a <prvDeleteTCB>
	{
		TCB_t *pxTCB;

		/* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
		being called too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
    3e78:	80 91 5a 06 	lds	r24, 0x065A
    3e7c:	88 23       	and	r24, r24
    3e7e:	e1 f6       	brne	.-72     	; 0x3e38 <prvCheckTasksWaitingTermination+0xc>

			prvDeleteTCB( pxTCB );
		}
	}
	#endif /* INCLUDE_vTaskDelete */
}
    3e80:	0f 90       	pop	r0
    3e82:	0f 90       	pop	r0
    3e84:	cf 91       	pop	r28
    3e86:	df 91       	pop	r29
    3e88:	08 95       	ret

00003e8a <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( TCB_t *pxTCB )
	{
    3e8a:	df 93       	push	r29
    3e8c:	cf 93       	push	r28
    3e8e:	00 d0       	rcall	.+0      	; 0x3e90 <prvDeleteTCB+0x6>
    3e90:	cd b7       	in	r28, 0x3d	; 61
    3e92:	de b7       	in	r29, 0x3e	; 62
    3e94:	9a 83       	std	Y+2, r25	; 0x02
    3e96:	89 83       	std	Y+1, r24	; 0x01

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
		{
			/* The task can only have been allocated dynamically - free both
			the stack and TCB. */
			vPortFree( pxTCB->pxStack );
    3e98:	e9 81       	ldd	r30, Y+1	; 0x01
    3e9a:	fa 81       	ldd	r31, Y+2	; 0x02
    3e9c:	87 89       	ldd	r24, Z+23	; 0x17
    3e9e:	90 8d       	ldd	r25, Z+24	; 0x18
    3ea0:	0e 94 b8 06 	call	0xd70	; 0xd70 <vPortFree>
			vPortFree( pxTCB );
    3ea4:	89 81       	ldd	r24, Y+1	; 0x01
    3ea6:	9a 81       	ldd	r25, Y+2	; 0x02
    3ea8:	0e 94 b8 06 	call	0xd70	; 0xd70 <vPortFree>
				configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB	);
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
    3eac:	0f 90       	pop	r0
    3eae:	0f 90       	pop	r0
    3eb0:	cf 91       	pop	r28
    3eb2:	df 91       	pop	r29
    3eb4:	08 95       	ret

00003eb6 <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
    3eb6:	df 93       	push	r29
    3eb8:	cf 93       	push	r28
    3eba:	00 d0       	rcall	.+0      	; 0x3ebc <prvResetNextTaskUnblockTime+0x6>
    3ebc:	cd b7       	in	r28, 0x3d	; 61
    3ebe:	de b7       	in	r29, 0x3e	; 62
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    3ec0:	e0 91 9f 06 	lds	r30, 0x069F
    3ec4:	f0 91 a0 06 	lds	r31, 0x06A0
    3ec8:	80 81       	ld	r24, Z
    3eca:	88 23       	and	r24, r24
    3ecc:	39 f4       	brne	.+14     	; 0x3edc <prvResetNextTaskUnblockTime+0x26>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
    3ece:	8f ef       	ldi	r24, 0xFF	; 255
    3ed0:	9f ef       	ldi	r25, 0xFF	; 255
    3ed2:	90 93 65 06 	sts	0x0665, r25
    3ed6:	80 93 64 06 	sts	0x0664, r24
    3eda:	13 c0       	rjmp	.+38     	; 0x3f02 <prvResetNextTaskUnblockTime+0x4c>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    3edc:	e0 91 9f 06 	lds	r30, 0x069F
    3ee0:	f0 91 a0 06 	lds	r31, 0x06A0
    3ee4:	05 80       	ldd	r0, Z+5	; 0x05
    3ee6:	f6 81       	ldd	r31, Z+6	; 0x06
    3ee8:	e0 2d       	mov	r30, r0
    3eea:	86 81       	ldd	r24, Z+6	; 0x06
    3eec:	97 81       	ldd	r25, Z+7	; 0x07
    3eee:	9a 83       	std	Y+2, r25	; 0x02
    3ef0:	89 83       	std	Y+1, r24	; 0x01
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
    3ef2:	e9 81       	ldd	r30, Y+1	; 0x01
    3ef4:	fa 81       	ldd	r31, Y+2	; 0x02
    3ef6:	82 81       	ldd	r24, Z+2	; 0x02
    3ef8:	93 81       	ldd	r25, Z+3	; 0x03
    3efa:	90 93 65 06 	sts	0x0665, r25
    3efe:	80 93 64 06 	sts	0x0664, r24
	}
}
    3f02:	0f 90       	pop	r0
    3f04:	0f 90       	pop	r0
    3f06:	cf 91       	pop	r28
    3f08:	df 91       	pop	r29
    3f0a:	08 95       	ret

00003f0c <xTaskGetCurrentTaskHandle>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )

	TaskHandle_t xTaskGetCurrentTaskHandle( void )
	{
    3f0c:	df 93       	push	r29
    3f0e:	cf 93       	push	r28
    3f10:	00 d0       	rcall	.+0      	; 0x3f12 <xTaskGetCurrentTaskHandle+0x6>
    3f12:	cd b7       	in	r28, 0x3d	; 61
    3f14:	de b7       	in	r29, 0x3e	; 62
	TaskHandle_t xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
    3f16:	80 91 58 06 	lds	r24, 0x0658
    3f1a:	90 91 59 06 	lds	r25, 0x0659
    3f1e:	9a 83       	std	Y+2, r25	; 0x02
    3f20:	89 83       	std	Y+1, r24	; 0x01

		return xReturn;
    3f22:	89 81       	ldd	r24, Y+1	; 0x01
    3f24:	9a 81       	ldd	r25, Y+2	; 0x02
	}
    3f26:	0f 90       	pop	r0
    3f28:	0f 90       	pop	r0
    3f2a:	cf 91       	pop	r28
    3f2c:	df 91       	pop	r29
    3f2e:	08 95       	ret

00003f30 <uxTaskResetEventItemValue>:

#endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

TickType_t uxTaskResetEventItemValue( void )
{
    3f30:	df 93       	push	r29
    3f32:	cf 93       	push	r28
    3f34:	00 d0       	rcall	.+0      	; 0x3f36 <uxTaskResetEventItemValue+0x6>
    3f36:	cd b7       	in	r28, 0x3d	; 61
    3f38:	de b7       	in	r29, 0x3e	; 62
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    3f3a:	e0 91 58 06 	lds	r30, 0x0658
    3f3e:	f0 91 59 06 	lds	r31, 0x0659
    3f42:	84 85       	ldd	r24, Z+12	; 0x0c
    3f44:	95 85       	ldd	r25, Z+13	; 0x0d
    3f46:	9a 83       	std	Y+2, r25	; 0x02
    3f48:	89 83       	std	Y+1, r24	; 0x01

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    3f4a:	a0 91 58 06 	lds	r26, 0x0658
    3f4e:	b0 91 59 06 	lds	r27, 0x0659
    3f52:	e0 91 58 06 	lds	r30, 0x0658
    3f56:	f0 91 59 06 	lds	r31, 0x0659
    3f5a:	86 89       	ldd	r24, Z+22	; 0x16
    3f5c:	28 2f       	mov	r18, r24
    3f5e:	30 e0       	ldi	r19, 0x00	; 0
    3f60:	84 e0       	ldi	r24, 0x04	; 4
    3f62:	90 e0       	ldi	r25, 0x00	; 0
    3f64:	82 1b       	sub	r24, r18
    3f66:	93 0b       	sbc	r25, r19
    3f68:	1d 96       	adiw	r26, 0x0d	; 13
    3f6a:	9c 93       	st	X, r25
    3f6c:	8e 93       	st	-X, r24
    3f6e:	1c 97       	sbiw	r26, 0x0c	; 12

	return uxReturn;
    3f70:	89 81       	ldd	r24, Y+1	; 0x01
    3f72:	9a 81       	ldd	r25, Y+2	; 0x02
}
    3f74:	0f 90       	pop	r0
    3f76:	0f 90       	pop	r0
    3f78:	cf 91       	pop	r28
    3f7a:	df 91       	pop	r29
    3f7c:	08 95       	ret

00003f7e <ulTaskNotifyTake>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
	{
    3f7e:	df 93       	push	r29
    3f80:	cf 93       	push	r28
    3f82:	cd b7       	in	r28, 0x3d	; 61
    3f84:	de b7       	in	r29, 0x3e	; 62
    3f86:	27 97       	sbiw	r28, 0x07	; 7
    3f88:	0f b6       	in	r0, 0x3f	; 63
    3f8a:	f8 94       	cli
    3f8c:	de bf       	out	0x3e, r29	; 62
    3f8e:	0f be       	out	0x3f, r0	; 63
    3f90:	cd bf       	out	0x3d, r28	; 61
    3f92:	8d 83       	std	Y+5, r24	; 0x05
    3f94:	7f 83       	std	Y+7, r23	; 0x07
    3f96:	6e 83       	std	Y+6, r22	; 0x06
	uint32_t ulReturn;

		taskENTER_CRITICAL();
    3f98:	0f b6       	in	r0, 0x3f	; 63
    3f9a:	f8 94       	cli
    3f9c:	0f 92       	push	r0
		{
			/* Only block if the notification count is not already non-zero. */
			if( pxCurrentTCB->ulNotifiedValue == 0UL )
    3f9e:	e0 91 58 06 	lds	r30, 0x0658
    3fa2:	f0 91 59 06 	lds	r31, 0x0659
    3fa6:	83 a1       	ldd	r24, Z+35	; 0x23
    3fa8:	94 a1       	ldd	r25, Z+36	; 0x24
    3faa:	a5 a1       	ldd	r26, Z+37	; 0x25
    3fac:	b6 a1       	ldd	r27, Z+38	; 0x26
    3fae:	00 97       	sbiw	r24, 0x00	; 0
    3fb0:	a1 05       	cpc	r26, r1
    3fb2:	b1 05       	cpc	r27, r1
    3fb4:	89 f4       	brne	.+34     	; 0x3fd8 <ulTaskNotifyTake+0x5a>
			{
				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    3fb6:	e0 91 58 06 	lds	r30, 0x0658
    3fba:	f0 91 59 06 	lds	r31, 0x0659
    3fbe:	81 e0       	ldi	r24, 0x01	; 1
    3fc0:	87 a3       	std	Z+39, r24	; 0x27

				if( xTicksToWait > ( TickType_t ) 0 )
    3fc2:	8e 81       	ldd	r24, Y+6	; 0x06
    3fc4:	9f 81       	ldd	r25, Y+7	; 0x07
    3fc6:	00 97       	sbiw	r24, 0x00	; 0
    3fc8:	39 f0       	breq	.+14     	; 0x3fd8 <ulTaskNotifyTake+0x5a>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    3fca:	8e 81       	ldd	r24, Y+6	; 0x06
    3fcc:	9f 81       	ldd	r25, Y+7	; 0x07
    3fce:	61 e0       	ldi	r22, 0x01	; 1
    3fd0:	0e 94 67 23 	call	0x46ce	; 0x46ce <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    3fd4:	0e 94 08 02 	call	0x410	; 0x410 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    3fd8:	0f 90       	pop	r0
    3fda:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    3fdc:	0f b6       	in	r0, 0x3f	; 63
    3fde:	f8 94       	cli
    3fe0:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_TAKE();
			ulReturn = pxCurrentTCB->ulNotifiedValue;
    3fe2:	e0 91 58 06 	lds	r30, 0x0658
    3fe6:	f0 91 59 06 	lds	r31, 0x0659
    3fea:	83 a1       	ldd	r24, Z+35	; 0x23
    3fec:	94 a1       	ldd	r25, Z+36	; 0x24
    3fee:	a5 a1       	ldd	r26, Z+37	; 0x25
    3ff0:	b6 a1       	ldd	r27, Z+38	; 0x26
    3ff2:	89 83       	std	Y+1, r24	; 0x01
    3ff4:	9a 83       	std	Y+2, r25	; 0x02
    3ff6:	ab 83       	std	Y+3, r26	; 0x03
    3ff8:	bc 83       	std	Y+4, r27	; 0x04

			if( ulReturn != 0UL )
    3ffa:	89 81       	ldd	r24, Y+1	; 0x01
    3ffc:	9a 81       	ldd	r25, Y+2	; 0x02
    3ffe:	ab 81       	ldd	r26, Y+3	; 0x03
    4000:	bc 81       	ldd	r27, Y+4	; 0x04
    4002:	00 97       	sbiw	r24, 0x00	; 0
    4004:	a1 05       	cpc	r26, r1
    4006:	b1 05       	cpc	r27, r1
    4008:	d9 f0       	breq	.+54     	; 0x4040 <ulTaskNotifyTake+0xc2>
			{
				if( xClearCountOnExit != pdFALSE )
    400a:	8d 81       	ldd	r24, Y+5	; 0x05
    400c:	88 23       	and	r24, r24
    400e:	49 f0       	breq	.+18     	; 0x4022 <ulTaskNotifyTake+0xa4>
				{
					pxCurrentTCB->ulNotifiedValue = 0UL;
    4010:	e0 91 58 06 	lds	r30, 0x0658
    4014:	f0 91 59 06 	lds	r31, 0x0659
    4018:	13 a2       	std	Z+35, r1	; 0x23
    401a:	14 a2       	std	Z+36, r1	; 0x24
    401c:	15 a2       	std	Z+37, r1	; 0x25
    401e:	16 a2       	std	Z+38, r1	; 0x26
    4020:	0f c0       	rjmp	.+30     	; 0x4040 <ulTaskNotifyTake+0xc2>
				}
				else
				{
					pxCurrentTCB->ulNotifiedValue = ulReturn - ( uint32_t ) 1;
    4022:	e0 91 58 06 	lds	r30, 0x0658
    4026:	f0 91 59 06 	lds	r31, 0x0659
    402a:	89 81       	ldd	r24, Y+1	; 0x01
    402c:	9a 81       	ldd	r25, Y+2	; 0x02
    402e:	ab 81       	ldd	r26, Y+3	; 0x03
    4030:	bc 81       	ldd	r27, Y+4	; 0x04
    4032:	01 97       	sbiw	r24, 0x01	; 1
    4034:	a1 09       	sbc	r26, r1
    4036:	b1 09       	sbc	r27, r1
    4038:	83 a3       	std	Z+35, r24	; 0x23
    403a:	94 a3       	std	Z+36, r25	; 0x24
    403c:	a5 a3       	std	Z+37, r26	; 0x25
    403e:	b6 a3       	std	Z+38, r27	; 0x26
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    4040:	e0 91 58 06 	lds	r30, 0x0658
    4044:	f0 91 59 06 	lds	r31, 0x0659
    4048:	17 a2       	std	Z+39, r1	; 0x27
		}
		taskEXIT_CRITICAL();
    404a:	0f 90       	pop	r0
    404c:	0f be       	out	0x3f, r0	; 63

		return ulReturn;
    404e:	89 81       	ldd	r24, Y+1	; 0x01
    4050:	9a 81       	ldd	r25, Y+2	; 0x02
    4052:	ab 81       	ldd	r26, Y+3	; 0x03
    4054:	bc 81       	ldd	r27, Y+4	; 0x04
	}
    4056:	bc 01       	movw	r22, r24
    4058:	cd 01       	movw	r24, r26
    405a:	27 96       	adiw	r28, 0x07	; 7
    405c:	0f b6       	in	r0, 0x3f	; 63
    405e:	f8 94       	cli
    4060:	de bf       	out	0x3e, r29	; 62
    4062:	0f be       	out	0x3f, r0	; 63
    4064:	cd bf       	out	0x3d, r28	; 61
    4066:	cf 91       	pop	r28
    4068:	df 91       	pop	r29
    406a:	08 95       	ret

0000406c <xTaskNotifyWait>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
	{
    406c:	ef 92       	push	r14
    406e:	ff 92       	push	r15
    4070:	0f 93       	push	r16
    4072:	1f 93       	push	r17
    4074:	df 93       	push	r29
    4076:	cf 93       	push	r28
    4078:	cd b7       	in	r28, 0x3d	; 61
    407a:	de b7       	in	r29, 0x3e	; 62
    407c:	2d 97       	sbiw	r28, 0x0d	; 13
    407e:	0f b6       	in	r0, 0x3f	; 63
    4080:	f8 94       	cli
    4082:	de bf       	out	0x3e, r29	; 62
    4084:	0f be       	out	0x3f, r0	; 63
    4086:	cd bf       	out	0x3d, r28	; 61
    4088:	6a 83       	std	Y+2, r22	; 0x02
    408a:	7b 83       	std	Y+3, r23	; 0x03
    408c:	8c 83       	std	Y+4, r24	; 0x04
    408e:	9d 83       	std	Y+5, r25	; 0x05
    4090:	2e 83       	std	Y+6, r18	; 0x06
    4092:	3f 83       	std	Y+7, r19	; 0x07
    4094:	48 87       	std	Y+8, r20	; 0x08
    4096:	59 87       	std	Y+9, r21	; 0x09
    4098:	1b 87       	std	Y+11, r17	; 0x0b
    409a:	0a 87       	std	Y+10, r16	; 0x0a
    409c:	fd 86       	std	Y+13, r15	; 0x0d
    409e:	ec 86       	std	Y+12, r14	; 0x0c
	BaseType_t xReturn;

		taskENTER_CRITICAL();
    40a0:	0f b6       	in	r0, 0x3f	; 63
    40a2:	f8 94       	cli
    40a4:	0f 92       	push	r0
		{
			/* Only block if a notification is not already pending. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
    40a6:	e0 91 58 06 	lds	r30, 0x0658
    40aa:	f0 91 59 06 	lds	r31, 0x0659
    40ae:	87 a1       	ldd	r24, Z+39	; 0x27
    40b0:	82 30       	cpi	r24, 0x02	; 2
    40b2:	49 f1       	breq	.+82     	; 0x4106 <xTaskNotifyWait+0x9a>
			{
				/* Clear bits in the task's notification value as bits may get
				set	by the notifying task or interrupt.  This can be used to
				clear the value to zero. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
    40b4:	e0 91 58 06 	lds	r30, 0x0658
    40b8:	f0 91 59 06 	lds	r31, 0x0659
    40bc:	23 a1       	ldd	r18, Z+35	; 0x23
    40be:	34 a1       	ldd	r19, Z+36	; 0x24
    40c0:	45 a1       	ldd	r20, Z+37	; 0x25
    40c2:	56 a1       	ldd	r21, Z+38	; 0x26
    40c4:	8a 81       	ldd	r24, Y+2	; 0x02
    40c6:	9b 81       	ldd	r25, Y+3	; 0x03
    40c8:	ac 81       	ldd	r26, Y+4	; 0x04
    40ca:	bd 81       	ldd	r27, Y+5	; 0x05
    40cc:	80 95       	com	r24
    40ce:	90 95       	com	r25
    40d0:	a0 95       	com	r26
    40d2:	b0 95       	com	r27
    40d4:	82 23       	and	r24, r18
    40d6:	93 23       	and	r25, r19
    40d8:	a4 23       	and	r26, r20
    40da:	b5 23       	and	r27, r21
    40dc:	83 a3       	std	Z+35, r24	; 0x23
    40de:	94 a3       	std	Z+36, r25	; 0x24
    40e0:	a5 a3       	std	Z+37, r26	; 0x25
    40e2:	b6 a3       	std	Z+38, r27	; 0x26

				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    40e4:	e0 91 58 06 	lds	r30, 0x0658
    40e8:	f0 91 59 06 	lds	r31, 0x0659
    40ec:	81 e0       	ldi	r24, 0x01	; 1
    40ee:	87 a3       	std	Z+39, r24	; 0x27

				if( xTicksToWait > ( TickType_t ) 0 )
    40f0:	8c 85       	ldd	r24, Y+12	; 0x0c
    40f2:	9d 85       	ldd	r25, Y+13	; 0x0d
    40f4:	00 97       	sbiw	r24, 0x00	; 0
    40f6:	39 f0       	breq	.+14     	; 0x4106 <xTaskNotifyWait+0x9a>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    40f8:	8c 85       	ldd	r24, Y+12	; 0x0c
    40fa:	9d 85       	ldd	r25, Y+13	; 0x0d
    40fc:	61 e0       	ldi	r22, 0x01	; 1
    40fe:	0e 94 67 23 	call	0x46ce	; 0x46ce <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    4102:	0e 94 08 02 	call	0x410	; 0x410 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    4106:	0f 90       	pop	r0
    4108:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    410a:	0f b6       	in	r0, 0x3f	; 63
    410c:	f8 94       	cli
    410e:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_WAIT();

			if( pulNotificationValue != NULL )
    4110:	8a 85       	ldd	r24, Y+10	; 0x0a
    4112:	9b 85       	ldd	r25, Y+11	; 0x0b
    4114:	00 97       	sbiw	r24, 0x00	; 0
    4116:	71 f0       	breq	.+28     	; 0x4134 <xTaskNotifyWait+0xc8>
			{
				/* Output the current notification value, which may or may not
				have changed. */
				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
    4118:	e0 91 58 06 	lds	r30, 0x0658
    411c:	f0 91 59 06 	lds	r31, 0x0659
    4120:	83 a1       	ldd	r24, Z+35	; 0x23
    4122:	94 a1       	ldd	r25, Z+36	; 0x24
    4124:	a5 a1       	ldd	r26, Z+37	; 0x25
    4126:	b6 a1       	ldd	r27, Z+38	; 0x26
    4128:	ea 85       	ldd	r30, Y+10	; 0x0a
    412a:	fb 85       	ldd	r31, Y+11	; 0x0b
    412c:	80 83       	st	Z, r24
    412e:	91 83       	std	Z+1, r25	; 0x01
    4130:	a2 83       	std	Z+2, r26	; 0x02
    4132:	b3 83       	std	Z+3, r27	; 0x03

			/* If ucNotifyValue is set then either the task never entered the
			blocked state (because a notification was already pending) or the
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
    4134:	e0 91 58 06 	lds	r30, 0x0658
    4138:	f0 91 59 06 	lds	r31, 0x0659
    413c:	87 a1       	ldd	r24, Z+39	; 0x27
    413e:	82 30       	cpi	r24, 0x02	; 2
    4140:	11 f0       	breq	.+4      	; 0x4146 <xTaskNotifyWait+0xda>
			{
				/* A notification was not received. */
				xReturn = pdFALSE;
    4142:	19 82       	std	Y+1, r1	; 0x01
    4144:	1a c0       	rjmp	.+52     	; 0x417a <xTaskNotifyWait+0x10e>
			}
			else
			{
				/* A notification was already pending or a notification was
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
    4146:	e0 91 58 06 	lds	r30, 0x0658
    414a:	f0 91 59 06 	lds	r31, 0x0659
    414e:	23 a1       	ldd	r18, Z+35	; 0x23
    4150:	34 a1       	ldd	r19, Z+36	; 0x24
    4152:	45 a1       	ldd	r20, Z+37	; 0x25
    4154:	56 a1       	ldd	r21, Z+38	; 0x26
    4156:	8e 81       	ldd	r24, Y+6	; 0x06
    4158:	9f 81       	ldd	r25, Y+7	; 0x07
    415a:	a8 85       	ldd	r26, Y+8	; 0x08
    415c:	b9 85       	ldd	r27, Y+9	; 0x09
    415e:	80 95       	com	r24
    4160:	90 95       	com	r25
    4162:	a0 95       	com	r26
    4164:	b0 95       	com	r27
    4166:	82 23       	and	r24, r18
    4168:	93 23       	and	r25, r19
    416a:	a4 23       	and	r26, r20
    416c:	b5 23       	and	r27, r21
    416e:	83 a3       	std	Z+35, r24	; 0x23
    4170:	94 a3       	std	Z+36, r25	; 0x24
    4172:	a5 a3       	std	Z+37, r26	; 0x25
    4174:	b6 a3       	std	Z+38, r27	; 0x26
				xReturn = pdTRUE;
    4176:	81 e0       	ldi	r24, 0x01	; 1
    4178:	89 83       	std	Y+1, r24	; 0x01
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    417a:	e0 91 58 06 	lds	r30, 0x0658
    417e:	f0 91 59 06 	lds	r31, 0x0659
    4182:	17 a2       	std	Z+39, r1	; 0x27
		}
		taskEXIT_CRITICAL();
    4184:	0f 90       	pop	r0
    4186:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    4188:	89 81       	ldd	r24, Y+1	; 0x01
	}
    418a:	2d 96       	adiw	r28, 0x0d	; 13
    418c:	0f b6       	in	r0, 0x3f	; 63
    418e:	f8 94       	cli
    4190:	de bf       	out	0x3e, r29	; 62
    4192:	0f be       	out	0x3f, r0	; 63
    4194:	cd bf       	out	0x3d, r28	; 61
    4196:	cf 91       	pop	r28
    4198:	df 91       	pop	r29
    419a:	1f 91       	pop	r17
    419c:	0f 91       	pop	r16
    419e:	ff 90       	pop	r15
    41a0:	ef 90       	pop	r14
    41a2:	08 95       	ret

000041a4 <xTaskGenericNotify>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
	{
    41a4:	0f 93       	push	r16
    41a6:	1f 93       	push	r17
    41a8:	df 93       	push	r29
    41aa:	cf 93       	push	r28
    41ac:	cd b7       	in	r28, 0x3d	; 61
    41ae:	de b7       	in	r29, 0x3e	; 62
    41b0:	2f 97       	sbiw	r28, 0x0f	; 15
    41b2:	0f b6       	in	r0, 0x3f	; 63
    41b4:	f8 94       	cli
    41b6:	de bf       	out	0x3e, r29	; 62
    41b8:	0f be       	out	0x3f, r0	; 63
    41ba:	cd bf       	out	0x3d, r28	; 61
    41bc:	9e 83       	std	Y+6, r25	; 0x06
    41be:	8d 83       	std	Y+5, r24	; 0x05
    41c0:	4f 83       	std	Y+7, r20	; 0x07
    41c2:	58 87       	std	Y+8, r21	; 0x08
    41c4:	69 87       	std	Y+9, r22	; 0x09
    41c6:	7a 87       	std	Y+10, r23	; 0x0a
    41c8:	2b 87       	std	Y+11, r18	; 0x0b
    41ca:	1d 87       	std	Y+13, r17	; 0x0d
    41cc:	0c 87       	std	Y+12, r16	; 0x0c
	TCB_t * pxTCB;
	BaseType_t xReturn = pdPASS;
    41ce:	81 e0       	ldi	r24, 0x01	; 1
    41d0:	8a 83       	std	Y+2, r24	; 0x02
	uint8_t ucOriginalNotifyState;

		configASSERT( xTaskToNotify );
		pxTCB = xTaskToNotify;
    41d2:	8d 81       	ldd	r24, Y+5	; 0x05
    41d4:	9e 81       	ldd	r25, Y+6	; 0x06
    41d6:	9c 83       	std	Y+4, r25	; 0x04
    41d8:	8b 83       	std	Y+3, r24	; 0x03

		taskENTER_CRITICAL();
    41da:	0f b6       	in	r0, 0x3f	; 63
    41dc:	f8 94       	cli
    41de:	0f 92       	push	r0
		{
			if( pulPreviousNotificationValue != NULL )
    41e0:	8c 85       	ldd	r24, Y+12	; 0x0c
    41e2:	9d 85       	ldd	r25, Y+13	; 0x0d
    41e4:	00 97       	sbiw	r24, 0x00	; 0
    41e6:	61 f0       	breq	.+24     	; 0x4200 <xTaskGenericNotify+0x5c>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    41e8:	eb 81       	ldd	r30, Y+3	; 0x03
    41ea:	fc 81       	ldd	r31, Y+4	; 0x04
    41ec:	83 a1       	ldd	r24, Z+35	; 0x23
    41ee:	94 a1       	ldd	r25, Z+36	; 0x24
    41f0:	a5 a1       	ldd	r26, Z+37	; 0x25
    41f2:	b6 a1       	ldd	r27, Z+38	; 0x26
    41f4:	ec 85       	ldd	r30, Y+12	; 0x0c
    41f6:	fd 85       	ldd	r31, Y+13	; 0x0d
    41f8:	80 83       	st	Z, r24
    41fa:	91 83       	std	Z+1, r25	; 0x01
    41fc:	a2 83       	std	Z+2, r26	; 0x02
    41fe:	b3 83       	std	Z+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    4200:	eb 81       	ldd	r30, Y+3	; 0x03
    4202:	fc 81       	ldd	r31, Y+4	; 0x04
    4204:	87 a1       	ldd	r24, Z+39	; 0x27
    4206:	89 83       	std	Y+1, r24	; 0x01

			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    4208:	eb 81       	ldd	r30, Y+3	; 0x03
    420a:	fc 81       	ldd	r31, Y+4	; 0x04
    420c:	82 e0       	ldi	r24, 0x02	; 2
    420e:	87 a3       	std	Z+39, r24	; 0x27

			switch( eAction )
    4210:	8b 85       	ldd	r24, Y+11	; 0x0b
    4212:	28 2f       	mov	r18, r24
    4214:	30 e0       	ldi	r19, 0x00	; 0
    4216:	3f 87       	std	Y+15, r19	; 0x0f
    4218:	2e 87       	std	Y+14, r18	; 0x0e
    421a:	8e 85       	ldd	r24, Y+14	; 0x0e
    421c:	9f 85       	ldd	r25, Y+15	; 0x0f
    421e:	82 30       	cpi	r24, 0x02	; 2
    4220:	91 05       	cpc	r25, r1
    4222:	59 f1       	breq	.+86     	; 0x427a <xTaskGenericNotify+0xd6>
    4224:	2e 85       	ldd	r18, Y+14	; 0x0e
    4226:	3f 85       	ldd	r19, Y+15	; 0x0f
    4228:	23 30       	cpi	r18, 0x03	; 3
    422a:	31 05       	cpc	r19, r1
    422c:	34 f4       	brge	.+12     	; 0x423a <xTaskGenericNotify+0x96>
    422e:	8e 85       	ldd	r24, Y+14	; 0x0e
    4230:	9f 85       	ldd	r25, Y+15	; 0x0f
    4232:	81 30       	cpi	r24, 0x01	; 1
    4234:	91 05       	cpc	r25, r1
    4236:	61 f0       	breq	.+24     	; 0x4250 <xTaskGenericNotify+0xac>
    4238:	4a c0       	rjmp	.+148    	; 0x42ce <xTaskGenericNotify+0x12a>
    423a:	2e 85       	ldd	r18, Y+14	; 0x0e
    423c:	3f 85       	ldd	r19, Y+15	; 0x0f
    423e:	23 30       	cpi	r18, 0x03	; 3
    4240:	31 05       	cpc	r19, r1
    4242:	59 f1       	breq	.+86     	; 0x429a <xTaskGenericNotify+0xf6>
    4244:	8e 85       	ldd	r24, Y+14	; 0x0e
    4246:	9f 85       	ldd	r25, Y+15	; 0x0f
    4248:	84 30       	cpi	r24, 0x04	; 4
    424a:	91 05       	cpc	r25, r1
    424c:	89 f1       	breq	.+98     	; 0x42b0 <xTaskGenericNotify+0x10c>
    424e:	3f c0       	rjmp	.+126    	; 0x42ce <xTaskGenericNotify+0x12a>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    4250:	eb 81       	ldd	r30, Y+3	; 0x03
    4252:	fc 81       	ldd	r31, Y+4	; 0x04
    4254:	23 a1       	ldd	r18, Z+35	; 0x23
    4256:	34 a1       	ldd	r19, Z+36	; 0x24
    4258:	45 a1       	ldd	r20, Z+37	; 0x25
    425a:	56 a1       	ldd	r21, Z+38	; 0x26
    425c:	8f 81       	ldd	r24, Y+7	; 0x07
    425e:	98 85       	ldd	r25, Y+8	; 0x08
    4260:	a9 85       	ldd	r26, Y+9	; 0x09
    4262:	ba 85       	ldd	r27, Y+10	; 0x0a
    4264:	82 2b       	or	r24, r18
    4266:	93 2b       	or	r25, r19
    4268:	a4 2b       	or	r26, r20
    426a:	b5 2b       	or	r27, r21
    426c:	eb 81       	ldd	r30, Y+3	; 0x03
    426e:	fc 81       	ldd	r31, Y+4	; 0x04
    4270:	83 a3       	std	Z+35, r24	; 0x23
    4272:	94 a3       	std	Z+36, r25	; 0x24
    4274:	a5 a3       	std	Z+37, r26	; 0x25
    4276:	b6 a3       	std	Z+38, r27	; 0x26
    4278:	2a c0       	rjmp	.+84     	; 0x42ce <xTaskGenericNotify+0x12a>
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    427a:	eb 81       	ldd	r30, Y+3	; 0x03
    427c:	fc 81       	ldd	r31, Y+4	; 0x04
    427e:	83 a1       	ldd	r24, Z+35	; 0x23
    4280:	94 a1       	ldd	r25, Z+36	; 0x24
    4282:	a5 a1       	ldd	r26, Z+37	; 0x25
    4284:	b6 a1       	ldd	r27, Z+38	; 0x26
    4286:	01 96       	adiw	r24, 0x01	; 1
    4288:	a1 1d       	adc	r26, r1
    428a:	b1 1d       	adc	r27, r1
    428c:	eb 81       	ldd	r30, Y+3	; 0x03
    428e:	fc 81       	ldd	r31, Y+4	; 0x04
    4290:	83 a3       	std	Z+35, r24	; 0x23
    4292:	94 a3       	std	Z+36, r25	; 0x24
    4294:	a5 a3       	std	Z+37, r26	; 0x25
    4296:	b6 a3       	std	Z+38, r27	; 0x26
    4298:	1a c0       	rjmp	.+52     	; 0x42ce <xTaskGenericNotify+0x12a>
					break;

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    429a:	eb 81       	ldd	r30, Y+3	; 0x03
    429c:	fc 81       	ldd	r31, Y+4	; 0x04
    429e:	8f 81       	ldd	r24, Y+7	; 0x07
    42a0:	98 85       	ldd	r25, Y+8	; 0x08
    42a2:	a9 85       	ldd	r26, Y+9	; 0x09
    42a4:	ba 85       	ldd	r27, Y+10	; 0x0a
    42a6:	83 a3       	std	Z+35, r24	; 0x23
    42a8:	94 a3       	std	Z+36, r25	; 0x24
    42aa:	a5 a3       	std	Z+37, r26	; 0x25
    42ac:	b6 a3       	std	Z+38, r27	; 0x26
    42ae:	0f c0       	rjmp	.+30     	; 0x42ce <xTaskGenericNotify+0x12a>
					break;

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    42b0:	89 81       	ldd	r24, Y+1	; 0x01
    42b2:	82 30       	cpi	r24, 0x02	; 2
    42b4:	59 f0       	breq	.+22     	; 0x42cc <xTaskGenericNotify+0x128>
					{
						pxTCB->ulNotifiedValue = ulValue;
    42b6:	eb 81       	ldd	r30, Y+3	; 0x03
    42b8:	fc 81       	ldd	r31, Y+4	; 0x04
    42ba:	8f 81       	ldd	r24, Y+7	; 0x07
    42bc:	98 85       	ldd	r25, Y+8	; 0x08
    42be:	a9 85       	ldd	r26, Y+9	; 0x09
    42c0:	ba 85       	ldd	r27, Y+10	; 0x0a
    42c2:	83 a3       	std	Z+35, r24	; 0x23
    42c4:	94 a3       	std	Z+36, r25	; 0x24
    42c6:	a5 a3       	std	Z+37, r26	; 0x25
    42c8:	b6 a3       	std	Z+38, r27	; 0x26
    42ca:	01 c0       	rjmp	.+2      	; 0x42ce <xTaskGenericNotify+0x12a>
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    42cc:	1a 82       	std	Y+2, r1	; 0x02

			traceTASK_NOTIFY();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    42ce:	89 81       	ldd	r24, Y+1	; 0x01
    42d0:	81 30       	cpi	r24, 0x01	; 1
    42d2:	b9 f5       	brne	.+110    	; 0x4342 <xTaskGenericNotify+0x19e>
			{
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    42d4:	8b 81       	ldd	r24, Y+3	; 0x03
    42d6:	9c 81       	ldd	r25, Y+4	; 0x04
    42d8:	02 96       	adiw	r24, 0x02	; 2
    42da:	0e 94 c8 07 	call	0xf90	; 0xf90 <uxListRemove>
				prvAddTaskToReadyList( pxTCB );
    42de:	eb 81       	ldd	r30, Y+3	; 0x03
    42e0:	fc 81       	ldd	r31, Y+4	; 0x04
    42e2:	96 89       	ldd	r25, Z+22	; 0x16
    42e4:	80 91 5e 06 	lds	r24, 0x065E
    42e8:	89 17       	cp	r24, r25
    42ea:	28 f4       	brcc	.+10     	; 0x42f6 <xTaskGenericNotify+0x152>
    42ec:	eb 81       	ldd	r30, Y+3	; 0x03
    42ee:	fc 81       	ldd	r31, Y+4	; 0x04
    42f0:	86 89       	ldd	r24, Z+22	; 0x16
    42f2:	80 93 5e 06 	sts	0x065E, r24
    42f6:	eb 81       	ldd	r30, Y+3	; 0x03
    42f8:	fc 81       	ldd	r31, Y+4	; 0x04
    42fa:	86 89       	ldd	r24, Z+22	; 0x16
    42fc:	28 2f       	mov	r18, r24
    42fe:	30 e0       	ldi	r19, 0x00	; 0
    4300:	c9 01       	movw	r24, r18
    4302:	88 0f       	add	r24, r24
    4304:	99 1f       	adc	r25, r25
    4306:	88 0f       	add	r24, r24
    4308:	99 1f       	adc	r25, r25
    430a:	88 0f       	add	r24, r24
    430c:	99 1f       	adc	r25, r25
    430e:	82 0f       	add	r24, r18
    4310:	93 1f       	adc	r25, r19
    4312:	ac 01       	movw	r20, r24
    4314:	47 59       	subi	r20, 0x97	; 151
    4316:	59 4f       	sbci	r21, 0xF9	; 249
    4318:	8b 81       	ldd	r24, Y+3	; 0x03
    431a:	9c 81       	ldd	r25, Y+4	; 0x04
    431c:	9c 01       	movw	r18, r24
    431e:	2e 5f       	subi	r18, 0xFE	; 254
    4320:	3f 4f       	sbci	r19, 0xFF	; 255
    4322:	ca 01       	movw	r24, r20
    4324:	b9 01       	movw	r22, r18
    4326:	0e 94 18 07 	call	0xe30	; 0xe30 <vListInsertEnd>
					earliest possible time. */
					prvResetNextTaskUnblockTime();
				}
				#endif

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    432a:	eb 81       	ldd	r30, Y+3	; 0x03
    432c:	fc 81       	ldd	r31, Y+4	; 0x04
    432e:	96 89       	ldd	r25, Z+22	; 0x16
    4330:	e0 91 58 06 	lds	r30, 0x0658
    4334:	f0 91 59 06 	lds	r31, 0x0659
    4338:	86 89       	ldd	r24, Z+22	; 0x16
    433a:	89 17       	cp	r24, r25
    433c:	10 f4       	brcc	.+4      	; 0x4342 <xTaskGenericNotify+0x19e>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					taskYIELD_IF_USING_PREEMPTION();
    433e:	0e 94 08 02 	call	0x410	; 0x410 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    4342:	0f 90       	pop	r0
    4344:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    4346:	8a 81       	ldd	r24, Y+2	; 0x02
	}
    4348:	2f 96       	adiw	r28, 0x0f	; 15
    434a:	0f b6       	in	r0, 0x3f	; 63
    434c:	f8 94       	cli
    434e:	de bf       	out	0x3e, r29	; 62
    4350:	0f be       	out	0x3f, r0	; 63
    4352:	cd bf       	out	0x3d, r28	; 61
    4354:	cf 91       	pop	r28
    4356:	df 91       	pop	r29
    4358:	1f 91       	pop	r17
    435a:	0f 91       	pop	r16
    435c:	08 95       	ret

0000435e <xTaskGenericNotifyFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
    435e:	ef 92       	push	r14
    4360:	ff 92       	push	r15
    4362:	0f 93       	push	r16
    4364:	1f 93       	push	r17
    4366:	df 93       	push	r29
    4368:	cf 93       	push	r28
    436a:	cd b7       	in	r28, 0x3d	; 61
    436c:	de b7       	in	r29, 0x3e	; 62
    436e:	62 97       	sbiw	r28, 0x12	; 18
    4370:	0f b6       	in	r0, 0x3f	; 63
    4372:	f8 94       	cli
    4374:	de bf       	out	0x3e, r29	; 62
    4376:	0f be       	out	0x3f, r0	; 63
    4378:	cd bf       	out	0x3d, r28	; 61
    437a:	9f 83       	std	Y+7, r25	; 0x07
    437c:	8e 83       	std	Y+6, r24	; 0x06
    437e:	48 87       	std	Y+8, r20	; 0x08
    4380:	59 87       	std	Y+9, r21	; 0x09
    4382:	6a 87       	std	Y+10, r22	; 0x0a
    4384:	7b 87       	std	Y+11, r23	; 0x0b
    4386:	2c 87       	std	Y+12, r18	; 0x0c
    4388:	1e 87       	std	Y+14, r17	; 0x0e
    438a:	0d 87       	std	Y+13, r16	; 0x0d
    438c:	f8 8a       	std	Y+16, r15	; 0x10
    438e:	ef 86       	std	Y+15, r14	; 0x0f
	TCB_t * pxTCB;
	uint8_t ucOriginalNotifyState;
	BaseType_t xReturn = pdPASS;
    4390:	81 e0       	ldi	r24, 0x01	; 1
    4392:	8a 83       	std	Y+2, r24	; 0x02
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = xTaskToNotify;
    4394:	8e 81       	ldd	r24, Y+6	; 0x06
    4396:	9f 81       	ldd	r25, Y+7	; 0x07
    4398:	9d 83       	std	Y+5, r25	; 0x05
    439a:	8c 83       	std	Y+4, r24	; 0x04

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    439c:	19 82       	std	Y+1, r1	; 0x01
		{
			if( pulPreviousNotificationValue != NULL )
    439e:	8d 85       	ldd	r24, Y+13	; 0x0d
    43a0:	9e 85       	ldd	r25, Y+14	; 0x0e
    43a2:	00 97       	sbiw	r24, 0x00	; 0
    43a4:	61 f0       	breq	.+24     	; 0x43be <xTaskGenericNotifyFromISR+0x60>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    43a6:	ec 81       	ldd	r30, Y+4	; 0x04
    43a8:	fd 81       	ldd	r31, Y+5	; 0x05
    43aa:	83 a1       	ldd	r24, Z+35	; 0x23
    43ac:	94 a1       	ldd	r25, Z+36	; 0x24
    43ae:	a5 a1       	ldd	r26, Z+37	; 0x25
    43b0:	b6 a1       	ldd	r27, Z+38	; 0x26
    43b2:	ed 85       	ldd	r30, Y+13	; 0x0d
    43b4:	fe 85       	ldd	r31, Y+14	; 0x0e
    43b6:	80 83       	st	Z, r24
    43b8:	91 83       	std	Z+1, r25	; 0x01
    43ba:	a2 83       	std	Z+2, r26	; 0x02
    43bc:	b3 83       	std	Z+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    43be:	ec 81       	ldd	r30, Y+4	; 0x04
    43c0:	fd 81       	ldd	r31, Y+5	; 0x05
    43c2:	87 a1       	ldd	r24, Z+39	; 0x27
    43c4:	8b 83       	std	Y+3, r24	; 0x03
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    43c6:	ec 81       	ldd	r30, Y+4	; 0x04
    43c8:	fd 81       	ldd	r31, Y+5	; 0x05
    43ca:	82 e0       	ldi	r24, 0x02	; 2
    43cc:	87 a3       	std	Z+39, r24	; 0x27

			switch( eAction )
    43ce:	8c 85       	ldd	r24, Y+12	; 0x0c
    43d0:	28 2f       	mov	r18, r24
    43d2:	30 e0       	ldi	r19, 0x00	; 0
    43d4:	3a 8b       	std	Y+18, r19	; 0x12
    43d6:	29 8b       	std	Y+17, r18	; 0x11
    43d8:	89 89       	ldd	r24, Y+17	; 0x11
    43da:	9a 89       	ldd	r25, Y+18	; 0x12
    43dc:	82 30       	cpi	r24, 0x02	; 2
    43de:	91 05       	cpc	r25, r1
    43e0:	59 f1       	breq	.+86     	; 0x4438 <xTaskGenericNotifyFromISR+0xda>
    43e2:	29 89       	ldd	r18, Y+17	; 0x11
    43e4:	3a 89       	ldd	r19, Y+18	; 0x12
    43e6:	23 30       	cpi	r18, 0x03	; 3
    43e8:	31 05       	cpc	r19, r1
    43ea:	34 f4       	brge	.+12     	; 0x43f8 <xTaskGenericNotifyFromISR+0x9a>
    43ec:	89 89       	ldd	r24, Y+17	; 0x11
    43ee:	9a 89       	ldd	r25, Y+18	; 0x12
    43f0:	81 30       	cpi	r24, 0x01	; 1
    43f2:	91 05       	cpc	r25, r1
    43f4:	61 f0       	breq	.+24     	; 0x440e <xTaskGenericNotifyFromISR+0xb0>
    43f6:	4a c0       	rjmp	.+148    	; 0x448c <xTaskGenericNotifyFromISR+0x12e>
    43f8:	29 89       	ldd	r18, Y+17	; 0x11
    43fa:	3a 89       	ldd	r19, Y+18	; 0x12
    43fc:	23 30       	cpi	r18, 0x03	; 3
    43fe:	31 05       	cpc	r19, r1
    4400:	59 f1       	breq	.+86     	; 0x4458 <xTaskGenericNotifyFromISR+0xfa>
    4402:	89 89       	ldd	r24, Y+17	; 0x11
    4404:	9a 89       	ldd	r25, Y+18	; 0x12
    4406:	84 30       	cpi	r24, 0x04	; 4
    4408:	91 05       	cpc	r25, r1
    440a:	89 f1       	breq	.+98     	; 0x446e <xTaskGenericNotifyFromISR+0x110>
    440c:	3f c0       	rjmp	.+126    	; 0x448c <xTaskGenericNotifyFromISR+0x12e>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    440e:	ec 81       	ldd	r30, Y+4	; 0x04
    4410:	fd 81       	ldd	r31, Y+5	; 0x05
    4412:	23 a1       	ldd	r18, Z+35	; 0x23
    4414:	34 a1       	ldd	r19, Z+36	; 0x24
    4416:	45 a1       	ldd	r20, Z+37	; 0x25
    4418:	56 a1       	ldd	r21, Z+38	; 0x26
    441a:	88 85       	ldd	r24, Y+8	; 0x08
    441c:	99 85       	ldd	r25, Y+9	; 0x09
    441e:	aa 85       	ldd	r26, Y+10	; 0x0a
    4420:	bb 85       	ldd	r27, Y+11	; 0x0b
    4422:	82 2b       	or	r24, r18
    4424:	93 2b       	or	r25, r19
    4426:	a4 2b       	or	r26, r20
    4428:	b5 2b       	or	r27, r21
    442a:	ec 81       	ldd	r30, Y+4	; 0x04
    442c:	fd 81       	ldd	r31, Y+5	; 0x05
    442e:	83 a3       	std	Z+35, r24	; 0x23
    4430:	94 a3       	std	Z+36, r25	; 0x24
    4432:	a5 a3       	std	Z+37, r26	; 0x25
    4434:	b6 a3       	std	Z+38, r27	; 0x26
    4436:	2a c0       	rjmp	.+84     	; 0x448c <xTaskGenericNotifyFromISR+0x12e>
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    4438:	ec 81       	ldd	r30, Y+4	; 0x04
    443a:	fd 81       	ldd	r31, Y+5	; 0x05
    443c:	83 a1       	ldd	r24, Z+35	; 0x23
    443e:	94 a1       	ldd	r25, Z+36	; 0x24
    4440:	a5 a1       	ldd	r26, Z+37	; 0x25
    4442:	b6 a1       	ldd	r27, Z+38	; 0x26
    4444:	01 96       	adiw	r24, 0x01	; 1
    4446:	a1 1d       	adc	r26, r1
    4448:	b1 1d       	adc	r27, r1
    444a:	ec 81       	ldd	r30, Y+4	; 0x04
    444c:	fd 81       	ldd	r31, Y+5	; 0x05
    444e:	83 a3       	std	Z+35, r24	; 0x23
    4450:	94 a3       	std	Z+36, r25	; 0x24
    4452:	a5 a3       	std	Z+37, r26	; 0x25
    4454:	b6 a3       	std	Z+38, r27	; 0x26
    4456:	1a c0       	rjmp	.+52     	; 0x448c <xTaskGenericNotifyFromISR+0x12e>
					break;

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    4458:	ec 81       	ldd	r30, Y+4	; 0x04
    445a:	fd 81       	ldd	r31, Y+5	; 0x05
    445c:	88 85       	ldd	r24, Y+8	; 0x08
    445e:	99 85       	ldd	r25, Y+9	; 0x09
    4460:	aa 85       	ldd	r26, Y+10	; 0x0a
    4462:	bb 85       	ldd	r27, Y+11	; 0x0b
    4464:	83 a3       	std	Z+35, r24	; 0x23
    4466:	94 a3       	std	Z+36, r25	; 0x24
    4468:	a5 a3       	std	Z+37, r26	; 0x25
    446a:	b6 a3       	std	Z+38, r27	; 0x26
    446c:	0f c0       	rjmp	.+30     	; 0x448c <xTaskGenericNotifyFromISR+0x12e>
					break;

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    446e:	8b 81       	ldd	r24, Y+3	; 0x03
    4470:	82 30       	cpi	r24, 0x02	; 2
    4472:	59 f0       	breq	.+22     	; 0x448a <xTaskGenericNotifyFromISR+0x12c>
					{
						pxTCB->ulNotifiedValue = ulValue;
    4474:	ec 81       	ldd	r30, Y+4	; 0x04
    4476:	fd 81       	ldd	r31, Y+5	; 0x05
    4478:	88 85       	ldd	r24, Y+8	; 0x08
    447a:	99 85       	ldd	r25, Y+9	; 0x09
    447c:	aa 85       	ldd	r26, Y+10	; 0x0a
    447e:	bb 85       	ldd	r27, Y+11	; 0x0b
    4480:	83 a3       	std	Z+35, r24	; 0x23
    4482:	94 a3       	std	Z+36, r25	; 0x24
    4484:	a5 a3       	std	Z+37, r26	; 0x25
    4486:	b6 a3       	std	Z+38, r27	; 0x26
    4488:	01 c0       	rjmp	.+2      	; 0x448c <xTaskGenericNotifyFromISR+0x12e>
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    448a:	1a 82       	std	Y+2, r1	; 0x02

			traceTASK_NOTIFY_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    448c:	8b 81       	ldd	r24, Y+3	; 0x03
    448e:	81 30       	cpi	r24, 0x01	; 1
    4490:	09 f0       	breq	.+2      	; 0x4494 <xTaskGenericNotifyFromISR+0x136>
    4492:	4f c0       	rjmp	.+158    	; 0x4532 <xTaskGenericNotifyFromISR+0x1d4>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    4494:	80 91 68 06 	lds	r24, 0x0668
    4498:	88 23       	and	r24, r24
    449a:	61 f5       	brne	.+88     	; 0x44f4 <xTaskGenericNotifyFromISR+0x196>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    449c:	8c 81       	ldd	r24, Y+4	; 0x04
    449e:	9d 81       	ldd	r25, Y+5	; 0x05
    44a0:	02 96       	adiw	r24, 0x02	; 2
    44a2:	0e 94 c8 07 	call	0xf90	; 0xf90 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    44a6:	ec 81       	ldd	r30, Y+4	; 0x04
    44a8:	fd 81       	ldd	r31, Y+5	; 0x05
    44aa:	96 89       	ldd	r25, Z+22	; 0x16
    44ac:	80 91 5e 06 	lds	r24, 0x065E
    44b0:	89 17       	cp	r24, r25
    44b2:	28 f4       	brcc	.+10     	; 0x44be <xTaskGenericNotifyFromISR+0x160>
    44b4:	ec 81       	ldd	r30, Y+4	; 0x04
    44b6:	fd 81       	ldd	r31, Y+5	; 0x05
    44b8:	86 89       	ldd	r24, Z+22	; 0x16
    44ba:	80 93 5e 06 	sts	0x065E, r24
    44be:	ec 81       	ldd	r30, Y+4	; 0x04
    44c0:	fd 81       	ldd	r31, Y+5	; 0x05
    44c2:	86 89       	ldd	r24, Z+22	; 0x16
    44c4:	28 2f       	mov	r18, r24
    44c6:	30 e0       	ldi	r19, 0x00	; 0
    44c8:	c9 01       	movw	r24, r18
    44ca:	88 0f       	add	r24, r24
    44cc:	99 1f       	adc	r25, r25
    44ce:	88 0f       	add	r24, r24
    44d0:	99 1f       	adc	r25, r25
    44d2:	88 0f       	add	r24, r24
    44d4:	99 1f       	adc	r25, r25
    44d6:	82 0f       	add	r24, r18
    44d8:	93 1f       	adc	r25, r19
    44da:	ac 01       	movw	r20, r24
    44dc:	47 59       	subi	r20, 0x97	; 151
    44de:	59 4f       	sbci	r21, 0xF9	; 249
    44e0:	8c 81       	ldd	r24, Y+4	; 0x04
    44e2:	9d 81       	ldd	r25, Y+5	; 0x05
    44e4:	9c 01       	movw	r18, r24
    44e6:	2e 5f       	subi	r18, 0xFE	; 254
    44e8:	3f 4f       	sbci	r19, 0xFF	; 255
    44ea:	ca 01       	movw	r24, r20
    44ec:	b9 01       	movw	r22, r18
    44ee:	0e 94 18 07 	call	0xe30	; 0xe30 <vListInsertEnd>
    44f2:	0a c0       	rjmp	.+20     	; 0x4508 <xTaskGenericNotifyFromISR+0x1aa>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    44f4:	8c 81       	ldd	r24, Y+4	; 0x04
    44f6:	9d 81       	ldd	r25, Y+5	; 0x05
    44f8:	9c 01       	movw	r18, r24
    44fa:	24 5f       	subi	r18, 0xF4	; 244
    44fc:	3f 4f       	sbci	r19, 0xFF	; 255
    44fe:	83 ea       	ldi	r24, 0xA3	; 163
    4500:	96 e0       	ldi	r25, 0x06	; 6
    4502:	b9 01       	movw	r22, r18
    4504:	0e 94 18 07 	call	0xe30	; 0xe30 <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    4508:	ec 81       	ldd	r30, Y+4	; 0x04
    450a:	fd 81       	ldd	r31, Y+5	; 0x05
    450c:	96 89       	ldd	r25, Z+22	; 0x16
    450e:	e0 91 58 06 	lds	r30, 0x0658
    4512:	f0 91 59 06 	lds	r31, 0x0659
    4516:	86 89       	ldd	r24, Z+22	; 0x16
    4518:	89 17       	cp	r24, r25
    451a:	58 f4       	brcc	.+22     	; 0x4532 <xTaskGenericNotifyFromISR+0x1d4>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    451c:	8f 85       	ldd	r24, Y+15	; 0x0f
    451e:	98 89       	ldd	r25, Y+16	; 0x10
    4520:	00 97       	sbiw	r24, 0x00	; 0
    4522:	21 f0       	breq	.+8      	; 0x452c <xTaskGenericNotifyFromISR+0x1ce>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    4524:	ef 85       	ldd	r30, Y+15	; 0x0f
    4526:	f8 89       	ldd	r31, Y+16	; 0x10
    4528:	81 e0       	ldi	r24, 0x01	; 1
    452a:	80 83       	st	Z, r24
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter to an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
    452c:	81 e0       	ldi	r24, 0x01	; 1
    452e:	80 93 61 06 	sts	0x0661, r24
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xReturn;
    4532:	8a 81       	ldd	r24, Y+2	; 0x02
	}
    4534:	62 96       	adiw	r28, 0x12	; 18
    4536:	0f b6       	in	r0, 0x3f	; 63
    4538:	f8 94       	cli
    453a:	de bf       	out	0x3e, r29	; 62
    453c:	0f be       	out	0x3f, r0	; 63
    453e:	cd bf       	out	0x3d, r28	; 61
    4540:	cf 91       	pop	r28
    4542:	df 91       	pop	r29
    4544:	1f 91       	pop	r17
    4546:	0f 91       	pop	r16
    4548:	ff 90       	pop	r15
    454a:	ef 90       	pop	r14
    454c:	08 95       	ret

0000454e <vTaskNotifyGiveFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
	{
    454e:	df 93       	push	r29
    4550:	cf 93       	push	r28
    4552:	cd b7       	in	r28, 0x3d	; 61
    4554:	de b7       	in	r29, 0x3e	; 62
    4556:	28 97       	sbiw	r28, 0x08	; 8
    4558:	0f b6       	in	r0, 0x3f	; 63
    455a:	f8 94       	cli
    455c:	de bf       	out	0x3e, r29	; 62
    455e:	0f be       	out	0x3f, r0	; 63
    4560:	cd bf       	out	0x3d, r28	; 61
    4562:	9e 83       	std	Y+6, r25	; 0x06
    4564:	8d 83       	std	Y+5, r24	; 0x05
    4566:	78 87       	std	Y+8, r23	; 0x08
    4568:	6f 83       	std	Y+7, r22	; 0x07
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = xTaskToNotify;
    456a:	8d 81       	ldd	r24, Y+5	; 0x05
    456c:	9e 81       	ldd	r25, Y+6	; 0x06
    456e:	9c 83       	std	Y+4, r25	; 0x04
    4570:	8b 83       	std	Y+3, r24	; 0x03

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    4572:	19 82       	std	Y+1, r1	; 0x01
		{
			ucOriginalNotifyState = pxTCB->ucNotifyState;
    4574:	eb 81       	ldd	r30, Y+3	; 0x03
    4576:	fc 81       	ldd	r31, Y+4	; 0x04
    4578:	87 a1       	ldd	r24, Z+39	; 0x27
    457a:	8a 83       	std	Y+2, r24	; 0x02
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    457c:	eb 81       	ldd	r30, Y+3	; 0x03
    457e:	fc 81       	ldd	r31, Y+4	; 0x04
    4580:	82 e0       	ldi	r24, 0x02	; 2
    4582:	87 a3       	std	Z+39, r24	; 0x27

			/* 'Giving' is equivalent to incrementing a count in a counting
			semaphore. */
			( pxTCB->ulNotifiedValue )++;
    4584:	eb 81       	ldd	r30, Y+3	; 0x03
    4586:	fc 81       	ldd	r31, Y+4	; 0x04
    4588:	83 a1       	ldd	r24, Z+35	; 0x23
    458a:	94 a1       	ldd	r25, Z+36	; 0x24
    458c:	a5 a1       	ldd	r26, Z+37	; 0x25
    458e:	b6 a1       	ldd	r27, Z+38	; 0x26
    4590:	01 96       	adiw	r24, 0x01	; 1
    4592:	a1 1d       	adc	r26, r1
    4594:	b1 1d       	adc	r27, r1
    4596:	eb 81       	ldd	r30, Y+3	; 0x03
    4598:	fc 81       	ldd	r31, Y+4	; 0x04
    459a:	83 a3       	std	Z+35, r24	; 0x23
    459c:	94 a3       	std	Z+36, r25	; 0x24
    459e:	a5 a3       	std	Z+37, r26	; 0x25
    45a0:	b6 a3       	std	Z+38, r27	; 0x26

			traceTASK_NOTIFY_GIVE_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    45a2:	8a 81       	ldd	r24, Y+2	; 0x02
    45a4:	81 30       	cpi	r24, 0x01	; 1
    45a6:	09 f0       	breq	.+2      	; 0x45aa <vTaskNotifyGiveFromISR+0x5c>
    45a8:	4f c0       	rjmp	.+158    	; 0x4648 <vTaskNotifyGiveFromISR+0xfa>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    45aa:	80 91 68 06 	lds	r24, 0x0668
    45ae:	88 23       	and	r24, r24
    45b0:	61 f5       	brne	.+88     	; 0x460a <vTaskNotifyGiveFromISR+0xbc>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    45b2:	8b 81       	ldd	r24, Y+3	; 0x03
    45b4:	9c 81       	ldd	r25, Y+4	; 0x04
    45b6:	02 96       	adiw	r24, 0x02	; 2
    45b8:	0e 94 c8 07 	call	0xf90	; 0xf90 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    45bc:	eb 81       	ldd	r30, Y+3	; 0x03
    45be:	fc 81       	ldd	r31, Y+4	; 0x04
    45c0:	96 89       	ldd	r25, Z+22	; 0x16
    45c2:	80 91 5e 06 	lds	r24, 0x065E
    45c6:	89 17       	cp	r24, r25
    45c8:	28 f4       	brcc	.+10     	; 0x45d4 <vTaskNotifyGiveFromISR+0x86>
    45ca:	eb 81       	ldd	r30, Y+3	; 0x03
    45cc:	fc 81       	ldd	r31, Y+4	; 0x04
    45ce:	86 89       	ldd	r24, Z+22	; 0x16
    45d0:	80 93 5e 06 	sts	0x065E, r24
    45d4:	eb 81       	ldd	r30, Y+3	; 0x03
    45d6:	fc 81       	ldd	r31, Y+4	; 0x04
    45d8:	86 89       	ldd	r24, Z+22	; 0x16
    45da:	28 2f       	mov	r18, r24
    45dc:	30 e0       	ldi	r19, 0x00	; 0
    45de:	c9 01       	movw	r24, r18
    45e0:	88 0f       	add	r24, r24
    45e2:	99 1f       	adc	r25, r25
    45e4:	88 0f       	add	r24, r24
    45e6:	99 1f       	adc	r25, r25
    45e8:	88 0f       	add	r24, r24
    45ea:	99 1f       	adc	r25, r25
    45ec:	82 0f       	add	r24, r18
    45ee:	93 1f       	adc	r25, r19
    45f0:	ac 01       	movw	r20, r24
    45f2:	47 59       	subi	r20, 0x97	; 151
    45f4:	59 4f       	sbci	r21, 0xF9	; 249
    45f6:	8b 81       	ldd	r24, Y+3	; 0x03
    45f8:	9c 81       	ldd	r25, Y+4	; 0x04
    45fa:	9c 01       	movw	r18, r24
    45fc:	2e 5f       	subi	r18, 0xFE	; 254
    45fe:	3f 4f       	sbci	r19, 0xFF	; 255
    4600:	ca 01       	movw	r24, r20
    4602:	b9 01       	movw	r22, r18
    4604:	0e 94 18 07 	call	0xe30	; 0xe30 <vListInsertEnd>
    4608:	0a c0       	rjmp	.+20     	; 0x461e <vTaskNotifyGiveFromISR+0xd0>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    460a:	8b 81       	ldd	r24, Y+3	; 0x03
    460c:	9c 81       	ldd	r25, Y+4	; 0x04
    460e:	9c 01       	movw	r18, r24
    4610:	24 5f       	subi	r18, 0xF4	; 244
    4612:	3f 4f       	sbci	r19, 0xFF	; 255
    4614:	83 ea       	ldi	r24, 0xA3	; 163
    4616:	96 e0       	ldi	r25, 0x06	; 6
    4618:	b9 01       	movw	r22, r18
    461a:	0e 94 18 07 	call	0xe30	; 0xe30 <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    461e:	eb 81       	ldd	r30, Y+3	; 0x03
    4620:	fc 81       	ldd	r31, Y+4	; 0x04
    4622:	96 89       	ldd	r25, Z+22	; 0x16
    4624:	e0 91 58 06 	lds	r30, 0x0658
    4628:	f0 91 59 06 	lds	r31, 0x0659
    462c:	86 89       	ldd	r24, Z+22	; 0x16
    462e:	89 17       	cp	r24, r25
    4630:	58 f4       	brcc	.+22     	; 0x4648 <vTaskNotifyGiveFromISR+0xfa>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    4632:	8f 81       	ldd	r24, Y+7	; 0x07
    4634:	98 85       	ldd	r25, Y+8	; 0x08
    4636:	00 97       	sbiw	r24, 0x00	; 0
    4638:	21 f0       	breq	.+8      	; 0x4642 <vTaskNotifyGiveFromISR+0xf4>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    463a:	ef 81       	ldd	r30, Y+7	; 0x07
    463c:	f8 85       	ldd	r31, Y+8	; 0x08
    463e:	81 e0       	ldi	r24, 0x01	; 1
    4640:	80 83       	st	Z, r24
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter in an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
    4642:	81 e0       	ldi	r24, 0x01	; 1
    4644:	80 93 61 06 	sts	0x0661, r24
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
	}
    4648:	28 96       	adiw	r28, 0x08	; 8
    464a:	0f b6       	in	r0, 0x3f	; 63
    464c:	f8 94       	cli
    464e:	de bf       	out	0x3e, r29	; 62
    4650:	0f be       	out	0x3f, r0	; 63
    4652:	cd bf       	out	0x3d, r28	; 61
    4654:	cf 91       	pop	r28
    4656:	df 91       	pop	r29
    4658:	08 95       	ret

0000465a <xTaskNotifyStateClear>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyStateClear( TaskHandle_t xTask )
	{
    465a:	df 93       	push	r29
    465c:	cf 93       	push	r28
    465e:	cd b7       	in	r28, 0x3d	; 61
    4660:	de b7       	in	r29, 0x3e	; 62
    4662:	27 97       	sbiw	r28, 0x07	; 7
    4664:	0f b6       	in	r0, 0x3f	; 63
    4666:	f8 94       	cli
    4668:	de bf       	out	0x3e, r29	; 62
    466a:	0f be       	out	0x3f, r0	; 63
    466c:	cd bf       	out	0x3d, r28	; 61
    466e:	9d 83       	std	Y+5, r25	; 0x05
    4670:	8c 83       	std	Y+4, r24	; 0x04
	TCB_t *pxTCB;
	BaseType_t xReturn;

		/* If null is passed in here then it is the calling task that is having
		its notification state cleared. */
		pxTCB = prvGetTCBFromHandle( xTask );
    4672:	8c 81       	ldd	r24, Y+4	; 0x04
    4674:	9d 81       	ldd	r25, Y+5	; 0x05
    4676:	00 97       	sbiw	r24, 0x00	; 0
    4678:	39 f4       	brne	.+14     	; 0x4688 <xTaskNotifyStateClear+0x2e>
    467a:	80 91 58 06 	lds	r24, 0x0658
    467e:	90 91 59 06 	lds	r25, 0x0659
    4682:	9f 83       	std	Y+7, r25	; 0x07
    4684:	8e 83       	std	Y+6, r24	; 0x06
    4686:	04 c0       	rjmp	.+8      	; 0x4690 <xTaskNotifyStateClear+0x36>
    4688:	8c 81       	ldd	r24, Y+4	; 0x04
    468a:	9d 81       	ldd	r25, Y+5	; 0x05
    468c:	9f 83       	std	Y+7, r25	; 0x07
    468e:	8e 83       	std	Y+6, r24	; 0x06
    4690:	8e 81       	ldd	r24, Y+6	; 0x06
    4692:	9f 81       	ldd	r25, Y+7	; 0x07
    4694:	9b 83       	std	Y+3, r25	; 0x03
    4696:	8a 83       	std	Y+2, r24	; 0x02

		taskENTER_CRITICAL();
    4698:	0f b6       	in	r0, 0x3f	; 63
    469a:	f8 94       	cli
    469c:	0f 92       	push	r0
		{
			if( pxTCB->ucNotifyState == taskNOTIFICATION_RECEIVED )
    469e:	ea 81       	ldd	r30, Y+2	; 0x02
    46a0:	fb 81       	ldd	r31, Y+3	; 0x03
    46a2:	87 a1       	ldd	r24, Z+39	; 0x27
    46a4:	82 30       	cpi	r24, 0x02	; 2
    46a6:	31 f4       	brne	.+12     	; 0x46b4 <xTaskNotifyStateClear+0x5a>
			{
				pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    46a8:	ea 81       	ldd	r30, Y+2	; 0x02
    46aa:	fb 81       	ldd	r31, Y+3	; 0x03
    46ac:	17 a2       	std	Z+39, r1	; 0x27
				xReturn = pdPASS;
    46ae:	81 e0       	ldi	r24, 0x01	; 1
    46b0:	89 83       	std	Y+1, r24	; 0x01
    46b2:	01 c0       	rjmp	.+2      	; 0x46b6 <xTaskNotifyStateClear+0x5c>
			}
			else
			{
				xReturn = pdFAIL;
    46b4:	19 82       	std	Y+1, r1	; 0x01
			}
		}
		taskEXIT_CRITICAL();
    46b6:	0f 90       	pop	r0
    46b8:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    46ba:	89 81       	ldd	r24, Y+1	; 0x01
	}
    46bc:	27 96       	adiw	r28, 0x07	; 7
    46be:	0f b6       	in	r0, 0x3f	; 63
    46c0:	f8 94       	cli
    46c2:	de bf       	out	0x3e, r29	; 62
    46c4:	0f be       	out	0x3f, r0	; 63
    46c6:	cd bf       	out	0x3d, r28	; 61
    46c8:	cf 91       	pop	r28
    46ca:	df 91       	pop	r29
    46cc:	08 95       	ret

000046ce <prvAddCurrentTaskToDelayedList>:
	}
#endif
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
    46ce:	df 93       	push	r29
    46d0:	cf 93       	push	r28
    46d2:	cd b7       	in	r28, 0x3d	; 61
    46d4:	de b7       	in	r29, 0x3e	; 62
    46d6:	27 97       	sbiw	r28, 0x07	; 7
    46d8:	0f b6       	in	r0, 0x3f	; 63
    46da:	f8 94       	cli
    46dc:	de bf       	out	0x3e, r29	; 62
    46de:	0f be       	out	0x3f, r0	; 63
    46e0:	cd bf       	out	0x3d, r28	; 61
    46e2:	9e 83       	std	Y+6, r25	; 0x06
    46e4:	8d 83       	std	Y+5, r24	; 0x05
    46e6:	6f 83       	std	Y+7, r22	; 0x07
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
    46e8:	80 91 5c 06 	lds	r24, 0x065C
    46ec:	90 91 5d 06 	lds	r25, 0x065D
    46f0:	9a 83       	std	Y+2, r25	; 0x02
    46f2:	89 83       	std	Y+1, r24	; 0x01
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    46f4:	80 91 58 06 	lds	r24, 0x0658
    46f8:	90 91 59 06 	lds	r25, 0x0659
    46fc:	02 96       	adiw	r24, 0x02	; 2
    46fe:	0e 94 c8 07 	call	0xf90	; 0xf90 <uxListRemove>
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
    4702:	8d 81       	ldd	r24, Y+5	; 0x05
    4704:	9e 81       	ldd	r25, Y+6	; 0x06
    4706:	2f ef       	ldi	r18, 0xFF	; 255
    4708:	8f 3f       	cpi	r24, 0xFF	; 255
    470a:	92 07       	cpc	r25, r18
    470c:	81 f4       	brne	.+32     	; 0x472e <prvAddCurrentTaskToDelayedList+0x60>
    470e:	8f 81       	ldd	r24, Y+7	; 0x07
    4710:	88 23       	and	r24, r24
    4712:	69 f0       	breq	.+26     	; 0x472e <prvAddCurrentTaskToDelayedList+0x60>
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
    4714:	80 91 58 06 	lds	r24, 0x0658
    4718:	90 91 59 06 	lds	r25, 0x0659
    471c:	9c 01       	movw	r18, r24
    471e:	2e 5f       	subi	r18, 0xFE	; 254
    4720:	3f 4f       	sbci	r19, 0xFF	; 255
    4722:	85 eb       	ldi	r24, 0xB5	; 181
    4724:	96 e0       	ldi	r25, 0x06	; 6
    4726:	b9 01       	movw	r22, r18
    4728:	0e 94 18 07 	call	0xe30	; 0xe30 <vListInsertEnd>
    472c:	43 c0       	rjmp	.+134    	; 0x47b4 <prvAddCurrentTaskToDelayedList+0xe6>
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xConstTickCount + xTicksToWait;
    472e:	29 81       	ldd	r18, Y+1	; 0x01
    4730:	3a 81       	ldd	r19, Y+2	; 0x02
    4732:	8d 81       	ldd	r24, Y+5	; 0x05
    4734:	9e 81       	ldd	r25, Y+6	; 0x06
    4736:	82 0f       	add	r24, r18
    4738:	93 1f       	adc	r25, r19
    473a:	9c 83       	std	Y+4, r25	; 0x04
    473c:	8b 83       	std	Y+3, r24	; 0x03

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
    473e:	e0 91 58 06 	lds	r30, 0x0658
    4742:	f0 91 59 06 	lds	r31, 0x0659
    4746:	8b 81       	ldd	r24, Y+3	; 0x03
    4748:	9c 81       	ldd	r25, Y+4	; 0x04
    474a:	93 83       	std	Z+3, r25	; 0x03
    474c:	82 83       	std	Z+2, r24	; 0x02

			if( xTimeToWake < xConstTickCount )
    474e:	2b 81       	ldd	r18, Y+3	; 0x03
    4750:	3c 81       	ldd	r19, Y+4	; 0x04
    4752:	89 81       	ldd	r24, Y+1	; 0x01
    4754:	9a 81       	ldd	r25, Y+2	; 0x02
    4756:	28 17       	cp	r18, r24
    4758:	39 07       	cpc	r19, r25
    475a:	70 f4       	brcc	.+28     	; 0x4778 <prvAddCurrentTaskToDelayedList+0xaa>
			{
				/* Wake time has overflowed.  Place this item in the overflow
				list. */
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    475c:	80 91 a1 06 	lds	r24, 0x06A1
    4760:	90 91 a2 06 	lds	r25, 0x06A2
    4764:	20 91 58 06 	lds	r18, 0x0658
    4768:	30 91 59 06 	lds	r19, 0x0659
    476c:	2e 5f       	subi	r18, 0xFE	; 254
    476e:	3f 4f       	sbci	r19, 0xFF	; 255
    4770:	b9 01       	movw	r22, r18
    4772:	0e 94 5c 07 	call	0xeb8	; 0xeb8 <vListInsert>
    4776:	1e c0       	rjmp	.+60     	; 0x47b4 <prvAddCurrentTaskToDelayedList+0xe6>
			}
			else
			{
				/* The wake time has not overflowed, so the current block list
				is used. */
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    4778:	40 91 9f 06 	lds	r20, 0x069F
    477c:	50 91 a0 06 	lds	r21, 0x06A0
    4780:	80 91 58 06 	lds	r24, 0x0658
    4784:	90 91 59 06 	lds	r25, 0x0659
    4788:	9c 01       	movw	r18, r24
    478a:	2e 5f       	subi	r18, 0xFE	; 254
    478c:	3f 4f       	sbci	r19, 0xFF	; 255
    478e:	ca 01       	movw	r24, r20
    4790:	b9 01       	movw	r22, r18
    4792:	0e 94 5c 07 	call	0xeb8	; 0xeb8 <vListInsert>

				/* If the task entering the blocked state was placed at the
				head of the list of blocked tasks then xNextTaskUnblockTime
				needs to be updated too. */
				if( xTimeToWake < xNextTaskUnblockTime )
    4796:	20 91 64 06 	lds	r18, 0x0664
    479a:	30 91 65 06 	lds	r19, 0x0665
    479e:	8b 81       	ldd	r24, Y+3	; 0x03
    47a0:	9c 81       	ldd	r25, Y+4	; 0x04
    47a2:	82 17       	cp	r24, r18
    47a4:	93 07       	cpc	r25, r19
    47a6:	30 f4       	brcc	.+12     	; 0x47b4 <prvAddCurrentTaskToDelayedList+0xe6>
				{
					xNextTaskUnblockTime = xTimeToWake;
    47a8:	8b 81       	ldd	r24, Y+3	; 0x03
    47aa:	9c 81       	ldd	r25, Y+4	; 0x04
    47ac:	90 93 65 06 	sts	0x0665, r25
    47b0:	80 93 64 06 	sts	0x0664, r24

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    47b4:	27 96       	adiw	r28, 0x07	; 7
    47b6:	0f b6       	in	r0, 0x3f	; 63
    47b8:	f8 94       	cli
    47ba:	de bf       	out	0x3e, r29	; 62
    47bc:	0f be       	out	0x3f, r0	; 63
    47be:	cd bf       	out	0x3d, r28	; 61
    47c0:	cf 91       	pop	r28
    47c2:	df 91       	pop	r29
    47c4:	08 95       	ret

000047c6 <vLED>:
SemaphoreHandle_t binary_semaphore ;

/*lazem tkon paramter to void */

void vLED (void *pvParameter)
{
    47c6:	df 93       	push	r29
    47c8:	cf 93       	push	r28
    47ca:	00 d0       	rcall	.+0      	; 0x47cc <vLED+0x6>
    47cc:	cd b7       	in	r28, 0x3d	; 61
    47ce:	de b7       	in	r29, 0x3e	; 62
    47d0:	9a 83       	std	Y+2, r25	; 0x02
    47d2:	89 83       	std	Y+1, r24	; 0x01
	{
			/*handler , max waiting time in the status   blocking time is 100  )
	     * pdTRUE
	     * pdFalse failed
	     * */
		if (xSemaphoreTake(binary_semaphore,100)  != pdTRUE ) {
    47d4:	80 91 c4 06 	lds	r24, 0x06C4
    47d8:	90 91 c5 06 	lds	r25, 0x06C5
    47dc:	64 e6       	ldi	r22, 0x64	; 100
    47de:	70 e0       	ldi	r23, 0x00	; 0
    47e0:	0e 94 26 0b 	call	0x164c	; 0x164c <xQueueSemaphoreTake>
    47e4:	81 30       	cpi	r24, 0x01	; 1
    47e6:	41 f0       	breq	.+16     	; 0x47f8 <vLED+0x32>

			PORTC |= (1<<2);
    47e8:	a5 e3       	ldi	r26, 0x35	; 53
    47ea:	b0 e0       	ldi	r27, 0x00	; 0
    47ec:	e5 e3       	ldi	r30, 0x35	; 53
    47ee:	f0 e0       	ldi	r31, 0x00	; 0
    47f0:	80 81       	ld	r24, Z
    47f2:	84 60       	ori	r24, 0x04	; 4
    47f4:	8c 93       	st	X, r24
    47f6:	ee cf       	rjmp	.-36     	; 0x47d4 <vLED+0xe>
		}

		else {
 /*at starting semaphore is pdfalse and wat  for the next giving */

			PORTC &= ~(1<<2);
    47f8:	a5 e3       	ldi	r26, 0x35	; 53
    47fa:	b0 e0       	ldi	r27, 0x00	; 0
    47fc:	e5 e3       	ldi	r30, 0x35	; 53
    47fe:	f0 e0       	ldi	r31, 0x00	; 0
    4800:	80 81       	ld	r24, Z
    4802:	8b 7f       	andi	r24, 0xFB	; 251
    4804:	8c 93       	st	X, r24
    4806:	e6 cf       	rjmp	.-52     	; 0x47d4 <vLED+0xe>

00004808 <vButton>:
	return ;

}

void vButton (void *pvParameter)
{
    4808:	df 93       	push	r29
    480a:	cf 93       	push	r28
    480c:	00 d0       	rcall	.+0      	; 0x480e <vButton+0x6>
    480e:	cd b7       	in	r28, 0x3d	; 61
    4810:	de b7       	in	r29, 0x3e	; 62
    4812:	9a 83       	std	Y+2, r25	; 0x02
    4814:	89 83       	std	Y+1, r24	; 0x01

	for (;;)             //Extended task
	{
      if (((PIND >>0 )&1) == 0 )
    4816:	e0 e3       	ldi	r30, 0x30	; 48
    4818:	f0 e0       	ldi	r31, 0x00	; 0
    481a:	80 81       	ld	r24, Z
    481c:	88 2f       	mov	r24, r24
    481e:	90 e0       	ldi	r25, 0x00	; 0
    4820:	81 70       	andi	r24, 0x01	; 1
    4822:	90 70       	andi	r25, 0x00	; 0
    4824:	00 97       	sbiw	r24, 0x00	; 0
    4826:	59 f4       	brne	.+22     	; 0x483e <vButton+0x36>
		{
			xSemaphoreGive(binary_semaphore);
    4828:	80 91 c4 06 	lds	r24, 0x06C4
    482c:	90 91 c5 06 	lds	r25, 0x06C5
    4830:	60 e0       	ldi	r22, 0x00	; 0
    4832:	70 e0       	ldi	r23, 0x00	; 0
    4834:	40 e0       	ldi	r20, 0x00	; 0
    4836:	50 e0       	ldi	r21, 0x00	; 0
    4838:	20 e0       	ldi	r18, 0x00	; 0
    483a:	0e 94 26 09 	call	0x124c	; 0x124c <xQueueGenericSend>

		}
		vTaskDelay(50);   /*50 TICK WAITING */
    483e:	82 e3       	ldi	r24, 0x32	; 50
    4840:	90 e0       	ldi	r25, 0x00	; 0
    4842:	0e 94 e8 18 	call	0x31d0	; 0x31d0 <vTaskDelay>
    4846:	e7 cf       	rjmp	.-50     	; 0x4816 <vButton+0xe>

00004848 <vInit>:

}


void vInit (void *pvParameter)
{
    4848:	df 93       	push	r29
    484a:	cf 93       	push	r28
    484c:	00 d0       	rcall	.+0      	; 0x484e <vInit+0x6>
    484e:	cd b7       	in	r28, 0x3d	; 61
    4850:	de b7       	in	r29, 0x3e	; 62
    4852:	9a 83       	std	Y+2, r25	; 0x02
    4854:	89 83       	std	Y+1, r24	; 0x01

	for (;;)             //Extended task
	{
		DDRC |= (1<<2);
    4856:	a4 e3       	ldi	r26, 0x34	; 52
    4858:	b0 e0       	ldi	r27, 0x00	; 0
    485a:	e4 e3       	ldi	r30, 0x34	; 52
    485c:	f0 e0       	ldi	r31, 0x00	; 0
    485e:	80 81       	ld	r24, Z
    4860:	84 60       	ori	r24, 0x04	; 4
    4862:	8c 93       	st	X, r24
		DDRD &= ~(1<<0);
    4864:	a1 e3       	ldi	r26, 0x31	; 49
    4866:	b0 e0       	ldi	r27, 0x00	; 0
    4868:	e1 e3       	ldi	r30, 0x31	; 49
    486a:	f0 e0       	ldi	r31, 0x00	; 0
    486c:	80 81       	ld	r24, Z
    486e:	8e 7f       	andi	r24, 0xFE	; 254
    4870:	8c 93       	st	X, r24
		PORTD |= (1<<0);   /*CONNECT T O GND   Pull up  */
    4872:	a2 e3       	ldi	r26, 0x32	; 50
    4874:	b0 e0       	ldi	r27, 0x00	; 0
    4876:	e2 e3       	ldi	r30, 0x32	; 50
    4878:	f0 e0       	ldi	r31, 0x00	; 0
    487a:	80 81       	ld	r24, Z
    487c:	81 60       	ori	r24, 0x01	; 1
    487e:	8c 93       	st	X, r24
vTaskDelete(initTask_handler);   // or Null
    4880:	80 91 c2 06 	lds	r24, 0x06C2
    4884:	90 91 c3 06 	lds	r25, 0x06C3
    4888:	0e 94 76 18 	call	0x30ec	; 0x30ec <vTaskDelete>
    488c:	e4 cf       	rjmp	.-56     	; 0x4856 <vInit+0xe>

0000488e <main>:
	return ;

}


int main(){
    488e:	ef 92       	push	r14
    4890:	ff 92       	push	r15
    4892:	0f 93       	push	r16
    4894:	df 93       	push	r29
    4896:	cf 93       	push	r28
    4898:	cd b7       	in	r28, 0x3d	; 61
    489a:	de b7       	in	r29, 0x3e	; 62
 *
 * xTaskCreate   created in the heap
 * */


	xTaskCreate(vLED,"Task1",configMINIMAL_STACK_SIZE,NULL,1,&ledTask_handler);
    489c:	83 ee       	ldi	r24, 0xE3	; 227
    489e:	93 e2       	ldi	r25, 0x23	; 35
    48a0:	25 e6       	ldi	r18, 0x65	; 101
    48a2:	30 e0       	ldi	r19, 0x00	; 0
    48a4:	e0 ec       	ldi	r30, 0xC0	; 192
    48a6:	f6 e0       	ldi	r31, 0x06	; 6
    48a8:	b9 01       	movw	r22, r18
    48aa:	45 e5       	ldi	r20, 0x55	; 85
    48ac:	50 e0       	ldi	r21, 0x00	; 0
    48ae:	20 e0       	ldi	r18, 0x00	; 0
    48b0:	30 e0       	ldi	r19, 0x00	; 0
    48b2:	01 e0       	ldi	r16, 0x01	; 1
    48b4:	7f 01       	movw	r14, r30
    48b6:	0e 94 ca 16 	call	0x2d94	; 0x2d94 <xTaskCreate>
	xTaskCreate(vButton,"Task2",configMINIMAL_STACK_SIZE,NULL,2,&buttonTask_handler);
    48ba:	84 e0       	ldi	r24, 0x04	; 4
    48bc:	94 e2       	ldi	r25, 0x24	; 36
    48be:	2b e6       	ldi	r18, 0x6B	; 107
    48c0:	30 e0       	ldi	r19, 0x00	; 0
    48c2:	ee eb       	ldi	r30, 0xBE	; 190
    48c4:	f6 e0       	ldi	r31, 0x06	; 6
    48c6:	b9 01       	movw	r22, r18
    48c8:	45 e5       	ldi	r20, 0x55	; 85
    48ca:	50 e0       	ldi	r21, 0x00	; 0
    48cc:	20 e0       	ldi	r18, 0x00	; 0
    48ce:	30 e0       	ldi	r19, 0x00	; 0
    48d0:	02 e0       	ldi	r16, 0x02	; 2
    48d2:	7f 01       	movw	r14, r30
    48d4:	0e 94 ca 16 	call	0x2d94	; 0x2d94 <xTaskCreate>
	xTaskCreate(vInit,"Task3",configMINIMAL_STACK_SIZE,NULL,3,&initTask_handler);   // higher priority task
    48d8:	84 e2       	ldi	r24, 0x24	; 36
    48da:	94 e2       	ldi	r25, 0x24	; 36
    48dc:	21 e7       	ldi	r18, 0x71	; 113
    48de:	30 e0       	ldi	r19, 0x00	; 0
    48e0:	e2 ec       	ldi	r30, 0xC2	; 194
    48e2:	f6 e0       	ldi	r31, 0x06	; 6
    48e4:	b9 01       	movw	r22, r18
    48e6:	45 e5       	ldi	r20, 0x55	; 85
    48e8:	50 e0       	ldi	r21, 0x00	; 0
    48ea:	20 e0       	ldi	r18, 0x00	; 0
    48ec:	30 e0       	ldi	r19, 0x00	; 0
    48ee:	03 e0       	ldi	r16, 0x03	; 3
    48f0:	7f 01       	movw	r14, r30
    48f2:	0e 94 ca 16 	call	0x2d94	; 0x2d94 <xTaskCreate>

	binary_semaphore = xSemaphoreCreateBinary();
    48f6:	81 e0       	ldi	r24, 0x01	; 1
    48f8:	60 e0       	ldi	r22, 0x00	; 0
    48fa:	43 e0       	ldi	r20, 0x03	; 3
    48fc:	0e 94 9a 08 	call	0x1134	; 0x1134 <xQueueGenericCreate>
    4900:	90 93 c5 06 	sts	0x06C5, r25
    4904:	80 93 c4 06 	sts	0x06C4, r24

    vTaskStartScheduler();
    4908:	0e 94 77 1a 	call	0x34ee	; 0x34ee <vTaskStartScheduler>
    490c:	ff cf       	rjmp	.-2      	; 0x490c <main+0x7e>

0000490e <memcpy>:
    490e:	fb 01       	movw	r30, r22
    4910:	dc 01       	movw	r26, r24
    4912:	02 c0       	rjmp	.+4      	; 0x4918 <memcpy+0xa>
    4914:	01 90       	ld	r0, Z+
    4916:	0d 92       	st	X+, r0
    4918:	41 50       	subi	r20, 0x01	; 1
    491a:	50 40       	sbci	r21, 0x00	; 0
    491c:	d8 f7       	brcc	.-10     	; 0x4914 <memcpy+0x6>
    491e:	08 95       	ret

00004920 <memset>:
    4920:	dc 01       	movw	r26, r24
    4922:	01 c0       	rjmp	.+2      	; 0x4926 <memset+0x6>
    4924:	6d 93       	st	X+, r22
    4926:	41 50       	subi	r20, 0x01	; 1
    4928:	50 40       	sbci	r21, 0x00	; 0
    492a:	e0 f7       	brcc	.-8      	; 0x4924 <memset+0x4>
    492c:	08 95       	ret

0000492e <_exit>:
    492e:	f8 94       	cli

00004930 <__stop_program>:
    4930:	ff cf       	rjmp	.-2      	; 0x4930 <__stop_program>
